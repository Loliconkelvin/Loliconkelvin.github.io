<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"loliconkelvin.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.12.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":true,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content=".red {         color: red;     }     .bold {         font-weight: bold;     }   Java集合框架">
<meta property="og:type" content="article">
<meta property="og:title" content="Java集合框架">
<meta property="og:url" content="https://loliconkelvin.github.io/2022/04/11/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/index.html">
<meta property="og:site_name" content="萝莉控的小窝">
<meta property="og:description" content=".red {         color: red;     }     .bold {         font-weight: bold;     }   Java集合框架">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s1.ax1x.com/2022/04/12/LedjFf.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/04/12/LnYW0x.md.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/04/13/LuOijK.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/04/13/LuOZAH.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/04/16/LtYwD0.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/04/16/Lt0LY6.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/04/16/Lt0zOH.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/04/18/Ld6Aw8.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/04/19/L0hmU1.md.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/04/20/Lrp7TA.md.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/04/20/LrpYon.md.png">
<meta property="article:published_time" content="2022-04-11T14:20:27.000Z">
<meta property="article:modified_time" content="2022-06-19T13:40:07.600Z">
<meta property="article:author" content="Loliconkelvin">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s1.ax1x.com/2022/04/12/LedjFf.png">


<link rel="canonical" href="https://loliconkelvin.github.io/2022/04/11/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://loliconkelvin.github.io/2022/04/11/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/","path":"2022/04/11/Java集合框架/","title":"Java集合框架"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Java集合框架 | 萝莉控的小窝</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">萝莉控的小窝</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.</span> <span class="nav-text">集合是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Collection%E4%BD%93%E7%B3%BB%E9%9B%86%E5%90%88"><span class="nav-number">2.</span> <span class="nav-text">Collection体系集合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Collection%E7%88%B6%E6%8E%A5%E5%8F%A3"><span class="nav-number">3.</span> <span class="nav-text">Collection父接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#List%E5%AD%90%E6%8E%A5%E5%8F%A3"><span class="nav-number">4.</span> <span class="nav-text">List子接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#List%E5%AE%9E%E7%8E%B0%E7%B1%BB%E6%A6%82%E6%8B%AC"><span class="nav-number">5.</span> <span class="nav-text">List实现类概括</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AE%B9%E7%9B%B8%E5%90%8C%E7%A7%BB%E9%99%A4%E6%96%B9%E6%B3%95%EF%BC%88List%EF%BC%89"><span class="nav-number">6.</span> <span class="nav-text">实现对象内容相同移除方法（List）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ArrayList"><span class="nav-number">7.</span> <span class="nav-text">ArrayList</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vector"><span class="nav-number">8.</span> <span class="nav-text">Vector</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LinkedList"><span class="nav-number">9.</span> <span class="nav-text">LinkedList</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B"><span class="nav-number">10.</span> <span class="nav-text">泛型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Set%E5%AD%90%E6%8E%A5%E5%8F%A3"><span class="nav-number">11.</span> <span class="nav-text">Set子接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashSet%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="nav-number">12.</span> <span class="nav-text">HashSet（重点）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TreeSet"><span class="nav-number">13.</span> <span class="nav-text">TreeSet</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map%E7%88%B6%E6%8E%A5%E5%8F%A3"><span class="nav-number">14.</span> <span class="nav-text">Map父接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap"><span class="nav-number">15.</span> <span class="nav-text">HashMap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashTable"><span class="nav-number">16.</span> <span class="nav-text">HashTable</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Properties"><span class="nav-number">17.</span> <span class="nav-text">Properties</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TreeMap"><span class="nav-number">18.</span> <span class="nav-text">TreeMap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Collections%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="nav-number">19.</span> <span class="nav-text">Collections工具类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E2%86%94%E6%95%B0%E7%BB%84"><span class="nav-number">20.</span> <span class="nav-text">集合↔数组</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Loliconkelvin"
      src="/uploads/avatar.png">
  <p class="site-author-name" itemprop="name">Loliconkelvin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">51</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Loliconkelvin" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Loliconkelvin" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:Loliconkelvin@gmail.com" title="E-Mail → mailto:Loliconkelvin@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://loliconkelvin.github.io/2022/04/11/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Loliconkelvin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萝莉控的小窝">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Java集合框架 | 萝莉控的小窝">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java集合框架
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-11 22:20:27" itemprop="dateCreated datePublished" datetime="2022-04-11T22:20:27+08:00">2022-04-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-06-19 21:40:07" itemprop="dateModified" datetime="2022-06-19T21:40:07+08:00">2022-06-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <style>
    .red {
        color: red;
    }
    .bold {
        font-weight: bold;
    }
</style>

<p>Java集合框架</p>
<span id="more"></span>

<h2 id="集合是什么"><a href="#集合是什么" class="headerlink" title="集合是什么"></a>集合是什么</h2><p>（java.util.*）集合类似于数组，数组是单个对象的容器，集合是多个对象的容器</p>
<ul>
<li><p>集合和数组的区别：</p>
<ol>
<li>数组长度固定，集合的长度不固定</li>
<li>数组可以存储基本数据类型和引用类型（要存储基本类型可以使用装箱）</li>
</ol>
</li>
</ul>
<h2 id="Collection体系集合"><a href="#Collection体系集合" class="headerlink" title="Collection体系集合"></a>Collection体系集合</h2><table>
<thead>
<tr>
<th align="center">Collection体系集合</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="https://s1.ax1x.com/2022/04/12/LedjFf.png" alt="LedjFf.png"></td>
</tr>
</tbody></table>
<h2 id="Collection父接口"><a href="#Collection父接口" class="headerlink" title="Collection父接口"></a>Collection父接口</h2><p>代表一组任意类型的对象</p>
<p>特点：有序，无下标，元素可重复</p>
<hr>
<p><strong>Collection接口常用方法</strong></p>
<p><code>add(Object obj)</code>：向集合中增加一个对象</p>
<ul>
<li><p>添加方法是将元素的地址存储到集合中</p>
<p>  <img src="https://s1.ax1x.com/2022/04/12/LnYW0x.md.png" alt="LnYW0x.md.png"></p>
</li>
</ul>
<p><code>addAll(Collection c)</code>：将集合c中的所有对象增加到调用该方法的集合中</p>
<p><code>clear()</code>：清空集合中的所有对象</p>
<p><code>contains(Object obj)</code>：检查此集合中是否含有此对象</p>
<p><code>containsAll(Collection c)</code>：若调用该方法的集合包含集合c内的所有对象，返回true</p>
<p><code>equals(Object obj)</code>：比较此集合是否与指定对象相等</p>
<p><code>iterator()</code>：返回在此集合元素上进行迭代的迭代器</p>
<p><code>isEmpty()</code>：判断此集合是否为空</p>
<p><code>remove(Object obj)</code>：在集合中移除obj对象</p>
<p><code>removeAll(Collection c)</code>：在调用该方法的集合中移除集合c里的所有对象</p>
<p><code>retainAll(Collection c)</code>：仅保留集合c中的元素</p>
<p><code>size()</code>：返回该集合的元素个数</p>
<p><code>toArray()</code>：将此集合转换成数组</p>
<hr>
<p><strong>遍历集合</strong></p>
<p><span class="red bold">增强for：</span></p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">for (Object o : collection) &#123;
           System.out.println(o);
&#125;</code></pre>

<p><span class="red bold">Iterator迭代器：</span>迭代器是专门用来遍历集合的工具</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">Iterator iterator &#x3D; collection.iterator();

while (iterator.hasNext()) &#123;
    Object next &#x3D; iterator.next();
    System.out.println(next);
&#125;</code></pre>

<hr>
<p><strong>Iterator迭代器</strong></p>
<p>迭代器是专门用来遍历集合的工具，可以通过 <code>Conlection及其子类对象.Interator()</code> 获取对象的迭代器</p>
<p><span class="red bold">Iterator迭代器方法：</span></p>
<p>迭代器被创建时会指向第一个元素</p>
<ol>
<li><p><code>hasNext()</code>：若当前指向有元素，返回true</p>
</li>
<li><p><code>Next()</code>：返回迭代器现在指向的元素，并将指向往后移</p>
</li>
<li><p><code>remove()</code>：从迭代器指向的conllection对象中移除迭代器返回的最后一个元素</p>
<ul>
<li><span class="red">注意1：</span>每执行一次Next之后，只能执行一次remove</li>
<li><span class="red">注意2（重要）：</span>在迭代过程中不能使用集合对象中的移除方法，只能使用迭代器的移除方法，否则迭代器会停止迭代并抛出并发修改异常</li>
</ul>
 <pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">while (iterator.hasNext()) &#123;
    String next &#x3D; (String)iterator.next();
    System.out.println(next);
    if (next.equals(&quot;茄子&quot;)) &#123;
        &#x2F;&#x2F; 错误用法：collection.remove(next);
        iterator.remove();
    &#125;
&#125;</code></pre></li>
</ol>
<h2 id="List子接口"><a href="#List子接口" class="headerlink" title="List子接口"></a>List子接口</h2><p>特点：有序、有下标、元素可以重复</p>
<hr>
<p><strong>List常用方法</strong></p>
<p>除了Collection自带的方法外，List还有一些拓展的方法</p>
<p><code>add(int index, Object obj)</code>：在制定下标index位置插入对象</p>
<p><code>addAll（int index, Collection c）</code>：将集合c中的所有对象增加到调用该方法的集合中的index位置</p>
<p><code>get(int index)</code>：返回集合中指定位置的元素</p>
<p><code>set(int index, Object obj)</code>：用指定元素obj替换集合中的index位置元素</p>
<p><code>remove(int index)</code>：移除集合中指定位置的元素</p>
<p><code>indexOf(Object obj)</code>：返回集合中第一次出现指定元素的索引，不包含元素则返回-1</p>
<p><code>ListIterator()</code>：返回此合集的列表迭代器</p>
<p><code>ListIterator(int index)</code>：返回此合集的列表迭代器，从合集指定位置开始</p>
<p><code>subList(int fromIndex, int toIndex)</code>：返回fromIndex和toIndex-1之间的集合元素</p>
<hr>
<p><strong>遍历集合</strong></p>
<p><span class="red bold">普通for：</span><br>因为List有下标，所以可以使用普通for并使用 <code>get(int index)</code> 方法遍历元素</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">for (int i &#x3D; 0; i &lt; list.size(); i++) &#123;
    System.out.println(list.get(i));
&#125;</code></pre>

<p><span class="red bold">增强for：</span></p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">for (Object s : list) &#123;
    System.out.println(s);
&#125;</code></pre>

<p><span class="red bold">Iterator迭代器：</span></p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">Iterator&lt;Object&gt; iterator &#x3D; list.iterator();
while (iterator.hasNext()) &#123;
    System.out.println(iterator.next());
&#125;</code></pre>

<p><span class="red bold">ListIterator迭代器：</span></p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">ListIterator&lt;Object&gt; listIterator &#x3D; list.listIterator();
while (listIterator.hasNext()) &#123;
   System.out.println(listIterator.nextIndex() + &quot;:&quot; + listIterator.next());
&#125;</code></pre>

<hr>
<p><strong>ListIterator迭代器</strong></p>
<p>ListIterator迭代器是Iterator迭代器的子类，并且拥有更强大的功能， 它可以：</p>
<ol>
<li>从前往后遍历，从后往前遍历</li>
<li>在迭代的过程中对集合元素进行增加、替换和移除</li>
</ol>
<p><span class="red bold">ListIterator迭代器方法：</span></p>
<p>除了Iterator自带的方法外，ListIterator迭代器还有以下方法</p>
<p><code>hasPrevious()</code>：若当前指向存在元素则返回true（当然需要先使用 <code>next()</code> 方法把指针移到最后）</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">while (listIterator.hasNext()) &#123;
    listIterator.next();
&#125;</code></pre>

<p><code>previous()</code>：返回当前元素并且指针向前移动</p>
<p><code>nextIndex()</code> <code>previousIndex()</code>：返回返回后续调用 <code>next()</code> 或 <code>previous()</code> 方法将返回的元素的索引，查询下标不会移动指针（<span class="red">所以查询下标总是在查询元素之前，否则下标不是当前元素的下标</span>）</p>
<p><code>remove()</code>：移除 <code>next()</code> 或 <code>previous()</code> 方法上一次返回的元素</p>
<p><code>add(Object obj)</code>：将对象存入到集合中，关联键值，key重复则覆盖原值</p>
<ul>
<li><p>若前一次调用的是<code>next()</code>方法，则在目前指针位置的前面插入元素</p>
<p>  <img src="https://s1.ax1x.com/2022/04/13/LuOijK.png" alt="LuOijK.png"></p>
</li>
<li><p>若前一次调用的是<code>previous()</code>方法，则在目前指针位置的后面插入元素</p>
<p>  <img src="https://s1.ax1x.com/2022/04/13/LuOZAH.png" alt="LuOZAH.png"></p>
</li>
</ul>
<p><code>set(Object obj)</code>：用指定元素替换 <code>next()</code> 或 <code>previous()</code> 方法上一次返回的元素</p>
<hr>
<p><strong>当集合存储数字数据时</strong></p>
<p>当集合存储数字数据（int）时，会进行自动装箱</p>
<p>并且由于List支持下标操作，在调用一些可以传入下标或Obj参数的方法时要注意调用的是哪个方法，默认传入int类型的值会认为传入的是下标而不是对象，要传入对象，有两种方法：</p>
<ol>
<li>使用装箱</li>
<li>使用强制类型转换</li>
</ol>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F; 移除下标为20的元素
list.remove(20);

&#x2F;&#x2F; 移除值为20的元素
list.remove(Integer.valueOf(20));
list.remove((Object)20);</code></pre>

<h2 id="List实现类概括"><a href="#List实现类概括" class="headerlink" title="List实现类概括"></a>List实现类概括</h2><p><span class="red bold">ArrayList：</span></p>
<ul>
<li>数组结构实现（是连续的空间），查询快，增删慢（增删会导致部分元素前后移动）</li>
<li>JDK1.2引入，效率快，线程不安全</li>
</ul>
<p><span class="red bold">Vector：</span></p>
<ul>
<li>数组结构实现，查询快增删慢</li>
<li>JDK1.0引入， 效率慢，线程安全</li>
</ul>
<p><span class="red bold">LinkedList：</span></p>
<ul>
<li>链表结构实现（非连续空间），查询慢，增删快</li>
</ul>
<h2 id="实现对象内容相同移除方法（List）"><a href="#实现对象内容相同移除方法（List）" class="headerlink" title="实现对象内容相同移除方法（List）"></a>实现对象内容相同移除方法（List）</h2><p>在调用remove方法时实际上是先调用 <code>传入参数的类里的equals方法</code> 来遍历比较参数与集合对象的地址是否相同，并且移除第一个equals方法返回true的地方</p>
<p>于是我们只需要在 <code>传入的参数的类中</code> 重写equals方法即可改变remove方法的判断条件</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@Override
public boolean equals(Object obj) &#123;
    if (this &#x3D;&#x3D; obj) &#123;
        return true;
    &#125;
    if (obj &#x3D;&#x3D; null) &#123;
        return false;
    &#125;
    if (obj instanceof Student) &#123;
        Student student &#x3D; (Student)obj;
        &#x2F;&#x2F; 对主键值进行比较
        if (this.name.equals(student.getName())) &#123;
            return true;
        &#125;
    &#125;
    return false;
&#125;</code></pre>

<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>ArrayList与List操作基本一致</p>
<hr>
<p><strong>ArrayList源码分析</strong></p>
<p><span class="red bold">常量：</span></p>
<ol>
<li><code>DEFAULT_CAPACITY = 10</code>：默认容量</li>
<li><code>elementData</code>：存放元素的数组</li>
</ol>
<p><span class="red bold">实例变量：</span></p>
<ol>
<li><code>size</code>：实际元素个数（实例变量，实例被new出时初始化为0）（非局部变量都会被初始化）</li>
</ol>
<p><span class="red bold">方法：</span></p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public ArrayList() &#123;
    &#x2F;&#x2F; 初始化存放元素的数组（this.elementData &#x3D; &#123;&#125;）
    this.elementData &#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
&#125;

public boolean add(E e) &#123;
    &#x2F;&#x2F; modCount++;
    add(e, elementData, size);
    return true;
&#125;

private void add(E e, Object[] elementData, int s) &#123;
    &#x2F;&#x2F; 当前需要存储的元素将会存储在下标为s的位置上
    &#x2F;&#x2F; 若需要存储的下标 与 数组的长度相同，扩展数组
    if (s &#x3D;&#x3D; elementData.length)
        elementData &#x3D; grow();
    &#x2F;&#x2F; 若需要存储的下标 与 数组的长度不相同，则表明数组在该元素增加后还有空位置，直接将元素赋给对应下标的值，下标 + 1
    elementData[s] &#x3D; e;
    size &#x3D; s + 1;
&#125;

private Object[] grow() &#123;
    &#x2F;&#x2F; 传入（再往数组里传一个对象所）需求的最小容量（下标 + 1：数组的长度 &#x3D; 最大下标 + 1）
    return grow(size + 1);
&#125;

private Object[] grow(int minCapacity) &#123;
    &#x2F;&#x2F; 对数组进行扩容，扩容量由newCapacity()决定
    return elementData &#x3D; Arrays.copyOf(elementData,
                                  newCapacity(minCapacity));
&#125;

private int newCapacity(int minCapacity) &#123;
    &#x2F;&#x2F; 旧容量 &#x3D; 当前数组长度
    int oldCapacity &#x3D; elementData.length;
    &#x2F;&#x2F; 新容量 &#x3D; 旧容量 * 1.5（向下取整）
    int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1);
    &#x2F;&#x2F; 若 新容量 - 最小容量 &lt;&#x3D; 0, 旧容量的1.5倍居然不够用或刚好够用
    if (newCapacity - minCapacity &lt;&#x3D; 0) &#123;
        &#x2F;&#x2F; 若数组是空数组，返回DEFAULT_CAPACITY &#x3D; 10（此时将直接将数组扩容10个单位）
        if (elementData &#x3D;&#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA)
            return Math.max(DEFAULT_CAPACITY, minCapacity);
        &#x2F;&#x2F; 不可能的值
        if (minCapacity &lt; 0) &#x2F;&#x2F; overflow
            throw new OutOfMemoryError();
        &#x2F;&#x2F; 返回需求的最小容量（什么时候才会用到这个？）
        return minCapacity;
&#125;
    &#x2F;&#x2F; 返回newCapacity新容量（因为MAX_ARRAY_SIZE非常大，基本上判断条件为true）
    return (newCapacity - MAX_ARRAY_SIZE &lt;&#x3D; 0)
        ? newCapacity
        : hugeCapacity(minCapacity);
&#125;</code></pre>

<hr>
<p><strong>解析</strong></p>
<table>
<thead>
<tr>
<th align="center">又长又臭？一图流解析马上就来</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="https://s1.ax1x.com/2022/04/16/LtYwD0.png" alt="LtYwD0.png"></td>
</tr>
</tbody></table>
<p><span class="red bold">结论：</span>当使用无参构造创建ArrayList时，创建一个空数组 <br /><br>当增加第一个元素时，扩容10 <br /><br>当每次当前要添加的元素的下标触碰到数组长度时，扩容为原数组长度的1.5倍</p>
<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p>Vector与List操作基本一致，由于Vector比较老，他会多出一种特有的遍历方法——枚举器（JDK1.2前使用 ）</p>
<hr>
<p><strong>Vecor部分特有方法</strong></p>
<p><code>firstElement()</code>：返回第一个元素</p>
<p><code>lastElement()</code>：返回最后一个元素</p>
<p><code>elementAt(int index)</code>：返回第index个元素</p>
<p><code>setElementAt(E obj, int index)</code>：功能与 <code>set()</code> 方法相同，不同点是Vector中的 <code>set()</code> 方法会返回被替代的元素值</p>
<hr>
<p><strong>Elements枚举器</strong></p>
<p>使用方法与迭代器相同，并且功能更弱</p>
<p><span class="red bold">枚举器方法：</span></p>
<ol>
<li><code>hasMoreElements()</code>：测试此枚举是否包含更多元素</li>
<li><code>nextElement()</code>：如果此枚举对象至少还有一个要提供的元素，则返回此枚举的下一个元素</li>
</ol>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p>LinkedList通过双向链表实现数据存储</p>
<p>LinkedList使用方法与List基本相同</p>
<hr>
<p><strong>LinkedList源码分析</strong></p>
<p><span class="red bold">实例变量：</span></p>
<ol>
<li><code>size</code>：链表长度</li>
<li><code>first</code>：第一个元素指针</li>
<li><code>last</code>：最后一个元素指针</li>
</ol>
<p><span class="red bold">方法：</span></p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private static class Node&lt;E&gt; &#123;
    &#x2F;&#x2F; 存储的元素
    E item;
    &#x2F;&#x2F; 该数据在链表中的后一个元素
    Node&lt;E&gt; next;
    &#x2F;&#x2F; 该数据在链表中的前一个元素
    Node&lt;E&gt; prev;

    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;
        this.item &#x3D; element;
        this.next &#x3D; next;
        this.prev &#x3D; prev;
    &#125;
&#125;

public LinkedList() &#123;
&#125;

public boolean add(E e) &#123;
    linkLast(e);
    return true;
&#125;

void linkLast(E e) &#123;
    &#x2F;&#x2F; 定义局部变量 l &#x3D; 末指针元素
    final Node&lt;E&gt; l &#x3D; last;
    &#x2F;&#x2F; 新建Node对象，其数据为传入的元素
    &#x2F;&#x2F; 其前一个元素为l（last）
    &#x2F;&#x2F; 其后一个元素为空（因此它是链表中最后一个元素）
    final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(l, e, null);
    &#x2F;&#x2F; 定义新元素为链表的最后一个元素（将末指针指向它）
    last &#x3D; newNode;
    &#x2F;&#x2F; 若新增的元素前面没有元素，将头指针也指向它
    if (l &#x3D;&#x3D; null)
        first &#x3D; newNode;
    &#x2F;&#x2F; 否则将之前的最后一个元素的next指针指向新增元素
    else
        l.next &#x3D; newNode;
    &#x2F;&#x2F; 增加链表长度
    size++;
    &#x2F;&#x2F; modCount++;
&#125;</code></pre>

<hr>
<p><strong>解析</strong></p>
<table>
<thead>
<tr>
<th align="center">当LinkedList链表中存在单个或多个元素的情况</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="https://s1.ax1x.com/2022/04/16/Lt0LY6.png" alt="Lt0LY6.png"></td>
</tr>
<tr>
<td align="center"><img src="https://s1.ax1x.com/2022/04/16/Lt0zOH.png" alt="Lt0zOH.png"></td>
</tr>
</tbody></table>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>（如果你遇到了数组和泛型的创建冲突，转到基本语法）</p>
<p>Java泛型是JDK1.5中引入的新特性，泛型的本质是参数化类型，把类型作为参数传递</p>
<p>常见的形式有泛型类、泛型接口、泛型方法</p>
<p><span class="red bold">语法：</span></p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F; T为类型占位符，表示一种引用类型
&lt;T&gt;</code></pre>

<hr>
<p><strong>&lt;? extneds T&gt;&#x2F;&lt;? Super T&gt;</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014551778/article/details/115123047">Java 泛型 ＜? super T＞ ＜? extend T＞ 的通俗理解</a></p>
<p><span class="red bold">&lt;? extneds T&gt;：</span>指定该泛型传入的类型只能继承T类</p>
<p><span class="red bold">&lt;? super T&gt;：</span>指定该泛型传入的类型可以是T类或其父类</p>
<hr>
<p><strong>泛型类</strong></p>
<p>使用以下格式创建一个泛型类，并且创建一个泛型变量</p>
<p><span class="red">注意：</span>泛型在没有给予指定类型之前不能被实例化</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class Test&lt;T&gt; &#123;
    T t;

    public void showT() &#123;
        System.out.println(t);
    &#125;
&#125;</code></pre>

<p>使用一下格式创建一个泛型类对象</p>
<p><span class="red">注意：</span>泛型仅允许传入引用类型，要传入基本类型可以使用包装类</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public static void main(String[] args) &#123;
    Test&lt;String&gt; stringTest &#x3D; new Test&lt;&gt;();

    stringTest.t &#x3D; &quot;123&quot;;
    stringTest.showT();
&#125;</code></pre>

<hr>
<p><strong>泛型接口</strong></p>
<p>泛型也适用于接口，使用以下格式创建一个泛型接口</p>
<p><span class="red">注意：</span>zszz，接口内可以包含常量和抽象方法，但是常量需要在定义的时候马上初始化，而T只是一个类型占位符，类型未知，无法实例化，<span class="red">因此接口内不能定义泛型常量</span></p>
<p>但是定义一个 T作为返回值或T作为参数的抽象方法是允许的</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public interface Test&lt;T&gt; &#123;
    
&#125;</code></pre>

<hr>
<p><strong>泛型接口实现类</strong></p>
<p>实现泛型接口的时需要指定泛型的类型，并且在实现泛型接口时，其包含泛型的方法会自动转换为传入的类型，就像下面那样：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class TestImpl implements Test&lt;String&gt; &#123;

    @Override
    public String server(String s) &#123;
        return null;
    &#125;
&#125;</code></pre>

<p>当然，若实现类也不确定泛型的类型，则将实现类写成泛型类，将泛型的指定交给实例化时进行，就像下面那样：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class TestImpl&lt;T&gt; implements Test&lt;T&gt; &#123;
    @Override
    public T server(T t) &#123;
        return null;
    &#125;
&#125;</code></pre>

<hr>
<p><strong>泛型方法</strong></p>
<p><span class="red bold">意义：</span>泛型方法指 当前方法的 <span class="red">参数或返回值的类型不确定</span></p>
<p><span class="red">若当前方法中有泛型参数，则须声明该方法为泛型方法</span></p>
<p><span class="red bold">格式：</span>声明一个泛型方法的格式与声明泛型类稍有不同，他需要在返回值前加上类型占位符</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F; 泛型作为参数
public &lt;T&gt; void show(T t) &#123;
    System.out.println(t);
&#125;

&#x2F;&#x2F; 泛型作为返回值
public &lt;T&gt; T show(T t) &#123;
    System.out.println(t);
    return t;
&#125;</code></pre>

<hr>
<p><strong>泛型方法传入参数</strong></p>
<p>在为泛型方法传入参数时，泛型会自动根据传入的参数调整自己的类型</p>
<p>泛型的好处之一：提高代码重用性</p>
<hr>
<p><strong>泛型集合</strong></p>
<p><span class="red bold">背景：</span>zszz，集合中可以存储各种数据，当我们写 <code>ArrayList arrayList = new ArrayList();</code>（不往集合中传入泛型类型）时，实际上存入集合中的所有类型都将变为Object，当我们将其取出时，需要判断数据原本是什么类型，如果全部转成同一个类型，可能出现类型强制转换错误</p>
<p><span class="red bold">解决：</span>使用泛型集合，指定集合内存储的类型，在编译时即可将 传入了不同类型的数据 的错误找出</p>
<p>反省好处之二：防止类型转换异常，提高代码安全性</p>
<h2 id="Set子接口"><a href="#Set子接口" class="headerlink" title="Set子接口"></a>Set子接口</h2><p><span class="red bold">特点：</span>无序（添加数据的顺序与遍历数据的顺序不一样），无下标，元素不可重复</p>
<p>Set接口的方法和Collection方法完全一致</p>
<h2 id="HashSet（重点）"><a href="#HashSet（重点）" class="headerlink" title="HashSet（重点）"></a>HashSet（重点）</h2><p><span class="red bold">存储结构：</span>哈希表（JDK1.7前：数组 + 链表 JDK1.7后：数组 + （单向）链表 + 红黑树）</p>
<p>（HashSet的底层就是HashMap，查阅HashMap类的add方法可以发现存储的对象视为HashMap的key，而value为new Object()，详见HashMap的存储结构）</p>
<p><span class="red bold">特点：</span></p>
<p>基于HashCode计算元素存放位置</p>
<ul>
<li>若存放位置为空，则表示没有元素存入，直接存入</li>
<li>若存放位置不为空，则会调用equals方法进行确认<ul>
<li>若equals结果为true，则拒绝后来数据存入</li>
<li>若equals结果为false，则形成链表</li>
</ul>
</li>
</ul>
<hr>
<p><strong>HashSet基本使用</strong></p>
<p>增加、删除、遍历，和前面的完全一样</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class Main &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F; 创建
        HashSet&lt;Student&gt; students &#x3D; new HashSet&lt;&gt;();

        Student s1 &#x3D; new Student(&quot;张三&quot;, 10);
        Student s2 &#x3D; new Student(&quot;李四&quot;, 5);
        Student s3 &#x3D; new Student(&quot;王五&quot;, 15);

        &#x2F;&#x2F; 增加
        students.add(s1);
        students.add(s2);
        students.add(s3);

        &#x2F;&#x2F; 遍历
        Iterator&lt;Student&gt; iterator &#x3D; students.iterator();
        while (iterator.hasNext()) &#123;
            System.out.println(iterator.next());
        &#125;

        &#x2F;&#x2F; 删除
        students.remove(s1);

        &#x2F;&#x2F; 查询
        System.out.println(students.contains(s1));
        System.out.println(students.isEmpty());
    &#125;
&#125;</code></pre>

<hr>
<p><strong>实现对象内容相同无法添加方法</strong></p>
<p><span class="red bold">背景：</span>Set接口的一个特点就是不能重复，但是当两个对象内容相同但地址不同时，还是可以被添加：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public static void main(String[] args) &#123;
    &#x2F;&#x2F; 创建
    HashSet&lt;Student&gt; students &#x3D; new HashSet&lt;&gt;();

    Student s1 &#x3D; new Student(&quot;张三&quot;, 10);
    Student s2 &#x3D; new Student(&quot;李四&quot;, 5);
    Student s3 &#x3D; new Student(&quot;王五&quot;, 15);

    &#x2F;&#x2F; 增加
    students.add(s1);
    students.add(s2);
    students.add(s3);

    students.add(new Student(&quot;王五&quot;, 15));

    for (Student student : students) &#123;
        System.out.println(student);
    &#125;
&#125;

&#x2F;*输出：
Student&#123;name&#x3D;&#39;张三&#39;, age&#x3D;10&#125;
Student&#123;name&#x3D;&#39;王五&#39;, age&#x3D;15&#125;
Student&#123;name&#x3D;&#39;李四&#39;, age&#x3D;5&#125;
Student&#123;name&#x3D;&#39;王五&#39;, age&#x3D;15&#125;
*&#x2F;</code></pre>

<p>让我们来看看，Set是怎么判断两个元素相同的（HashSet -&gt; 特点）：<span class="red">根据HashCode计算存储位置</span> <br /><br>我们把新new出来的对象独立出来变为s4，看看这两个元素哈希值一不一样：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">System.out.println(s3.hashCode());
System.out.println(s4.hashCode());

&#x2F;*输出：
997110508
509886383
*&#x2F;</code></pre>

<p>他们的哈希值不一样，因此一定可以存储，而且不会触发equals方法比较，很明显我们不能通过重写equals方法来达到改变对比的效果，因为它根本没触发，<span class="red">我们需要重写Hashcode方法</span></p>
<p><span class="red bold">解决：</span>很明显，我们需要在Student类中重写hashcode方法，我们只需要根据对象的值来计算hashCode即可，比如说这个例子中需要根据名字和年龄来计算hashCode：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@Override
public int hashCode() &#123;
    int n1 &#x3D; this.name.hashCode();
    int n2 &#x3D; this.age;
    
    return n1 + n2;
&#125;</code></pre>

<p>但即使这样，相同值的元素依然会被增加进来，并且会与那个值相同的元素形成链表，因为hashCode一样只会触发equals比较，equals返回true才会阻止后来元素加入，<span class="red">我们还需要重写equals方法，依然是根据两个元素的主键来判断</span></p>
<p><span class="red">小技巧：</span>可以使用IDEA来一键重写</p>
<p><span class="red bold">结论：</span>HashSet比较相同依据有两个，先是HashCode再是equals，只有哈希值相同，equals为true时，才会阻止值重复地址不同的元素加入，<span class="red">同样这个结论也适用于删除的 <code>remove()</code> 方法和查询的 <code>contains()</code> 方法</span></p>
<hr>
<p><strong>关于hashcode一点小知识</strong></p>
<p>自动生成的根据对象的值计算hashcode的方法使用到了31这个数，并且用这个数做了一些乘法，这是因为：</p>
<ol>
<li>31 是一个质数，可以减少散列冲突（哈希冲突），可以尽量让数据存储在不同的位置</li>
<li>31 可以提高运行效率，因为 <code>31 * i = (i &lt;&lt; 5) - i</code></li>
</ol>
<h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><p><span class="red bold">存储结构：</span>红黑树</p>
<p>TreeSet基于排列顺序实现元素不重复</p>
<p>实现了SortedSet接口，对集合元素自动排序</p>
<p>元素对象的类型必须实现Comparable接口，指定排序规则</p>
<p>通过CompareTo方法确定是否为重复元素</p>
<hr>
<p><strong>红黑树</strong></p>
<p><span class="red bold">二叉查找树：</span><br>左子树的值必须小于根节点的值，右子树的值必须大于根节点的值</p>
<p><img src="https://s1.ax1x.com/2022/04/18/Ld6Aw8.png" alt="Ld6Aw8.png"></p>
<p><span class="red bold">红黑树：</span>红黑树是一种自平衡二叉查找树，规定最顶部的根节点必须为黑色，其可以通过旋转和变色来达到防止一棵树过长的效果，查找效率高</p>
<hr>
<p><strong>TreeSet常用方法</strong></p>
<p>还是那一堆东西，跟前面的一样</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public static void main(String[] args) &#123;
    &#x2F;&#x2F; 创建
    TreeSet&lt;String&gt; strings &#x3D; new TreeSet&lt;&gt;();

    &#x2F;&#x2F; 增加
    strings.add(&quot;姓名&quot;);
    strings.add(&quot;学号&quot;);
    strings.add(&quot;班级&quot;);
    strings.add(&quot;性别&quot;);
    System.out.println(strings);

    &#x2F;&#x2F; 删除
    strings.remove(&quot;性别&quot;);

    &#x2F;&#x2F; 遍历(增强for&#x2F;迭代器)
    for (String s : strings) &#123;
        System.out.println(s);
    &#125;

    Iterator&lt;String&gt; iterator &#x3D; strings.iterator();
    while (iterator.hasNext()) &#123;
        System.out.println(iterator.next());
    &#125;

    &#x2F;&#x2F; 查询
    System.out.println(strings.contains(&quot;学号&quot;));
    System.out.println(strings.isEmpty());
&#125;</code></pre>

<hr>
<p><strong>TreeSet集合中添加类元素</strong></p>
<p><span class="red bold">注意：</span>要在TreeSet中添加类元素，<span class="red">该类要实现comparable接口</span>（<span style="color: blue">或使用比较器，在下面有讲到</span>）<span class="red">并且重写接口内的比较方法</span>，否则该类是不能被比较（排序  ）的，也因此不能被添加至TreeSet中</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class Student implements Comparable&lt;Student&gt; &#123;
    private String name;
    private int age;

    public Student() &#123;
    &#125;

    public Student(String name, int age) &#123;
        this.name &#x3D; name;
        this.age &#x3D; age;
    &#125;

    &#x2F;&#x2F; 通常，比较的方法就是将类里面的实例变量进行逐个比较，可以返回它们的和，也可以返回单个比较结果等等比较方法
    @Override
    public int compareTo(Student o) &#123;
        int n1 &#x3D; this.name.compareTo(o.name);
        int n2 &#x3D; this.age - o.age;

        return n1 &#x3D;&#x3D; 0 ? n2 : n1;
    &#125;
&#125;</code></pre>

<p><span class="red bold">结论：</span>TreeSet判断两个元素重复的基准就是传入类中的 <code>compareTo()</code> 方法，该方法返回0，则表示元素相同，阻止后来元素存入</p>
<hr>
<p><strong>Comparator比较器</strong></p>
<p>上面提到除了保存到TreeSet中的类要实现Comparable接口外，还可以通过Comparator比较器的方式</p>
<p><span class="red bold">使用Comparator比较器是指：</span>在实例化TreeSet时传入一个实现了Comparator比较器的类作为参数，以定制该TreeSet的排序方法，看代码：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public static void main(String[] args) &#123;
  TreeSet&lt;Student&gt; students &#x3D; new TreeSet&lt;&gt;(new Comparator&lt;Student&gt;() &#123;
      @Override
      public int compare(Student o1, Student o2) &#123;
          int n1 &#x3D; o1.getName().compareTo(o2.getName());
          int n2 &#x3D; o1.getAge() - o2.getAge();
          return n1 &#x3D;&#x3D; 0 ? n2 : n1;
      &#125;
  &#125;);
&#125;</code></pre>

<p><span class="red bold">结论：</span>这两种方法都可以让类存储到TreeSet对象中，但是很明显两种方法针对的情况不同</p>
<ol>
<li>实现Comparable：是指定这个类被存储到集合中的排序方式，存储到任何一个TreeSet中都遵循这种排序方式</li>
<li>传入Comparator实现类：是指定该TreeSet针对该类的排序方式，而该类存储到其他TreeSet中就需要重新指定排序方式</li>
</ol>
<hr>
<p><strong>TreeSet小案例</strong></p>
<p>使用TreeSet对传入的字符串进行排序，要求按照字符串的长度进行排序，若字符串长度想相等，则按照字母表进行排序</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class Main &#123;
    public static void main(String[] args) &#123;
        TreeSet&lt;String&gt; strings &#x3D; new TreeSet&lt;String&gt;((o1, o2) -&gt; &#123;
            int length &#x3D; o1.length() - o2.length();
            int compare &#x3D; o1.compareTo(o2);
            return length &#x3D;&#x3D; 0 ? compare : length;
        &#125;);

        strings.add(&quot;helloworld&quot;);
        strings.add(&quot;zhang&quot;);
        strings.add(&quot;lisi&quot;);
        strings.add(&quot;wangwu&quot;);
        strings.add(&quot;beijing&quot;);
        strings.add(&quot;xian&quot;);
        strings.add(&quot;nanjing&quot;);

        for (String s : strings) &#123;
            System.out.println(s);
        &#125;
    &#125;
&#125;</code></pre>

<h2 id="Map父接口"><a href="#Map父接口" class="headerlink" title="Map父接口"></a>Map父接口</h2><p><span class="red bold">特点：</span></p>
<ol>
<li>用于存储键值对（Key-Value）</li>
<li>键：无序、无下标、<span class="red">不允许重复</span></li>
<li>值：无序、无下标、<span class="red">允许重复</span></li>
</ol>
<hr>
<p><strong>Map基本方法</strong></p>
<p><span class="red bold">注意：</span>这里开始就和Collection有点不同了，Map并不属于Collection，Map是一个单独的体系</p>
<p><code>put(K key, V value)</code>：向Map对象中增加键值对，若key重复，则新的值会替代原值</p>
<p><code>get(Object key)</code>：根据键获取对应的值</p>
<p><code>remove(Object key)</code>：通过传入的键删除键值对</p>
<p><code>size()</code>：返回Map中的键值对数量</p>
<p><code>containsKey(Object key)</code>：判断Map内是否存在该键</p>
<p><code>containsValue(Object value)</code>：判断Map内是否存在该值</p>
<p><code>values()</code>：返回包含所有值的Collection集合</p>
<hr>
<p><strong>Map遍历方法</strong></p>
<p>Map有两种遍历方法，分别是提取Map中所有的键 和 提取Map中所有的键值对并包装成entry</p>
<p><span class="red bold">提取Map中所有的键</span></p>
<p><code>keySet()</code>：该方法返回一个包含该对象所有<span class="red">键值</span>的Set集合</p>
<ul>
<li>获取到所有键值之后可以通过增强for遍历，也可以通过迭代器遍历</li>
<li>要获取对应的值，还需要在遍历过程中通过 <code>get()</code> 方法获取</li>
</ul>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">Set&lt;String&gt; set &#x3D; map.keySet();
for (String s : set) &#123;
    System.out.println(s + &quot;----------&quot; + map.get(s));
&#125;</code></pre>

<p><span class="red bold">提取Map中所有的映射对（键值对）</span></p>
<p><span class="red">相比于获取全部键，获取键值对的效率更高</span>（因为获取键之后要获取值还是要回去Map里根据键取到相应的值）</p>
<p><code>entrySet()</code>：该方法返回一个包含该对象所有键值对的Entry类型Set集合对象</p>
<ul>
<li><p>Entry类：Entry是Map接口中的一个内部接口，它是键值对的一种封装</p>
</li>
<li><p>Entry类方法：</p>
<p>  <code>getKey()</code>：获取当前entry的键</p>
<p>  <code>getValue()</code>：获取当前entry的值</p>
</li>
</ul>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">Set&lt;Map.Entry&lt;String, String&gt;&gt; entries &#x3D; map.entrySet();
for (Map.Entry&lt;String, String&gt; entry : entries) &#123;
    System.out.println(entry.getKey() + &quot;---------&quot; + entry.getValue());
&#125;</code></pre>

<table>
<thead>
<tr>
<th align="center">keySet与entrySet的区别</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="https://s1.ax1x.com/2022/04/19/L0hmU1.md.png" alt="L0hmU1.md.png"></td>
</tr>
</tbody></table>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>hashMap在JDK1.2版本引入，线程不安全，运行效率快</p>
<p><span class="red bold">存储结构：</span>数组 + （单向）链表 + 红黑树（详见源码分析）</p>
<p><span class="red bold">特点：</span></p>
<ul>
<li>线程不安全，效率快</li>
<li>hashMap允许null键和null值</li>
<li>初始容量为16，加载因子为0.75<ul>
<li>加载因子：指当数据达到容量的0.75倍时开始扩容</li>
</ul>
</li>
</ul>
<hr>
<p><strong>HashMap类方法</strong></p>
<p>HashMap类方法与Map接口中方法相同</p>
<hr>
<p><strong>实现对象内容相同移除方法</strong></p>
<p>HashMap不允许相同的键，并且是基于哈希码计算存储位置，<span class="red">因此HashMap是通过判断key的hashcode和equals返回值判断键是否相同</span></p>
<p>要实现同键值不同对象判定为相同，则需要重写key的类的hashcode和equals方法</p>
<p><span class="red">该判断条件适用于移除与判断方法</span></p>
<hr>
<p><strong>HashMap源码分析</strong></p>
<p><span class="red bold">常量：</span> </p>
<p><code>DEFAULT_INITIAL_CAPACITY</code>：默认最小容量（当HashMap对象实例化时，创建的容量）</p>
<p><code>MAXIMUM_CAPACITY</code>：最大容量</p>
<p><code>DEFAULT_LOAD_FACTOR</code>：加载因子（当存入的元素数量达到当前容量的0.75倍时开始扩容）</p>
<hr>
<p><code>TREEIFY_THRESHOLD</code> &#x3D; 8 </p>
<p><code>UNTREEIFY_THRESHOLD</code> &#x3D; 6 </p>
<p><code>MIN_TREEIFY_CAPACITY</code> &#x3D; 64</p>
<p>HashMap的红黑树存储方法并不是一开始就出现的，需要达到一定的数据存储量，才会将链表转换为红黑树，这三个变量就是转换为红黑树的条件，条件是：</p>
<ol>
<li>该链表长度 &gt; 8</li>
<li>数组长度 &gt; 64</li>
</ol>
<p>当链表长度 &lt; 6 时，会将红黑树转换回链表</p>
<table>
<thead>
<tr>
<th align="center">HashMap存储结构</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="https://s1.ax1x.com/2022/04/20/Lrp7TA.md.png" alt="Lrp7TA.md.png"></td>
</tr>
<tr>
<td align="center"><img src="https://s1.ax1x.com/2022/04/20/LrpYon.md.png" alt="LrpYon.md.png"></td>
</tr>
</tbody></table>
<hr>
<p>HashMap和HashSet中存储的链表为单向链表，可查阅HashMap类的Node内部类，它只有向后一个元素指向的指针</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;
    final int hash;
    final K key;
    V value;
    Node&lt;K,V&gt; next;
&#125;</code></pre>

<p><span class="red bold">构造方法：</span></p>
<p>HashMap的构造方法中并不创建数组，只是设定了加载因子，在实例化对象之后，只会得到：</p>
<ul>
<li>tabel &#x3D; null</li>
<li>size &#x3D; 0</li>
</ul>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public HashMap() &#123;
  this.loadFactor &#x3D; DEFAULT_LOAD_FACTOR;
&#125;</code></pre>

<p><span class="red bold">put方法：</span>put方法内只有一句调用putVal方法的语句，传入kay与value</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                boolean evict) &#123;
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
    &#x2F;&#x2F; 若table为null（table长度为0），调用resize()方法
    if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)
        n &#x3D; (tab &#x3D; resize()).length;
    &#x2F;&#x2F; 根据HashCode计算在数组中的存储位置
    &#x2F;&#x2F; 若该位置为空，将键值对封装为Node，装入该位置
    if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)
        tab[i] &#x3D; newNode(hash, key, value, null);
    else &#123;
        &#x2F;&#x2F; ...
    &#125;
    &#x2F;&#x2F; 若增加元素后储存的元素数量超过阈值，进行扩容
    if (++size &gt; threshold)
        resize();
    return null;
&#125;</code></pre>

<p><span class="red">resize方法：</span>resize方法用于扩容</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">final Node&lt;K,V&gt;[] resize() &#123;
    &#x2F;&#x2F; 定义旧数组空间
    Node&lt;K,V&gt;[] oldTab &#x3D; table;
    &#x2F;&#x2F; 定义旧数组空间长度
    int oldCap &#x3D; (oldTab &#x3D;&#x3D; null) ? 0 : oldTab.length;
    &#x2F;&#x2F; 定义旧扩容阈值
    int oldThr &#x3D; threshold;
    &#x2F;&#x2F; 定义新数组空间和长度
    int newCap, newThr &#x3D; 0;
    &#x2F;&#x2F; 第n次触发扩容时，会走这里
    if (oldCap &gt; 0) &#123;
        if (oldCap &gt;&#x3D; MAXIMUM_CAPACITY) &#123;
            threshold &#x3D; Integer.MAX_VALUE;
            return oldTab;
        &#125;
        &#x2F;&#x2F; 每次扩容会将容量变为原来的两倍
        else if ((newCap &#x3D; oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;
                 oldCap &gt;&#x3D; DEFAULT_INITIAL_CAPACITY)
            newThr &#x3D; oldThr &lt;&lt; 1; &#x2F;&#x2F; double threshold
    &#125;
    else if (oldThr &gt; 0)
        newCap &#x3D; oldThr;
    &#x2F;&#x2F; 第一次增加元素时（第一次扩容时）还没有设定阈值，会走这里
    else &#123;
        &#x2F;&#x2F; 新的空间长度会等于默认初始化长度（16）
        newCap &#x3D; DEFAULT_INITIAL_CAPACITY;
        &#x2F;&#x2F; 新的阈值会等于0.75 * 默认初始化长度（16）
        newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    &#125;
    &#x2F;&#x2F; 设定新阈值
    threshold &#x3D; newThr;

    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)
    &#x2F;&#x2F; 根据设置的容量创建新用于存储元素的数组
    Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];
    &#x2F;&#x2F; 将该数组给变量table
    table &#x3D; newTab;
    if (oldTab !&#x3D; null) &#123;
        for (int j &#x3D; 0; j &lt; oldCap; ++j) &#123;
            &#x2F;&#x2F; 转存数据到新的数组 ...
        &#125;
    &#125;
    return newTab;
&#125;</code></pre>

<p><span class="red bold">结论：</span></p>
<ol>
<li>当HashMap实例化时，table为null，为了节省空间，当添加第一个元素时，默认table容量是16</li>
<li>HashMap的扩充阈值是 0.75*当前容量，每次触发扩容都会将容量翻倍</li>
<li>JDK1.8之后，当链表长度大于8，并且数组中元素大于等于64时，会将链表调整为红黑树，目的是提高运行效率</li>
<li>JDK1.8之后，当链表长度小于6时，将红黑树还原为链表</li>
<li>JDK1.8之前，链表为头插入，JDK1.8之后，链表为尾插入</li>
</ol>
<h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><p><span class="red bold">特点：</span></p>
<p>HashTable起源于JDK1.0版本，现在使用频率比较低</p>
<ul>
<li>线程安全，效率慢</li>
<li>不允许key为null</li>
<li>不允许value为null</li>
</ul>
<h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><p>Properties类继承HashTable，使用频率比较高</p>
<p><span class="red bold">特点：</span></p>
<ul>
<li>存储属性名和属性值</li>
<li><span class="red">要求key和value都是String</span>，因此没有泛型</li>
<li>可以保存在流中，或从流中被加载</li>
<li>通常用于配置文件读取</li>
</ul>
<hr>
<p><strong>Properties基本方法</strong></p>
<p><code>setProperty(String key, String value)</code>：设置一个键值和其对应的参数</p>
<p><code>getProperty(String key)</code>：获取键所对应的值</p>
<blockquote>
<p>实在想看看这个类怎么用可以去看看 JDBC-&gt;提取工具类-&gt;配置文件</p>
</blockquote>
<hr>
<p><strong>Properties遍历方法</strong></p>
<p>除了keySet和entrySet外，Properties还提供了第三种遍历方法：</p>
<p><code>stringPropertyNames()</code>：返回String类型键值的Set集合</p>
<hr>
<p><strong>Properties流方法</strong></p>
<p><code>list(PrintStream out)</code>：将数据输出到流</p>
<p><code>list(PrintWriter out)</code>：将数据输出到打印流</p>
<p><code>store(Writer writer, String comments)</code><br><code>store(OutputStream out, String comments)</code>：通过字节&#x2F;字符输出流将数据保存到文件，comments为注释（文件后缀通常为.properties）</p>
<p><code>load(Reader reader)</code><br><code>load(InputStream inStream)</code>：通过字节&#x2F;字符输入流将文件中的数据读取回Properties对象中</p>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>TreeMap类比TreeSet，可以得知：</p>
<p><span class="red bold">特点：</span></p>
<ul>
<li>存储结构：红黑树</li>
<li><span class="red">通过比较key的值</span>，自动排序</li>
</ul>
<p>对于两个元素是否相同，与TreeSet规则相同，是通过Comparable里面的方法比较，或在构造方法时实现Comparator比较器</p>
<h2 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h2><p>Collections类提供静态方法以实现对所有集合类的操作</p>
<p><span class="red">注意：</span>Collection是集合父接口，Collections是对集合进行操作的工具类</p>
<hr>
<p><strong>Collections类常用方法</strong></p>
<p><code>sort(List&lt;T&gt; list)</code>：对传入的集合进行升序排序，也可以在第二个参数继续传入Comparator比较器定制排序</p>
<p><code>binarySearch(List list, T key)</code>：根据传入的key在list类进行二分查找</p>
<p><code>copy(List dest, List src)</code>：复制src集合到desc集合中</p>
<ul>
<li><span class="red">注意：</span>要求两个集合长度一样，否则会报错，可以先用循环往新集合内添加默认元素</li>
</ul>
<p><code>reverse(List list)</code>：反转集合内元素顺序</p>
<p><code>shuffle(List list)</code>：打乱集合内元素</p>
<h2 id="集合↔数组"><a href="#集合↔数组" class="headerlink" title="集合↔数组"></a>集合↔数组</h2><p>使用Collection对象的方法可以将集合转换为数组</p>
<p><code>toArray()</code>：可选一个数组作为参数传递，该数组作为存储集合的值的目标数组</p>
<p>使用Arrays的静态方法也可以将数组转换为集合</p>
<p><code>asList(T a)</code>：对传入的数组对象a，转换为集合</p>
<ul>
<li><span class="red">注意1：</span>转换后集合的不允许添加或删除操作</li>
<li><span class="red">注意2：</span>基本类型数组转换为集合时，要先将数组转换为使用包装类对象接收  <pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">Integer[] arr &#x3D; &#123;100,50,320&#125;;</code></pre></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/04/09/Java%E5%A0%86%E6%A0%88%E5%88%86%E6%9E%90/" rel="prev" title="Java堆栈分析">
                  <i class="fa fa-chevron-left"></i> Java堆栈分析
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/04/22/Java-IO%E6%B5%81/" rel="next" title="Java IO流">
                  Java IO流 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Loliconkelvin</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/components/prism-core.min.js" integrity="sha256-4mJNT2bMXxcc1GCJaxBmMPdmah5ji0Ldnd79DKd1hoM=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/plugins/autoloader/prism-autoloader.min.js" integrity="sha256-dL6vkUiCn30lPTN9cVrmQHo5UQmEwDMrx2ppAk4IhVk=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/plugins/line-numbers/prism-line-numbers.min.js" integrity="sha256-9cmf7tcLdXpKsPi/2AWE93PbZpTp4M4tqzFk+lWomjU=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
