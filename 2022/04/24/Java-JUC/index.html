<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"loliconkelvin.github.io","root":"/","images":"/images","scheme":"Pisces","version":"8.7.1","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":true,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content=".red {         color: red;     }     .bold {         font-weight: bold;     }   Java-JUC">
<meta property="og:type" content="article">
<meta property="og:title" content="Java JUC">
<meta property="og:url" content="https://loliconkelvin.github.io/2022/04/24/Java-JUC/index.html">
<meta property="og:site_name" content="萝莉控的小窝">
<meta property="og:description" content=".red {         color: red;     }     .bold {         font-weight: bold;     }   Java-JUC">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s1.ax1x.com/2022/04/25/LIDpTK.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/04/25/LT3PrF.md.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/04/26/LbE66H.md.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/04/26/LbE4tf.md.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/04/26/LbVS9U.md.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/04/26/LbVEAx.md.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/04/26/LbVm9O.md.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/04/26/LbVKjH.md.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/01/O9pvjK.md.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/01/O998g0.md.png">
<meta property="article:published_time" content="2022-04-24T08:28:50.000Z">
<meta property="article:modified_time" content="2022-05-02T03:17:23.458Z">
<meta property="article:author" content="Loliconkelvin">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s1.ax1x.com/2022/04/25/LIDpTK.png">


<link rel="canonical" href="https://loliconkelvin.github.io/2022/04/24/Java-JUC/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://loliconkelvin.github.io/2022/04/24/Java-JUC/","path":"2022/04/24/Java-JUC/","title":"Java JUC"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Java JUC | 萝莉控的小窝</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">萝莉控的小窝</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFJUC"><span class="nav-number">1.</span> <span class="nav-text">什么是JUC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">线程和进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C"><span class="nav-number">3.</span> <span class="nav-text">并发和并行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E9%A1%BE%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8Esynchronized%E5%90%8C%E6%AD%A5"><span class="nav-number">4.</span> <span class="nav-text">回顾多线程与synchronized同步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lock"><span class="nav-number">5.</span> <span class="nav-text">Lock</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized%E5%92%8CLock%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.</span> <span class="nav-text">synchronized和Lock的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-number">7.</span> <span class="nav-text">生产者消费者问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8%E9%94%81%E7%8E%B0%E8%B1%A1%E7%90%86%E8%A7%A3%E9%94%81"><span class="nav-number">8.</span> <span class="nav-text">8锁现象理解锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88%E7%B1%BB"><span class="nav-number">9.</span> <span class="nav-text">不安全的集合类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Callable"><span class="nav-number">10.</span> <span class="nav-text">Callable</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JUC%E4%B8%89%E4%B8%AA%E5%B8%B8%E7%94%A8%E8%BE%85%E5%8A%A9%E7%B1%BB%E2%80%94%E2%80%94CountDownLatch"><span class="nav-number">11.</span> <span class="nav-text">JUC三个常用辅助类——CountDownLatch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JUC%E4%B8%89%E4%B8%AA%E5%B8%B8%E7%94%A8%E8%BE%85%E5%8A%A9%E7%B1%BB%E2%80%94%E2%80%94CyclicBarrier"><span class="nav-number">12.</span> <span class="nav-text">JUC三个常用辅助类——CyclicBarrier</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JUC%E4%B8%89%E4%B8%AA%E5%B8%B8%E7%94%A8%E8%BE%85%E5%8A%A9%E7%B1%BB%E2%80%94%E2%80%94Semaphore"><span class="nav-number">13.</span> <span class="nav-text">JUC三个常用辅助类——Semaphore</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ReadWriteLock%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-number">14.</span> <span class="nav-text">ReadWriteLock读写锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E5%A4%A7%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="nav-number">15.</span> <span class="nav-text">四大函数式接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stream%E6%B5%81%E5%BC%8F%E8%AE%A1%E7%AE%97-%E9%93%BE%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="nav-number">16.</span> <span class="nav-text">stream流式计算&#x2F;链式编程</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Loliconkelvin"
      src="/uploads/avatar.png">
  <p class="site-author-name" itemprop="name">Loliconkelvin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Loliconkelvin" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Loliconkelvin" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:loliconkelvin@gmail.com" title="E-Mail → mailto:loliconkelvin@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



          </div>
        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://loliconkelvin.github.io/2022/04/24/Java-JUC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Loliconkelvin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萝莉控的小窝">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java JUC
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-24 16:28:50" itemprop="dateCreated datePublished" datetime="2022-04-24T16:28:50+08:00">2022-04-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-05-02 11:17:23" itemprop="dateModified" datetime="2022-05-02T11:17:23+08:00">2022-05-02</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <style>
    .red {
        color: red;
    }
    .bold {
        font-weight: bold;
    }
</style>

<p>Java-JUC</p>
<span id="more"></span>

<h2 id="什么是JUC"><a href="#什么是JUC" class="headerlink" title="什么是JUC"></a>什么是JUC</h2><p>JUC指 java.util.concurrent 包，还包括 java.util.concurrent.atomic java.util.concurrent.locks</p>
<h2 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h2><p><span class="red bold">进程：</span>指一个程序，一个进程会包含至少一个线程（Java默认有两个线程：main、gc）</p>
<p><span class="red bold">线程：</span>指一个程序里的一些同步进行的功能，它们可能是通过线程实现的</p>
<p>Java本身不能开启线程，因为Java运行在虚拟机中，无法直接操作硬件，它是通过调用底层C++来开启线程</p>
<hr>
<p><strong>回顾线程的状态</strong></p>
<p>理论上：创建、就绪、运行、死亡、阻塞</p>
<p>源码指定的：</p>
<ol>
<li>NEW：创建</li>
<li>RUNNABLE：就绪</li>
<li>BLOCKED：阻塞</li>
<li>WAITING：无限期等待</li>
<li>TIMED_WAITING：超时等待（有时间限制）</li>
<li>TERMINATED：消亡</li>
</ol>
<hr>
<p><strong>wait和sleep的区别</strong></p>
<ol>
<li>来自不同的类<ul>
<li>wait在Object里</li>
<li>sleep在Thread里</li>
</ul>
</li>
<li>锁<ul>
<li>wait会释放锁</li>
<li>sleep抱着锁睡觉</li>
</ul>
</li>
<li>适用范围不同<ul>
<li>wait必须在同步代码块中</li>
<li>任何线程都可以sleep</li>
</ul>
</li>
</ol>
<h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><p><span class="red bold">并发：</span>指多个线程操作一个资源。并发的本质是一个CPU在多个程序之间切换运行。</p>
<p><span class="red bold">并行：</span>指多个线程可以同时被多个CPU执行</p>
<h2 id="回顾多线程与synchronized同步"><a href="#回顾多线程与synchronized同步" class="headerlink" title="回顾多线程与synchronized同步"></a>回顾多线程与synchronized同步</h2><hr>
<p><strong>面向对象的多线程编写</strong></p>
<p>以前写多线程时，经常一个类继承Thread类或实现Runnable接口，但是这都不够面向对象</p>
<p><span class="red bold">资源类：</span>专类专用，在真正的线程开发中，线城市一个单独的资源类，只有属性和方法，如：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Ticket &#123;
    &#x2F;&#x2F; 票数
    private static int number &#x3D; 50;

    &#x2F;&#x2F; 卖票方法
    public synchronized void sale() &#123;
        if (number &gt; 0) &#123;
            System.out.println(Thread.currentThread().getName() + &quot;卖出了第&quot; + number-- + &quot;张票，&quot; + &quot;剩余&quot; + number + &quot;张&quot;);
            try &#123;
                Thread.sleep(100);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

<p><span class="red bold">线程操作：</span>那么如何实现线程对资源类的操作？只需要想办法将资源类丢到线程里即可，基本思路是：<code>Thread里丢Runnable，Runnable里丢run方法，run方法里丢资源类方法</code>，如：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F; 首先需要一个被操作的资源类
Ticket ticket &#x3D; new Ticket();

&#x2F;&#x2F; 然后需要一个线程，然后把资源类扔进线程里
new Thread(() -&gt; &#123;
   for (int i &#x3D; 0; i &lt; 60; i++) &#123;
       ticket.sale();
   &#125;
&#125;, &quot;A&quot;).start();</code></pre>

<p><span class="red bold">实现同步：</span>针对synchronized同步，就是在方法里面加上synchronized修饰（或使用synchronized代码块）</p>
<p><span class="red">关于锁：</span>锁会锁定两个东西，一个是对象，一个是class</p>
<h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><p>Lock指java.util.concurrent.locks中的lock接口，它有三个实现类，分别是：</p>
<ol>
<li>ReentrantLock：可重入锁（常用）</li>
<li>ReentrantReadWriteLock.ReadLock：读锁（内部类）</li>
<li>ReentrantReadWriteLock.WriteLock：写锁（内部类）</li>
</ol>
<p>我们先使用可重入锁，根据官方文档，使用可重入锁分为三步：</p>
<ol>
<li>创建锁对象（Lock lock = new …）</li>
<li>加锁（Lock.lock() try { // 同步代码块}）</li>
<li>解锁（ finally {lock.unlock()} ）</li>
</ol>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Ticket2 &#123;
    &#x2F;&#x2F; 票数
    private static int number &#x3D; 50;

    &#x2F;&#x2F; 创建锁对象
    Lock lock &#x3D; new ReentrantLock();

    &#x2F;&#x2F; 卖票方法
    public void sale() &#123;
        &#x2F;&#x2F; 加锁
        lock.lock();

        try &#123;
            if (number &gt; 0) &#123;
                System.out.println(Thread.currentThread().getName() + &quot;卖出了第&quot; + number-- + &quot;张票，&quot; + &quot;剩余&quot; + number + &quot;张&quot;);
                try &#123;
                    Thread.sleep(100);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125; finally &#123;
            &#x2F;&#x2F; 解锁
            lock.unlock();
        &#125;
    &#125;
&#125;</code></pre>

<h2 id="synchronized和Lock的区别"><a href="#synchronized和Lock的区别" class="headerlink" title="synchronized和Lock的区别"></a>synchronized和Lock的区别</h2><table>
<thead>
<tr>
<th align="center">synchronized</th>
<th align="center">Lock</th>
</tr>
</thead>
<tbody><tr>
<td align="center">关键字</td>
<td align="center">类</td>
</tr>
<tr>
<td align="center">自动加锁解锁</td>
<td align="center">手动加锁解锁</td>
</tr>
<tr>
<td align="center">无法判断锁的状态</td>
<td align="center">可以判断锁的状态</td>
</tr>
<tr>
<td align="center">一直等待</td>
<td align="center">可以设置超时</td>
</tr>
<tr>
<td align="center">非公平锁</td>
<td align="center">可以自定义是否公平</td>
</tr>
<tr>
<td align="center">少量同步代码</td>
<td align="center">大量同步代码</td>
</tr>
</tbody></table>
<ol>
<li>synchronized是一个Java内置关键字；Lock是一个类</li>
<li>synchronized自动隐式加锁；Lock手动显式加锁</li>
<li>synchronized无法判断获取锁的状态；Lock可以判断是否获取到了锁</li>
<li>synchronized会自动释放锁；Lock需要手动释放，若不释放会造成死锁</li>
<li>synchronized在一个线程阻塞的时候，另一个线程会一直等；Lock锁时则另一个线程不一定会一直等（tryLock()）</li>
<li>synchronized为可重入锁，不可以中断的，非公平锁；Lock为可重入锁，可以判断锁的状态，可以自定义是否公平</li>
<li>synchronized适合少量代码同步问题；Lock适合锁大量同步代码</li>
</ol>
<h2 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h2><p>PC（ProducerConsumer）问题三部曲：<span class="red">判断等待-&gt;业务-&gt;唤醒</span></p>
<hr>
<p><strong>回顾synchronized版生产者消费者问题</strong></p>
<p>根据PC问题三部曲并且根据上面资源类的格式，可以得到以下代码：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class ProducerConsumer &#123;
    public static void main(String[] args) &#123;
        Buffer buffer &#x3D; new Buffer();

        new Thread(() -&gt; &#123;
            for (int i &#x3D; 0; i &lt; 10; i++) &#123;
                buffer.put(i);
            &#125;
        &#125;, &quot;Producer1&quot;).start();

        new Thread(() -&gt; &#123;
            for (int i &#x3D; 0; i &lt; 10; i++) &#123;
                buffer.get();
            &#125;
        &#125;, &quot;Consumer1&quot;).start();
    &#125;
&#125;

class Buffer &#123;
    private int buffer;
    private boolean updated &#x3D; false;

    &#x2F;&#x2F; 生产者将调用该方法
    public synchronized void put(int num) &#123;
        &#x2F;&#x2F; 判断等待（使用while防止虚假唤醒）
        if (updated) &#123;
            try &#123;
                this.wait();
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        &#x2F;&#x2F; 操作
        buffer &#x3D; num;
        System.out.println(Thread.currentThread().getName() + &quot;放入&quot; + buffer);
        updated &#x3D; true;

        &#x2F;&#x2F; 唤醒
        notifyAll();
    &#125;

    &#x2F;&#x2F; 消费者将调用该方法
    public synchronized void get() &#123;
        &#x2F;&#x2F; 判断等待
        if (!updated) &#123;
            try &#123;
                this.wait();
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        &#x2F;&#x2F; 业务
        System.out.println(Thread.currentThread().getName() + &quot;取出&quot; + buffer);
        updated &#x3D; false;

        &#x2F;&#x2F; 通知
        notifyAll();
    &#125;
&#125;</code></pre>

<hr>
<p><strong>虚假唤醒问题</strong></p>
<p>虚假唤醒指多个线程被唤醒，但有些线程是有效的，有些线程是无效或会造成错误的</p>
<p><span class="red bold">问题：</span></p>
<p>注意上面在同步方法在中使用了if来判断，这在两个线程操作一个对象的时候没有问题，但是在两个以上操作线程时就会出现问题</p>
<p><img src="https://s1.ax1x.com/2022/04/25/LIDpTK.png" alt="LIDpTK.png"></p>
<p><span class="red bold">问题分析：</span></p>
<p>当有两个消费者（消费者同理）时</p>
<ol>
<li>在上一次两个生产者被同时notify唤醒后，有一个生产者（假设是生产者1）执行完了方法，而另一个（假设是生产者2）来不及执行，停在了this.wait()方法处</li>
<li>而当两个生产者再次被notify唤醒时，碰巧生产者1抢占到了资源并执行完毕，然后生产者2紧接着占到资源，从wait处继续往下执行，就造成了两个生产者都操作了资源的问题<br><img src="https://s1.ax1x.com/2022/04/25/LT3PrF.md.png" alt="LT3PrF.md.png"></li>
</ol>
<blockquote>
<p>实例分析（应用于对数据进行+1和-1）：线程1进入方法，++后释放，线程2进入方法，！=被wait，线程3进入方法，–后释放，释放的瞬间线程1拿到了锁，进入后++，线程2从wait中被唤醒，向下执行后++，出现了2这样的数字</p>
</blockquote>
<p><span class="red bold">解决：</span>将判断等待部分使用while判断，使wait结束之后不能马上进入业务，还要再判断一遍</p>
<hr>
<p><strong>JUC版生产者消费者问题</strong></p>
<p>synchronized有wait和notify，Lock接口本身并没有可以代替这两个方法的方法，但另一个接口Condition有</p>
<p><span class="red bold">构造方法：</span>需要通过Lock对象的<code>newCondition()</code>方法将Condition对象new出，该Condition对象会与对应的Lock对象绑定</p>
<p><span class="red bold">方法：</span></p>
<pre class="line-numbers language-await()```：当前线程等待，直到发出信号或中断" data-language="await()```：当前线程等待，直到发出信号或中断"><code class="language-await()```：当前线程等待，直到发出信号或中断">
&#96;&#96;&#96;signal()&#96;&#96;&#96;：唤醒一个等待线程

&#96;&#96;&#96;signalAll()&#96;&#96;&#96;：唤醒所有等待线程

&lt;span class&#x3D;&quot;red bold&quot;&gt;使用格式：&lt;&#x2F;span&gt;

&#96;&#96;&#96;Java
private final Lock lock &#x3D; new Lock();
println final Condition put &#x3D; lock.newCondition();
println final Condition get &#x3D; lock.newCondition();

public void put(int num) &#123;
    lock.lock();
    try &#123;
        while(updated) &#123;
            put.await();
        &#125;

        &#x2F;&#x2F; ......

        get.signalAll();
    &#125; finally &#123;
        lock.unlock;
    &#125;
&#125;</code></pre>

<hr>
<p><strong>Condition精准通知某个线程</strong></p>
<p>Condition的特点在于：<span class="red">一个Lock锁可以与多个监视器绑定，一个监视器监视一个线程，则可以实现精准通知某个监视器（线程）</span></p>
<h2 id="8锁现象理解锁"><a href="#8锁现象理解锁" class="headerlink" title="8锁现象理解锁"></a>8锁现象理解锁</h2><p>现有以下程序：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class LockTest &#123;
    public static void main(String[] args) &#123;
        Phone phone &#x3D; new Phone();
        new Thread(phone::sendMsg, &quot;A&quot;).start();

        new Thread(phone::call, &quot;B&quot;).start();
    &#125;
&#125;

class Phone &#123;
    public synchronized void sendMsg() &#123;
        System.out.println(&quot;发短信&quot;);
    &#125;

    public synchronized void call() &#123;
        System.out.println(&quot;打电话&quot;);
    &#125;
&#125;</code></pre>

<hr>
<ol>
<li><strong>main线程延时（对象锁）</strong></li>
</ol>
<p><span class="red bold">问题：</span>若在main线程中的两个线程开启之间延时4s，发短信和打电话谁先执行？</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">Phone phone &#x3D; new Phone();
new Thread(phone::sendMsg, &quot;A&quot;).start();

try &#123;
   TimeUnit.SECONDS.sleep(4);
&#125; catch (InterruptedException e) &#123;
   e.printStackTrace();
&#125;

new Thread(phone::call, &quot;B&quot;).start();</code></pre>

<p><span class="red bold">解答：</span>发短息先执行 <br /><br>因为发短信在主线程中先被开启，拿到了锁，打电话在4s后被开启，得到锁</p>
<p><img src="https://s1.ax1x.com/2022/04/26/LbE66H.md.png" alt="LbE66H.md.png"></p>
<hr>
<ol start="2">
<li><strong>main线程 + 同步方法延时</strong></li>
</ol>
<p><span class="red bold">问题：</span>若发短信方法延时4s，main线程延时2s，谁先执行？</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public synchronized void sendMsg() &#123;
  try &#123;
      TimeUnit.SECONDS.sleep(4);
  &#125; catch (InterruptedException e) &#123;
      e.printStackTrace();
  &#125;
  System.out.println(&quot;发短信&quot;);
&#125;</code></pre>

<p><span class="red bold">解答：</span>发短信先执行 <br /><br>因为还是发短息先得到了锁，并且发短信会在4s后</p>
<p><img src="https://s1.ax1x.com/2022/04/26/LbE4tf.md.png" alt="LbE4tf.md.png"></p>
<p><span class="red bold">对象锁：</span>这里锁的是phone对象，因为两个线程使用用一个对象，因此使用同一把锁</p>
<hr>
<ol start="3">
<li><strong>同步方法 + 不同步方法</strong></li>
</ol>
<p><span class="red bold">问题：</span>将打电话改为不同步方法，延时条件不变（main延时2s，发短信延时4s），谁先执行？</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public void call() &#123;
        System.out.println(&quot;打电话&quot;);
    &#125;</code></pre>

<p><span class="red bold">解答：</span>打电话先执行，因为打电话不是同步方法，不受锁的影响，因此只需要看时间延时决定谁先执行。</p>
<p><img src="https://s1.ax1x.com/2022/04/26/LbVS9U.md.png" alt="LbVS9U.md.png"></p>
<hr>
<ol start="4">
<li><strong>两个对象</strong></li>
</ol>
<p><span class="red bold">问题：</span>将new一个对象变为new两个对象，两个线程分别调用两个对象的发短信和打电话方法，延时条件不变（main延时2s，发短信延时4s），谁先执行？</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class LockTest1 &#123;
    public static void main(String[] args) &#123;
        Phone1 phone1 &#x3D; new Phone1();
        Phone1 phone2 &#x3D; new Phone1();
        new Thread(phone1::sendMsg, &quot;A&quot;).start();

        try &#123;
            TimeUnit.SECONDS.sleep(2);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;

        new Thread(phone2::call, &quot;B&quot;).start();
    &#125;
&#125;</code></pre>

<p><span class="red bold">解答：</span>打电话先执行，因为是两个不同的对象，因此是两把锁互不干涉，看时间延时来决定谁先执行</p>
<p><img src="https://s1.ax1x.com/2022/04/26/LbVEAx.md.png" alt="LbVEAx.md.png"></p>
<hr>
<ol start="5">
<li><strong>静态同步方法（Class锁）</strong></li>
</ol>
<p><span class="red bold">问题：</span>将两个同步方法都变为静态同步方法，只有一个对象，延时条件不变（main延时2s，发短信延时4s），谁先执行？</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public static synchronized void sendMsg() &#123;
  try &#123;
      TimeUnit.SECONDS.sleep(4);
  &#125; catch (InterruptedException e) &#123;
      e.printStackTrace();
  &#125;
  System.out.println(&quot;发短信&quot;);
&#125;

public static synchronized void call() &#123;
  System.out.println(&quot;打电话&quot;);
&#125;</code></pre>

<p><span class="red bold">解答：</span>发短信先执行，静态方法锁的是该类的Class对象，Class对象一个类只对应一个，谁先拿到谁先执行</p>
<p><img src="https://s1.ax1x.com/2022/04/26/LbVm9O.md.png" alt="LbVm9O.md.png"></p>
<p><span class="red bold">Class锁：</span>Class锁会在调用该类静态方法时用到，只要是调用该类的静态方法，都要请求到这个Class对象锁，相当于是<span class="red">Class锁会将该类的静态方法全部锁定</span></p>
<hr>
<ol start="6">
<li><strong>静态方法 + 两个对象</strong></li>
</ol>
<p><span class="red bold">问题：</span>两个对象，谁先执行？</p>
<p><span class="red bold">解答：</span>结果和上面一样，发短信先执行，本来静态方法的调用就和对象没关系，并且Class锁并不是根据对象来锁的，也跟对象没关系</p>
<hr>
<ol start="7">
<li><strong>静态方法 + 非静态方法</strong></li>
</ol>
<p><span class="red bold">问题：</span>发短信是静态同步方法，打电话是普通同步方法，延时条件不变（main延时2s，发短信延时4s），谁先执行？</p>
<p><span class="red bold">解答：</span>打电话先执行，这是两把锁互不干涉，看时间延时来决定谁先执行</p>
<p><img src="https://s1.ax1x.com/2022/04/26/LbVKjH.md.png" alt="LbVKjH.md.png"></p>
<hr>
<ol start="8">
<li><strong>静态方法 + 非静态方法 + 两个对象</strong></li>
</ol>
<p><span class="red bold">问题：</span>在第7问的基础上将对象变为两个，谁先执行？</p>
<p><span class="red bold">解答：</span>打电话先执行，这里有两把锁互不干涉，看时间延时来决定谁先执行</p>
<h2 id="不安全的集合类"><a href="#不安全的集合类" class="headerlink" title="不安全的集合类"></a>不安全的集合类</h2><hr>
<p><strong>并发修改异常</strong></p>
<p>zszz，ArrayList只在单线程的时候会爆并发修改异常，而解决方法有以下几种：</p>
<ol>
<li>改用Vector（但还是会爆……）</li>
<li>使用工具类Collections静态方法<code>synchronizedList(List&lt;T&gt; list)</code>将集合变为同步集合</li>
<li>使用java.util.concurrent包下的CopyOnWriteArrayList（<span class="red">好处在于该类只在写入的时候加锁，读取的时候不加锁，提高效率</span>）</li>
</ol>
<br />

<p>Set同理，也会爆并发修改异常：</p>
<ol>
<li>使用工具类Collections静态方法<code>synchronizedSet(Set&lt;T&gt; s)</code>将集合变为同步集合</li>
<li>使用java.util.concurrent包下的CopyOnWriteArraySet</li>
</ol>
<p>Map同理：</p>
<ol>
<li>改用HashTable</li>
<li>使用工具类Collections静态方法<code>synchronizedMap(Map&lt;K,V&gt; m)</code>将集合变为同步集合</li>
<li>使用java.util.concurrent包下的<span class="red">ConcurrentHashMap</span></li>
</ol>
<h2 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h2><p>有返回值、可抛出异常、需要重写call()方法</p>
<hr>
<p><strong>启动Callable</strong></p>
<p><span class="red bold">问题：</span>Thread只能接收Runnable，如何启动Callable？</p>
<p><span class="red bold">解决：</span>使用适配器类FutureTask。</p>
<hr>
<p><strong>FutureTask</strong></p>
<p>FutureTask是Runnable的一个实现类，可以将Callable进行封装</p>
<p><span class="red bold">注意：</span></p>
<ol>
<li><p>被丢进FutureTask的线程<span class="red">只会执行一次</span>，再次执行时，Callable线程的状态已经改变</p>
<ul>
<li>线程状态：<br>FutureTask内定义了多个线程状态</li>
</ul>
<ol>
<li>当一个线程被丢进FutureTask构造方法时，状态被定义为NEW</li>
<li>在执行FutureTask的run()方法时，<span class="red">先检查线程状态，若线程状态不为NEW，则不会调用Callable的call()方法</span>，若为NEW，则会调用Callable的call()方法，call()方法执行完毕后，会接收call()方法的返回值并保留，此时线程状态被设置为COMPLETING</li>
<li>保留完返回值后，线程状态被设置为NORMAL</li>
</ol>
</li>
<li><p>使用FutureTask对象的方法<code>get()</code>，以获取存储在FutureTask对象中的Call()方法返回值</p>
</li>
<li><p><code>get()</code>方法会阻塞，当线程状态在NEW或COMPLETING时，get()方法会等待线程执行完毕</p>
</li>
</ol>
<h2 id="JUC三个常用辅助类——CountDownLatch"><a href="#JUC三个常用辅助类——CountDownLatch" class="headerlink" title="JUC三个常用辅助类——CountDownLatch"></a>JUC三个常用辅助类——CountDownLatch</h2><p>CountDownLatch是一个减法计数器，使用在 当某个事件需要发生在其他几个事件都完成后 的情况下</p>
<p><span class="red bold">构造方法：</span></p>
<pre class="line-numbers language-CountDownLatch​(int" data-language="CountDownLatch​(int"><div class="caption"><span>count)```：给定一个计数器初值</span></div><code class="language-CountDownLatch​(int">
&lt;span class&#x3D;&quot;red bold&quot;&gt;方法：&lt;&#x2F;span&gt;

&#96;&#96;&#96;await()&#96;&#96;&#96;：使当前线程在计数器归零前等待

&#96;&#96;&#96;await​(long timeout, TimeUnit unit)&#96;&#96;&#96;：使当前线程在计数器归零前进行超时等待（timeout：时间数字；unit：时间单位），返回当前计数器是否已经归零

&#96;&#96;&#96;	countDown()&#96;&#96;&#96;：使计数器-1

&#96;&#96;&#96;	getCount()&#96;&#96;&#96;：返回当前计数器的值

下面的例子实现main线程的最后一句输出始终会在线程输出完之后执行

&#96;&#96;&#96;Java
public static void main(String[] args) throws InterruptedException &#123;
  CountDownLatch endSignal &#x3D; new CountDownLatch(3);

  for (int i &#x3D; 0; i &lt; 3; i++) &#123;
      new Thread(() -&gt; &#123;
          System.out.println(&quot;创建线程&quot;);
          endSignal.countDown();
      &#125;, String.valueOf(i)).start();
  &#125;

  endSignal.await();

  System.out.println(&quot;这将最后执行&quot;);
&#125;</code></pre>

<h2 id="JUC三个常用辅助类——CyclicBarrier"><a href="#JUC三个常用辅助类——CyclicBarrier" class="headerlink" title="JUC三个常用辅助类——CyclicBarrier"></a>JUC三个常用辅助类——CyclicBarrier</h2><p>CyclicBarrier是一个加法计数器，其计数依据不是数字，而是等待的线程数，当等待的线程数达到阈值时，他会唤醒所有等待线程</p>
<p>官方把它称作一个屏障，当有指定数量的线程到达屏障处等待时，屏障将消失，允许线程继续执行</p>
<p><span class="red bold">构造方法：</span></p>
<pre class="line-numbers language-CyclicBarrier​(int" data-language="CyclicBarrier​(int"><div class="caption"><span>parties)```：指定触发所需要的等待线程数</span></div><code class="language-CyclicBarrier​(int">
&#96;&#96;&#96;CyclicBarrier​(int parties, Runnable barrierAction)&#96;&#96;&#96;：指定触发所需要的等待线程数，屏障触发后会执行barrierAction线程

&lt;span class&#x3D;&quot;red bold&quot;&gt;方法：&lt;&#x2F;span&gt;

&#96;&#96;&#96;await()&#96;&#96;&#96;：使当前线程在屏障消失前等待

&#96;&#96;&#96;	await​(long timeout, TimeUnit unit)&#96;&#96;&#96;：使当前线程在屏障消失前进行超时等待（timeout：时间数字；unit：时间单位）

&#96;&#96;&#96;getNumberWaiting()&#96;&#96;&#96;：返回当前正在等待的线程数量

&#96;&#96;&#96;	getParties()&#96;&#96;&#96;：返回触发屏障消失所需的等待线程数

&#96;&#96;&#96;isBroken()&#96;&#96;&#96;：此屏障是否已经触发

&#96;&#96;&#96;reset()&#96;&#96;&#96;：重置屏障状态

下面的例子实现传入CyclicBarrier对象的线程会在下面五个线程都为等待状态时触发屏障而执行

&#96;&#96;&#96;Java
public static void main(String[] args) &#123;
  CyclicBarrier barrier &#x3D; new CyclicBarrier(5, () -&gt; System.out.println(&quot;屏障击破&quot;));


  for (int i &#x3D; 0; i &lt; 5; i++) &#123;
      new Thread(() -&gt; &#123;
          System.out.println(&quot;创建线程&quot;);
          try &#123;
              barrier.await();
          &#125; catch (InterruptedException e) &#123;
              e.printStackTrace();
          &#125; catch (BrokenBarrierException e) &#123;
              e.printStackTrace();
          &#125;
      &#125;).start();
  &#125;
&#125;</code></pre>

<h2 id="JUC三个常用辅助类——Semaphore"><a href="#JUC三个常用辅助类——Semaphore" class="headerlink" title="JUC三个常用辅助类——Semaphore"></a>JUC三个常用辅助类——Semaphore</h2><p>Semaphore类与上面两个计数器不同，Semaphore称为信号量，用于同一时间只能有指定数量的线程执行，执行完之后再把位置让给其他线程执行（像去茶餐厅吃饭找位置一样，同一个位置，别人吃完，你才能坐上去），通常用于限流</p>
<p><span class="red bold">构造方法：</span></p>
<pre class="line-numbers language-Semaphore​(int" data-language="Semaphore​(int"><div class="caption"><span>permits)```：指定可被申请的位置数，默认非公平</span></div><code class="language-Semaphore​(int">
&#96;&#96;&#96;Semaphore(int permits, boolean fair)&#96;&#96;&#96;：指定可被申请的位置数，并指定是否公平

&lt;span class&#x3D;&quot;red bold&quot;&gt;方法：&lt;&#x2F;span&gt;

&#96;&#96;&#96;acquire()&#96;&#96;&#96;：使该线程从此信号量获得许可，或未获取到许可则阻塞

&#96;&#96;&#96;acquire​(int permits)&#96;&#96;&#96;：使该线程从此信号量获得给定数量的许可，或未获取到许可则阻塞

&#96;&#96;&#96;release()&#96;&#96;&#96;：使该线程释放获取到的许可

&#96;&#96;&#96;release​(int permits)&#96;&#96;&#96;：使该线程释放给定数量的许可

&#96;&#96;&#96;	tryAcquire()&#96;&#96;&#96;：尝试申请许可，若申请不到则直接返回false

&#96;&#96;&#96;Java
public static void main(String[] args) &#123;
  Semaphore semaphore &#x3D; new Semaphore(3, true);

  for (int i &#x3D; 0; i &lt; 6; i++) &#123;
      final int temp &#x3D; i;
      new Thread(() -&gt; &#123;
          try &#123;
              semaphore.acquire();
              System.out.println(Thread.currentThread().getName() + &quot;请求到位置&quot;);
              Thread.sleep(temp * 1000);
              System.out.println(Thread.currentThread().getName() + &quot;释放位置&quot;);
              semaphore.release();
          &#125; catch (InterruptedException e) &#123;
              e.printStackTrace();
          &#125;
      &#125;).start();
  &#125;
&#125;</code></pre>

<h2 id="ReadWriteLock读写锁"><a href="#ReadWriteLock读写锁" class="headerlink" title="ReadWriteLock读写锁"></a>ReadWriteLock读写锁</h2><p>ReadWriteLock用于维护一对关联的锁，一个用于读取，一个用于写入，其中：</p>
<ul>
<li>读-读不互斥：读锁可被多个线程执行</li>
<li>写-写互斥：写锁不可以被多个线程执行</li>
</ul>
<p>规则：</p>
<ul>
<li>在非公平的情况下，允许读锁和写锁插队，但读锁能插队的条件是队列头结点不是想获取写锁的线程</li>
<li>读-写互斥：在任意线程获取到读锁时，不能有其他线程获取到写锁（防止读脏数据：指读到写过程中的中间状态），在任意线程获取到写锁时，不能再有线程获取到读锁</li>
</ul>
<p><span class="red bold">方法：</span></p>
<pre class="line-numbers language-readLock()```：返回读锁" data-language="readLock()```：返回读锁"><code class="language-readLock()```：返回读锁">
&#96;&#96;&#96;writeLock()&#96;&#96;&#96;：返回写锁

获取到读写锁之后，使用方法与ReentrantLock一样

&#96;&#96;&#96;lock()&#96;&#96;&#96;：加锁

&#96;&#96;&#96;unlock()&#96;&#96;&#96;：解锁

&lt;span class&#x3D;&quot;red bold&quot;&gt;关于共享锁和独占锁：&lt;&#x2F;span&gt;

* 共享锁：共享锁就是读锁，可以有多个线程获取读锁

* 独占锁：独占锁就是写锁，写锁是排它锁

## 阻塞队列BlockingQueue

|                        阻塞队列的关系图                        |
| :------------------------------------------------------------: |
| ![OpFZhd.md.png](https:&#x2F;&#x2F;s1.ax1x.com&#x2F;2022&#x2F;04&#x2F;30&#x2F;OpFZhd.md.png) |

## 阻塞队列的4组API

|     方式     | 抛出异常  | 不抛出异常，有返回值 | 阻塞等待 |                超时等待                 |
| :----------: | :-------: | :------------------: | :------: | :-------------------------------------: |
|     增加     |   add()   |       offer()        |  put()   | offer(E e, long timeout, TimeUnit unit) |
|  移除并返回  | remove()  |        poll()        |  take()  |    poll(long timeout, TimeUnit unit)    |
| 返回队首元素 | element() |        peek()        |    -     |                    -                    |

* 抛出异常列：当无法增加元素或取不到元素时会抛出运行时异常
* 不抛出异常列：当无法添加元素时或返回false，取不到元素是会返回null
* 阻塞等待列：当无法增加元素或取不到元素时会无限期等待
* 超时等待列：当无法增加元素或取不到元素时会进行超时等待，到达时间后未能执行的，跳过

## 同步队列SynchronousQueue

同步队列是容量为1的阻塞队列，必须由多个线程来操作

使用&#96;&#96;&#96;put()&#96;&#96;&#96;方法将数据放入队列，使用&#96;&#96;&#96;take()&#96;&#96;&#96;方法将队列中的数据删除并返回

&lt;span class&#x3D;&quot;red bold&quot;&gt;注意：&lt;&#x2F;span&gt;若没有线程在等待删除数据，则&#96;&#96;&#96;put()&#96;&#96;&#96;会进行等待

## 线程池

线程池重点：3大方法、7大参数、4种拒绝策略

---
**池化技术**

指将要重复开启关闭的资源事先准备好，有资源需要被使用则借出，使用完归还到池里

&lt;span class&#x3D;&quot;red bold&quot;&gt;好处：&lt;&#x2F;span&gt;

1. 降低资源消耗
2. 提高响应速度
3. 方便管理（如：线程池可以使线程可复用、还可控制最大并发数、管理线程）

---
**三大方法**

&lt;span class&#x3D;&quot;red bold&quot;&gt;规范：&lt;&#x2F;span&gt;线程池的创建不允许使用Executors工具类，应当使用ThreadPoolExecutor

&lt;span class&#x3D;&quot;red bold&quot;&gt;三大方法：&lt;&#x2F;span&gt;

&#96;&#96;&#96;newSingleThreadExecutor()&#96;&#96;&#96;：创建一个可以存储一个线程的线程池

&#96;&#96;&#96;newFixedThreadPool(int nThreads)&#96;&#96;&#96;：创建一个可以存储指定nThreads个线程的线程池

&#96;&#96;&#96;newCachedThreadPool()&#96;&#96;&#96;：创建一个动态容量的线程池，该线程池会随需要的线程来决定开启的线程数

&lt;span class&#x3D;&quot;red bold&quot;&gt;注意：&lt;&#x2F;span&gt;线程池使用完要使用&#96;&#96;&#96;shutdown()&#96;&#96;&#96;关闭

---
**初见ThreadPoolExecutor**

我们可以通过刚刚的三大方法的源码看到ThreadPoolExecutor，其实使用Executors来创建的线程池本质上就是使用ThreadPoolExexutor来创建

&#96;&#96;&#96;Java
public static ExecutorService newSingleThreadExecutor() &#123;
  return new FinalizableDelegatedExecutorService
      (new ThreadPoolExecutor(1, 1,
                              0L, TimeUnit.MILLISECONDS,
                              new LinkedBlockingQueue&lt;Runnable&gt;()));
&#125;

public static ExecutorService newFixedThreadPool(int nThreads) &#123;
  return new ThreadPoolExecutor(nThreads, nThreads,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue&lt;Runnable&gt;());
&#125;

public static ExecutorService newCachedThreadPool() &#123;
  return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                60L, TimeUnit.SECONDS,
                                new SynchronousQueue&lt;Runnable&gt;());
&#125;</code></pre>

<p>通过深入<code>ThreadPoolExecutor()</code>方法，我们可以得到：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public ThreadPoolExecutor(int corePoolSize,
                        int maximumPoolSize,
                        long keepAliveTime,
                        TimeUnit unit,
                        BlockingQueue&lt;Runnable&gt; workQueue,
                        ThreadFactory threadFactory,
                        RejectedExecutionHandler handler) &#123;
  if (corePoolSize &lt; 0 ||
      maximumPoolSize &lt;&#x3D; 0 ||
      maximumPoolSize &lt; corePoolSize ||
      keepAliveTime &lt; 0)
      throw new IllegalArgumentException();
  if (workQueue &#x3D;&#x3D; null || threadFactory &#x3D;&#x3D; null || handler &#x3D;&#x3D; null)
      throw new NullPointerException();
  this.corePoolSize &#x3D; corePoolSize;
  this.maximumPoolSize &#x3D; maximumPoolSize;
  this.workQueue &#x3D; workQueue;
  this.keepAliveTime &#x3D; unit.toNanos(keepAliveTime);
  this.threadFactory &#x3D; threadFactory;
  this.handler &#x3D; handler;
&#125;</code></pre>

<hr>
<p><strong>七大参数</strong></p>
<p>七大参数指的是通过ThreadPoolExxcutor创建线程池所传入的7个参数，他们分别是：</p>
<ul>
<li>corePoolSize：核心（默认）线程池大小</li>
<li>maximumPoolSize：最大线程池大小</li>
<li>keepAliveTime：超时释放时间（若超过这个时间无人调用则释放）</li>
<li>unit：超时单位</li>
<li>workQueue：阻塞队列</li>
<li>threadFactory：线程工厂（用于创建线程）</li>
<li>handler：拒绝策略</li>
</ul>
<table>
<thead>
<tr>
<th align="center">原生线程池通俗理解</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="https://s1.ax1x.com/2022/05/01/O9pvjK.md.png" alt="O9pvjK.md.png"></td>
</tr>
<tr>
<td align="center"><img src="https://s1.ax1x.com/2022/05/01/O998g0.md.png" alt="O998g0.md.png"></td>
</tr>
</tbody></table>
<ul>
<li>反观<code>newCachedThreadPool()</code>方法：我们可以知道：<ul>
<li>默认线程池大小为0</li>
<li>最大线程池大小为约21亿</li>
<li>闲置线程池超时释放时间为60秒</li>
<li>使用同步阻塞队列，只能容纳1个线程，队列中超过一个线程则启动线程池扩容</li>
<li>使用默认线程工厂（点进ThreadPoolExecutor方法可知）</li>
<li>使用默认拒绝策略（放弃过量的线程并抛出异常）（点进ThreadPoolExecutor方法可知）</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public static ExecutorService newCachedThreadPool() &#123;
  return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                60L, TimeUnit.SECONDS,
                                new SynchronousQueue&lt;Runnable&gt;());
&#125;</code></pre>

<blockquote>
<p>并且点开<code>newSingleThreadExecutor()</code>和<code>newFixedThreadPool(int nThreads)</code>方法我们可以知道为什么这两个线程池不会报错，因为其阻塞队列容量为Integer.MAX_VALUE，所以其阻塞队列不会满</p>
</blockquote>
<hr>
<p><strong>四大拒绝策略</strong></p>
<p><span class="red">当线程池的任务超出线程池队列可以存储的最大值之后，拒绝策略被触发</span></p>
<p>四大拒绝策略已经作为子类保存在ThreadPoolExecutor类中，他们分别是：</p>
<ol>
<li>AbortPolicy：拒绝新进任务并抛出异常</li>
<li>DiscardPolicy：忽略并抛弃新进任务</li>
<li>DiscardOldestPolicy：抛弃阻塞队列中位于头部的任务，并执行新进任务</li>
<li>CallerRunsPolicy：使用当前调用的线程执行新进任务（从哪里来回哪去 ）</li>
</ol>
<hr>
<p><strong>使用ThreadPoolExecutor创建线程池</strong></p>
<p>现在你已经知道了7大参数是什么意思，来试试用更底层的方法创建一个线程池：</p>
<p><span class="red bold">要求：</span>2个常开柜台，3个选开柜台，阻塞队列容量为3，拒绝策略为抛出异常</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">ThreadPoolExecutor threadPool &#x3D; new ThreadPoolExecutor(2, 5,
       3, TimeUnit.SECONDS,
       new ArrayBlockingQueue&lt;&gt;(3),
       Executors.defaultThreadFactory(),
       new ThreadPoolExecutor.DiscardOldestPolicy());</code></pre>

<hr>
<p><strong>最大线程该如何定义</strong></p>
<p><span class="red bold">设置依据——CPU密集型</span></p>
<p>CPU密集型：CPU有n个逻辑处理器（线程），则最多同时执行n条线程，<span class="red">多少线程的CPU就定义线程池最大容量为多少</span>，使效率最大化</p>
<ul>
<li><p>关于n核m线程（逻辑处理器）：如6核12线程（12个逻辑处理器），指的是有六个物理核心，每个核心进行双线程运算，则可以被理解为12个单线程核心</p>
<p>  代码获取CPU总线程数：</p>
  <pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">Runtime.getRuntime().availableProcessors()</code></pre></li>
</ul>
<p><span class="red bold">设置依据——IO密集型</span></p>
<p>IO密集型：指该项目中有n个十分消耗IO资源的线程，<span class="red">将线程池的最大容量设置为大于n即可，通常为2n</span></p>
<h2 id="四大函数式接口"><a href="#四大函数式接口" class="headerlink" title="四大函数式接口"></a>四大函数式接口</h2><p><span class="red bold">函数式接口：</span>指只有一个抽象方法的接口</p>
<p>四大函数式接口位于java.util.function包中</p>
<hr>
<p><strong>Function接口（函数）</strong><br><span class="red bold">（任意类型输入-&gt;任意类型输出）</span></p>
<p>Function接口是一种函数处理，在写该接口的实现类时要指定<span class="red">输入和输出</span>的数据类型</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">Function&lt;String, String&gt; function &#x3D; new Function&lt;String, String&gt;() &#123;
    @Override
    public String apply(String s) &#123;
        return s;
    &#125;
&#125;;

Function&lt;String, String&gt; function &#x3D; s -&gt; s;</code></pre>

<hr>
<p><strong>Predicate接口（断言）</strong><br><span class="red bold">（任意类型输入-&gt;布尔类型输出）</span></p>
<p>Predicate是一种判断，在写该接口的实现类的时候需要指定<span class="red">输入</span>的数据类型</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">Predicate&lt;String&gt; predicate &#x3D; new Predicate&lt;String&gt;() &#123;
    @Override
    public boolean test(String s) &#123;
        return null &#x3D;&#x3D; s ? false : s.isEmpty();
    &#125;
&#125;;</code></pre>

<hr>
<p><strong>Supplier接口</strong><br><span class="red bold">（无输入-&gt;任意类型输出）</span></p>
<p>Supplier是一种供给者，没有输入，只有输出</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">Supplier&lt;String&gt; supplier &#x3D; new Supplier&lt;String&gt;() &#123;
    @Override
    public String get() &#123;
        return null;
    &#125;
&#125;;</code></pre>

<hr>
<p><strong>Consumer接口</strong><br><span class="red bold">（任意类型输入-&gt;无输出）</span></p>
<p>Consumer是一种消费者，只有输入，没有输出</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">Consumer&lt;String&gt; consumer &#x3D; new Consumer&lt;&gt;() &#123;
    @Override
    public void accept(String o) &#123;
        System.out.println(o);
    &#125;
&#125;;</code></pre>

<h2 id="stream流式计算-链式编程"><a href="#stream流式计算-链式编程" class="headerlink" title="stream流式计算/链式编程"></a>stream流式计算/链式编程</h2><p>上面函数式接口简不简单？其实函数式接口是为stream服务哒</p>
<p>stream位于java.util.stream包下</p>
<p><span class="red bold">获取流：</span></p>
<p>stream是一个接口，无法被new出，我们可以通过以下方法获取流：</p>
<ol>
<li>collection对象的方法<code>stream()</code>获取集合的流</li>
<li>Arrays工具类静态方法<code>stream()</code>获取数组的流</li>
<li>通过BufferedReader对象的方法<code>lines()</code>获取BufferedReader读取的行的流</li>
<li>Files工具类中静态方法<code>    list​(Path dir)</code>获取目录中的条目的流</li>
<li>使用Stream类静态方法<code>of(T t)</code>获取传入元素组成的流</li>
<li>……</li>
</ol>
<p><span class="red bold">流方法（判断）：</span></p>
<pre class="line-numbers language-allMatch​(Predicate" data-language="allMatch​(Predicate"><div class="caption"><span>predicate)```：传入一个断言接口实现类，返回此流中的每一个元素是否都满足此断言</span></div><code class="language-allMatch​(Predicate">
&#96;&#96;&#96;	anyMatch​(Predicate predicate)&#96;&#96;&#96;：传入一个断言接口实现类，返回此流中的任何一个元素是否满足此断言

&#96;&#96;&#96;noneMatch​(Predicate predicate)&#96;&#96;&#96;：传入一个断言接口实现类，返回此流中是否没有元素满足此断言

&lt;span class&#x3D;&quot;red bold&quot;&gt;流方法（统计）：&lt;&#x2F;span&gt;

&#96;&#96;&#96;count()&#96;&#96;&#96;：返回此流中元素的数量

&lt;span class&#x3D;&quot;red bold&quot;&gt;流方法（功能性）：&lt;&#x2F;span&gt;

&#96;&#96;&#96;filter​(Predicate predicate)&#96;&#96;&#96;：流元素过滤器，传入一个断言接口实现类，返回所有满足此断言的元素组成的流

&#96;&#96;&#96;forEach​(Consumer action)&#96;&#96;&#96;：无返回流元素消费器，传入一个消费型接口的实现类，对此流所有元素进行消费操作，&lt;span class&#x3D;&quot;red&quot;&gt;并且会中断链式操作（指不能继续点下去）&lt;&#x2F;span&gt;，通常用于最后

&#96;&#96;&#96;limit​(long maxSize)&#96;&#96;&#96;：对流进行截断，使流长度不超过限定值

&#96;&#96;&#96;map(Function mapper)&#96;&#96;&#96;：流元素处理器，传入一个函数接口实现类，返回该流所有元素经过该函数处理后的元素组成的流

&#96;&#96;&#96;max​(Comparator comparator)&#96;&#96;&#96;：流元素取最大，传入一个比较器，返回该流中最大的元素

&#96;&#96;&#96;min​(Comparator comparator)&#96;&#96;&#96;：流元素取最小，传入一个比较器，返回该流中最小的元素

&#96;&#96;&#96;peek​(Consumer action)&#96;&#96;&#96;：有返回流元素消费器，传入一个消费型接口的实现类，对此流所有元素进行消费操作，&lt;span class&#x3D;&quot;red&quot;&gt;不会中断链式操作（指可以继续点下去）&lt;&#x2F;span&gt;，通常用于中间（peek：偷看（运行过程））

&#96;&#96;&#96;skip​(long n)&#96;&#96;&#96;：删除调用该方法的流的前n个元素，返回删除后的流

&#96;&#96;&#96;sorted()&#96;&#96;&#96;：流元素排序器，对流元素进行自然排序

&#96;&#96;&#96;sorted​(Comparator comparator)&#96;&#96;&#96;：流元素排序器，传入一个比较器，对流中的元素进行排序，返回排序后的流

* 我们不仅可以重写Comparator中的compare方法，Comparator还提供一些默认方法供使用
    &#96;&#96;&#96;reverseOrder()&#96;&#96;&#96;：返回一个自然逆序排序器

    &#96;&#96;&#96;comparing(Function keyExtractor)&#96;&#96;&#96;：传入一个类的排序键，返回一个以该键值为依据的自然比较器（如：根据年龄的值排序，则传入 (类的对象名) -&gt; 类的对象名.getAge() 或 类名::getAge）

    &#96;&#96;&#96;comparing(Function keyExtractor, Comparator keyComparator)&#96;&#96;&#96;：传入一个类的排序键，并且传入一个自定义排序器，返回一个以该键值为依据的自定义比较器

    &#96;&#96;&#96;reversed()&#96;&#96;&#96;：返回调用该方法的比较器的逆序比较器

    &#96;&#96;&#96;thenComparing​(Function keyExtractor)&#96;&#96;&#96;：用于多字段排序，当前一个Comparing比较相同时，使用自然比较器比较该键值

    &#96;&#96;&#96;thenComparing(Function keyExtractor, Comparator keyComparator)&#96;&#96;&#96;：用于多字段排序，当前一个Comparing比较相同时，使用传入的自定义比较器比较该键值

&#96;&#96;&#96;dropWhile​(Predicate predicate)&#96;&#96;&#96;：传入一个断言接口实现类，从头开始丢弃掉流中的元素，直到流中的元素不满足该断言

&#96;&#96;&#96;Java
Stream&lt;Character&gt; stream &#x3D; Stream.of(&#39;A&#39;, &#39;B&#39;, &#39;c&#39;, &#39;D&#39;, &#39;E&#39;);

stream.dropWhile(Character::isUpperCase).forEach(System.out::print);

&#x2F;*输出：
* cDE
*&#x2F;</code></pre>

<pre class="line-numbers language-takeWhile​(Predicate" data-language="takeWhile​(Predicate"><div class="caption"><span>predicate)```：传入一个断言接口实现类，从头开始提取流中的元素，直到流中的元素不满足该断言</span></div><code class="language-takeWhile​(Predicate">
&#96;&#96;&#96;Java
Stream&lt;Character&gt; stream &#x3D; Stream.of(&#39;A&#39;, &#39;B&#39;, &#39;c&#39;, &#39;D&#39;, &#39;E&#39;);

stream.takeWhile(Character::isUpperCase).forEach(System.out::print);

&#x2F;*输出：
* AB
*&#x2F;</code></pre>

<p>lambda表达式、链式编程、函数式接口、stream流式计算</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/04/22/Java-IO%E6%B5%81/" rel="prev" title="Java IO流">
                  <i class="fa fa-chevron-left"></i> Java IO流
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Loliconkelvin</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdn.jsdelivr.net/npm/ribbon.js@1.0.2/dist/ribbon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.24.1/components/prism-core.min.js" integrity="sha256-dz05jjFU9qYuMvQQlE6iWDtNAnEsmu6uMb1vWhKdkEM=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.24.1/plugins/autoloader/prism-autoloader.min.js" integrity="sha256-sttoa+EIAvFFfeeIkmPn8ypyOOb6no2sZ2NbxtBXgqU=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.24.1/plugins/line-numbers/prism-line-numbers.min.js" integrity="sha256-K837BwIyiXo5k/9fCYgqUyA14bN4/Ve9P2SIT0KmZD0=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
