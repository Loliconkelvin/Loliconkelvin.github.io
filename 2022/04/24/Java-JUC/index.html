<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"loliconkelvin.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.12.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":true,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content=".red {         color: red;     }     .bold {         font-weight: bold;     }   Java-JUC">
<meta property="og:type" content="article">
<meta property="og:title" content="Java JUC">
<meta property="og:url" content="https://loliconkelvin.github.io/2022/04/24/Java-JUC/index.html">
<meta property="og:site_name" content="萝莉控的小窝">
<meta property="og:description" content=".red {         color: red;     }     .bold {         font-weight: bold;     }   Java-JUC">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s1.ax1x.com/2022/04/25/LIDpTK.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/04/25/LT3PrF.md.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/04/26/LbE66H.md.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/04/26/LbE4tf.md.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/04/26/LbVS9U.md.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/04/26/LbVEAx.md.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/04/26/LbVm9O.md.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/04/26/LbVKjH.md.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/04/30/OpFZhd.md.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/01/O9pvjK.md.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/01/O998g0.md.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/02/Oi1YB8.md.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/02/Oi1O4H.md.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/02/OiHRC6.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/07/OQ204H.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/03/OAAjQU.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/03/OAMKRs.md.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/04/OEuk2n.md.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/04/OEMIbV.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/06/OnNa8A.md.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/05/OeZPqf.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/05/Oeu0cd.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/06/Ou2jw4.md.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/06/OuRFOO.md.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/06/OuRekd.md.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/06/OuRlX8.md.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/06/OKQGNR.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/10/16/5JTvtJ.png">
<meta property="article:published_time" content="2022-04-24T08:28:50.000Z">
<meta property="article:modified_time" content="2022-06-19T01:51:12.971Z">
<meta property="article:author" content="Loliconkelvin">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s1.ax1x.com/2022/04/25/LIDpTK.png">


<link rel="canonical" href="https://loliconkelvin.github.io/2022/04/24/Java-JUC/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://loliconkelvin.github.io/2022/04/24/Java-JUC/","path":"2022/04/24/Java-JUC/","title":"Java JUC"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Java JUC | 萝莉控的小窝</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">萝莉控的小窝</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFJUC"><span class="nav-number">1.</span> <span class="nav-text">什么是JUC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">线程和进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C"><span class="nav-number">3.</span> <span class="nav-text">并发和并行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E9%A1%BE%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8Esynchronized%E5%90%8C%E6%AD%A5"><span class="nav-number">4.</span> <span class="nav-text">回顾多线程与synchronized同步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lock"><span class="nav-number">5.</span> <span class="nav-text">Lock</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized%E5%92%8CLock%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.</span> <span class="nav-text">synchronized和Lock的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-number">7.</span> <span class="nav-text">生产者消费者问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8%E9%94%81%E7%8E%B0%E8%B1%A1%E7%90%86%E8%A7%A3%E9%94%81"><span class="nav-number">8.</span> <span class="nav-text">8锁现象理解锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88%E7%B1%BB"><span class="nav-number">9.</span> <span class="nav-text">不安全的集合类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Callable"><span class="nav-number">10.</span> <span class="nav-text">Callable</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JUC%E4%B8%89%E4%B8%AA%E5%B8%B8%E7%94%A8%E8%BE%85%E5%8A%A9%E7%B1%BB%E2%80%94%E2%80%94CountDownLatch"><span class="nav-number">11.</span> <span class="nav-text">JUC三个常用辅助类——CountDownLatch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JUC%E4%B8%89%E4%B8%AA%E5%B8%B8%E7%94%A8%E8%BE%85%E5%8A%A9%E7%B1%BB%E2%80%94%E2%80%94CyclicBarrier"><span class="nav-number">12.</span> <span class="nav-text">JUC三个常用辅助类——CyclicBarrier</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JUC%E4%B8%89%E4%B8%AA%E5%B8%B8%E7%94%A8%E8%BE%85%E5%8A%A9%E7%B1%BB%E2%80%94%E2%80%94Semaphore"><span class="nav-number">13.</span> <span class="nav-text">JUC三个常用辅助类——Semaphore</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ReadWriteLock%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-number">14.</span> <span class="nav-text">ReadWriteLock读写锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97BlockingQueue"><span class="nav-number">15.</span> <span class="nav-text">阻塞队列BlockingQueue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%844%E7%BB%84API"><span class="nav-number">16.</span> <span class="nav-text">阻塞队列的4组API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97SynchronousQueue"><span class="nav-number">17.</span> <span class="nav-text">同步队列SynchronousQueue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">18.</span> <span class="nav-text">线程池</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E5%A4%A7%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="nav-number">19.</span> <span class="nav-text">四大函数式接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stream%E6%B5%81%E5%BC%8F%E8%AE%A1%E7%AE%97-x2F-%E9%93%BE%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="nav-number">20.</span> <span class="nav-text">stream流式计算&#x2F;链式编程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ForkJoin"><span class="nav-number">21.</span> <span class="nav-text">ForkJoin</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Stream%E5%B9%B6%E8%A1%8C%E6%B5%81%E8%AE%A1%E7%AE%97"><span class="nav-number">22.</span> <span class="nav-text">Stream并行流计算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83%EF%BC%88Future%EF%BC%89"><span class="nav-number">23.</span> <span class="nav-text">异步回调（Future）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%90%86%E8%A7%A3Volatile"><span class="nav-number">24.</span> <span class="nav-text">理解Volatile</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="nav-number">25.</span> <span class="nav-text">原子性包装类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E4%B8%8E%E5%8F%8D%E5%B0%84%E4%B9%8B%E4%BA%89"><span class="nav-number">26.</span> <span class="nav-text">单例模式——单例与反射之争</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%A0%B4%E5%9D%8F"><span class="nav-number">27.</span> <span class="nav-text">单例模式——破坏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81%E6%80%BB%E7%BB%93"><span class="nav-number">28.</span> <span class="nav-text">锁总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E6%8E%92%E6%9F%A5"><span class="nav-number">29.</span> <span class="nav-text">死锁排查</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Loliconkelvin"
      src="/uploads/avatar.png">
  <p class="site-author-name" itemprop="name">Loliconkelvin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">50</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Loliconkelvin" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Loliconkelvin" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:Loliconkelvin@gmail.com" title="E-Mail → mailto:Loliconkelvin@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://loliconkelvin.github.io/2022/04/24/Java-JUC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Loliconkelvin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萝莉控的小窝">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Java JUC | 萝莉控的小窝">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java JUC
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-24 16:28:50" itemprop="dateCreated datePublished" datetime="2022-04-24T16:28:50+08:00">2022-04-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-06-19 09:51:12" itemprop="dateModified" datetime="2022-06-19T09:51:12+08:00">2022-06-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <style>
    .red {
        color: red;
    }
    .bold {
        font-weight: bold;
    }
</style>

<p>Java-JUC</p>
<span id="more"></span>

<h2 id="什么是JUC"><a href="#什么是JUC" class="headerlink" title="什么是JUC"></a>什么是JUC</h2><p>JUC指 java.util.concurrent 包，还包括 java.util.concurrent.atomic java.util.concurrent.locks</p>
<h2 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h2><p><span class="red bold">进程：</span>指一个程序，一个进程会包含至少一个线程（Java默认有两个线程：main、gc）</p>
<p><span class="red bold">线程：</span>指一个程序里的一些同步进行的功能，它们可能是通过线程实现的</p>
<p>Java本身不能开启线程，因为Java运行在虚拟机中，无法直接操作硬件，它是通过调用底层C++来开启线程</p>
<hr>
<p><strong>回顾线程的状态</strong></p>
<p>理论上：创建、就绪、运行、死亡、阻塞</p>
<p>源码指定的：</p>
<ol>
<li>NEW：创建</li>
<li>RUNNABLE：就绪</li>
<li>BLOCKED：阻塞</li>
<li>WAITING：无限期等待</li>
<li>TIMED_WAITING：超时等待（有时间限制）</li>
<li>TERMINATED：消亡</li>
</ol>
<hr>
<p><strong>wait和sleep的区别</strong></p>
<ol>
<li>来自不同的类<ul>
<li>wait在Object里</li>
<li>sleep在Thread里</li>
</ul>
</li>
<li>锁<ul>
<li>wait会释放锁</li>
<li>sleep抱着锁睡觉</li>
</ul>
</li>
<li>适用范围不同<ul>
<li>wait必须在同步代码块中</li>
<li>任何线程都可以sleep</li>
</ul>
</li>
</ol>
<h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><p><span class="red bold">并发：</span>指多个线程操作一个资源。并发的本质是一个CPU在多个程序之间切换运行。</p>
<p><span class="red bold">并行：</span>指多个线程可以同时被多个CPU执行</p>
<h2 id="回顾多线程与synchronized同步"><a href="#回顾多线程与synchronized同步" class="headerlink" title="回顾多线程与synchronized同步"></a>回顾多线程与synchronized同步</h2><hr>
<p><strong>面向对象的多线程编写</strong></p>
<p>以前写多线程时，经常一个类继承Thread类或实现Runnable接口，但是这都不够面向对象</p>
<p><span class="red bold">资源类：</span>专类专用，在真正的线程开发中，线城市一个单独的资源类，只有属性和方法，如：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Ticket &#123;
    &#x2F;&#x2F; 票数
    private static int number &#x3D; 50;

    &#x2F;&#x2F; 卖票方法
    public synchronized void sale() &#123;
        if (number &gt; 0) &#123;
            System.out.println(Thread.currentThread().getName() + &quot;卖出了第&quot; + number-- + &quot;张票，&quot; + &quot;剩余&quot; + number + &quot;张&quot;);
            try &#123;
                Thread.sleep(100);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

<p><span class="red bold">线程操作：</span>那么如何实现线程对资源类的操作？只需要想办法将资源类丢到线程里即可，基本思路是：<code>Thread里丢Runnable，Runnable里丢run方法，run方法里丢资源类方法</code>，如：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F; 首先需要一个被操作的资源类
Ticket ticket &#x3D; new Ticket();

&#x2F;&#x2F; 然后需要一个线程，然后把资源类扔进线程里
new Thread(() -&gt; &#123;
   for (int i &#x3D; 0; i &lt; 60; i++) &#123;
       ticket.sale();
   &#125;
&#125;, &quot;A&quot;).start();</code></pre>

<p><span class="red bold">实现同步：</span>针对synchronized同步，就是在方法里面加上synchronized修饰（或使用synchronized代码块）</p>
<p><span class="red">关于锁：</span>锁会锁定两个东西，一个是对象，一个是class</p>
<h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><p>Lock指java.util.concurrent.locks中的lock接口，它有三个实现类，分别是：</p>
<ol>
<li>ReentrantLock：可重入锁（常用）</li>
<li>ReentrantReadWriteLock.ReadLock：读锁（内部类）</li>
<li>ReentrantReadWriteLock.WriteLock：写锁（内部类）</li>
</ol>
<p>我们先使用可重入锁，根据官方文档，使用可重入锁分为三步：</p>
<ol>
<li>创建锁对象（Lock lock &#x3D; new …）</li>
<li>加锁（Lock.lock() try { &#x2F;&#x2F; 同步代码块}）</li>
<li>解锁（ finally {lock.unlock()} ）</li>
</ol>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Ticket2 &#123;
    &#x2F;&#x2F; 票数
    private static int number &#x3D; 50;

    &#x2F;&#x2F; 创建锁对象
    Lock lock &#x3D; new ReentrantLock();

    &#x2F;&#x2F; 卖票方法
    public void sale() &#123;
        &#x2F;&#x2F; 加锁
        lock.lock();

        try &#123;
            if (number &gt; 0) &#123;
                System.out.println(Thread.currentThread().getName() + &quot;卖出了第&quot; + number-- + &quot;张票，&quot; + &quot;剩余&quot; + number + &quot;张&quot;);
                try &#123;
                    Thread.sleep(100);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125; finally &#123;
            &#x2F;&#x2F; 解锁
            lock.unlock();
        &#125;
    &#125;
&#125;</code></pre>

<h2 id="synchronized和Lock的区别"><a href="#synchronized和Lock的区别" class="headerlink" title="synchronized和Lock的区别"></a>synchronized和Lock的区别</h2><table>
<thead>
<tr>
<th align="center">synchronized</th>
<th align="center">Lock</th>
</tr>
</thead>
<tbody><tr>
<td align="center">关键字</td>
<td align="center">类</td>
</tr>
<tr>
<td align="center">自动加锁解锁</td>
<td align="center">手动加锁解锁</td>
</tr>
<tr>
<td align="center">无法判断锁的状态</td>
<td align="center">可以判断锁的状态</td>
</tr>
<tr>
<td align="center">一直等待</td>
<td align="center">可以设置超时</td>
</tr>
<tr>
<td align="center">非公平锁</td>
<td align="center">可以自定义是否公平</td>
</tr>
<tr>
<td align="center">少量同步代码</td>
<td align="center">大量同步代码</td>
</tr>
</tbody></table>
<ol>
<li>synchronized是一个Java内置关键字；Lock是一个类</li>
<li>synchronized自动隐式加锁；Lock手动显式加锁</li>
<li>synchronized无法判断获取锁的状态；Lock可以判断是否获取到了锁</li>
<li>synchronized会自动释放锁；Lock需要手动释放，若不释放会造成死锁</li>
<li>synchronized在一个线程阻塞的时候，另一个线程会一直等；Lock锁时则另一个线程不一定会一直等（tryLock()）</li>
<li>synchronized为可重入锁，不可以中断的，非公平锁；Lock为可重入锁，可以判断锁的状态，可以自定义是否公平</li>
<li>synchronized适合少量代码同步问题；Lock适合锁大量同步代码</li>
</ol>
<h2 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h2><p>PC（ProducerConsumer）问题三部曲：<span class="red">判断等待-&gt;业务-&gt;唤醒</span></p>
<hr>
<p><strong>回顾synchronized版生产者消费者问题</strong></p>
<p>根据PC问题三部曲并且根据上面资源类的格式，可以得到以下代码：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class ProducerConsumer &#123;
    public static void main(String[] args) &#123;
        Buffer buffer &#x3D; new Buffer();

        new Thread(() -&gt; &#123;
            for (int i &#x3D; 0; i &lt; 10; i++) &#123;
                buffer.put(i);
            &#125;
        &#125;, &quot;Producer1&quot;).start();

        new Thread(() -&gt; &#123;
            for (int i &#x3D; 0; i &lt; 10; i++) &#123;
                buffer.get();
            &#125;
        &#125;, &quot;Consumer1&quot;).start();
    &#125;
&#125;

class Buffer &#123;
    private int buffer;
    private boolean updated &#x3D; false;

    &#x2F;&#x2F; 生产者将调用该方法
    public synchronized void put(int num) &#123;
        &#x2F;&#x2F; 判断等待（使用while防止虚假唤醒）
        if (updated) &#123;
            try &#123;
                this.wait();
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        &#x2F;&#x2F; 操作
        buffer &#x3D; num;
        System.out.println(Thread.currentThread().getName() + &quot;放入&quot; + buffer);
        updated &#x3D; true;

        &#x2F;&#x2F; 唤醒
        notifyAll();
    &#125;

    &#x2F;&#x2F; 消费者将调用该方法
    public synchronized void get() &#123;
        &#x2F;&#x2F; 判断等待
        if (!updated) &#123;
            try &#123;
                this.wait();
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        &#x2F;&#x2F; 业务
        System.out.println(Thread.currentThread().getName() + &quot;取出&quot; + buffer);
        updated &#x3D; false;

        &#x2F;&#x2F; 通知
        notifyAll();
    &#125;
&#125;</code></pre>

<hr>
<p><strong>虚假唤醒问题</strong></p>
<p>虚假唤醒指多个线程被唤醒，但有些线程是有效的，有些线程是无效或会造成错误的</p>
<p><span class="red bold">问题：</span></p>
<p>注意上面在同步方法在中使用了if来判断，这在两个线程操作一个对象的时候没有问题，但是在两个以上操作线程时就会出现问题</p>
<p><img src="https://s1.ax1x.com/2022/04/25/LIDpTK.png" alt="LIDpTK.png"></p>
<p><span class="red bold">问题分析：</span></p>
<p>当有两个消费者（消费者同理）时</p>
<ol>
<li>在上一次两个生产者被同时notify唤醒后，有一个生产者（假设是生产者1）执行完了方法，而另一个（假设是生产者2）来不及执行，停在了this.wait()方法处</li>
<li>而当两个生产者再次被notify唤醒时，碰巧生产者1抢占到了资源并执行完毕，然后生产者2紧接着占到资源，从wait处继续往下执行，就造成了两个生产者都操作了资源的问题<br><img src="https://s1.ax1x.com/2022/04/25/LT3PrF.md.png" alt="LT3PrF.md.png"></li>
</ol>
<blockquote>
<p>实例分析（应用于对数据进行+1和-1）：线程1进入方法，++后释放，线程2进入方法，！&#x3D;被wait，线程3进入方法，–后释放，释放的瞬间线程1拿到了锁，进入后++，线程2从wait中被唤醒，向下执行后++，出现了2这样的数字</p>
</blockquote>
<p><span class="red bold">解决：</span>将判断等待部分使用while判断，使wait结束之后不能马上进入业务，还要再判断一遍</p>
<hr>
<p><strong>JUC版生产者消费者问题</strong></p>
<p>synchronized有wait和notify，Lock接口本身并没有可以代替这两个方法的方法，但另一个接口Condition有</p>
<p><span class="red bold">构造方法：</span>需要通过Lock对象的 <code>newCondition()</code> 方法将Condition对象new出，该Condition对象会与对应的Lock对象绑定</p>
<p><span class="red bold">方法：</span></p>
<p><code>await()</code>：当前线程等待，直到发出信号或中断</p>
<p><code>signal()</code>：唤醒一个等待线程</p>
<p><code>signalAll()</code>：唤醒所有等待线程</p>
<p><span class="red bold">使用格式：</span></p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private final Lock lock &#x3D; new Lock();
println final Condition put &#x3D; lock.newCondition();
println final Condition get &#x3D; lock.newCondition();

public void put(int num) &#123;
    lock.lock();
    try &#123;
        while(updated) &#123;
            put.await();
        &#125;

        &#x2F;&#x2F; ......

        get.signalAll();
    &#125; finally &#123;
        lock.unlock;
    &#125;
&#125;</code></pre>

<hr>
<p><strong>Condition精准通知某个线程</strong></p>
<p>Condition的特点在于：<span class="red">一个Lock锁可以与多个监视器绑定，一个监视器监视一个线程，则可以实现精准通知某个监视器（线程）</span></p>
<h2 id="8锁现象理解锁"><a href="#8锁现象理解锁" class="headerlink" title="8锁现象理解锁"></a>8锁现象理解锁</h2><p>现有以下程序：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class LockTest &#123;
    public static void main(String[] args) &#123;
        Phone phone &#x3D; new Phone();
        new Thread(phone::sendMsg, &quot;A&quot;).start();

        new Thread(phone::call, &quot;B&quot;).start();
    &#125;
&#125;

class Phone &#123;
    public synchronized void sendMsg() &#123;
        System.out.println(&quot;发短信&quot;);
    &#125;

    public synchronized void call() &#123;
        System.out.println(&quot;打电话&quot;);
    &#125;
&#125;</code></pre>

<hr>
<ol>
<li><strong>main线程延时（对象锁）</strong></li>
</ol>
<p><span class="red bold">问题：</span>若在main线程中的两个线程开启之间延时4s，发短信和打电话谁先执行？</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">Phone phone &#x3D; new Phone();
new Thread(phone::sendMsg, &quot;A&quot;).start();

try &#123;
   TimeUnit.SECONDS.sleep(4);
&#125; catch (InterruptedException e) &#123;
   e.printStackTrace();
&#125;

new Thread(phone::call, &quot;B&quot;).start();</code></pre>

<p><span class="red bold">解答：</span>发短息先执行 <br /><br>因为发短信在主线程中先被开启，拿到了锁，打电话在4s后被开启，得到锁</p>
<p><img src="https://s1.ax1x.com/2022/04/26/LbE66H.md.png" alt="LbE66H.md.png"></p>
<hr>
<ol start="2">
<li><strong>main线程 + 同步方法延时</strong></li>
</ol>
<p><span class="red bold">问题：</span>若发短信方法延时4s，main线程延时2s，谁先执行？</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public synchronized void sendMsg() &#123;
  try &#123;
      TimeUnit.SECONDS.sleep(4);
  &#125; catch (InterruptedException e) &#123;
      e.printStackTrace();
  &#125;
  System.out.println(&quot;发短信&quot;);
&#125;</code></pre>

<p><span class="red bold">解答：</span>发短信先执行 <br /><br>因为还是发短息先得到了锁，并且发短信会在4s后</p>
<p><img src="https://s1.ax1x.com/2022/04/26/LbE4tf.md.png" alt="LbE4tf.md.png"></p>
<p><span class="red bold">对象锁：</span>这里锁的是phone对象，因为两个线程使用用一个对象，因此使用同一把锁</p>
<hr>
<ol start="3">
<li><strong>同步方法 + 不同步方法</strong></li>
</ol>
<p><span class="red bold">问题：</span>将打电话改为不同步方法，延时条件不变（main延时2s，发短信延时4s），谁先执行？</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public void call() &#123;
        System.out.println(&quot;打电话&quot;);
    &#125;</code></pre>

<p><span class="red bold">解答：</span>打电话先执行，因为打电话不是同步方法，不受锁的影响，因此只需要看时间延时决定谁先执行。</p>
<p><img src="https://s1.ax1x.com/2022/04/26/LbVS9U.md.png" alt="LbVS9U.md.png"></p>
<hr>
<ol start="4">
<li><strong>两个对象</strong></li>
</ol>
<p><span class="red bold">问题：</span>将new一个对象变为new两个对象，两个线程分别调用两个对象的发短信和打电话方法，延时条件不变（main延时2s，发短信延时4s），谁先执行？</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class LockTest1 &#123;
    public static void main(String[] args) &#123;
        Phone1 phone1 &#x3D; new Phone1();
        Phone1 phone2 &#x3D; new Phone1();
        new Thread(phone1::sendMsg, &quot;A&quot;).start();

        try &#123;
            TimeUnit.SECONDS.sleep(2);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;

        new Thread(phone2::call, &quot;B&quot;).start();
    &#125;
&#125;</code></pre>

<p><span class="red bold">解答：</span>打电话先执行，因为是两个不同的对象，因此是两把锁互不干涉，看时间延时来决定谁先执行</p>
<p><img src="https://s1.ax1x.com/2022/04/26/LbVEAx.md.png" alt="LbVEAx.md.png"></p>
<hr>
<ol start="5">
<li><strong>静态同步方法（Class锁）</strong></li>
</ol>
<p><span class="red bold">问题：</span>将两个同步方法都变为静态同步方法，只有一个对象，延时条件不变（main延时2s，发短信延时4s），谁先执行？</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public static synchronized void sendMsg() &#123;
  try &#123;
      TimeUnit.SECONDS.sleep(4);
  &#125; catch (InterruptedException e) &#123;
      e.printStackTrace();
  &#125;
  System.out.println(&quot;发短信&quot;);
&#125;

public static synchronized void call() &#123;
  System.out.println(&quot;打电话&quot;);
&#125;</code></pre>

<p><span class="red bold">解答：</span>发短信先执行，静态方法锁的是该类的Class对象，Class对象一个类只对应一个，谁先拿到谁先执行</p>
<p><img src="https://s1.ax1x.com/2022/04/26/LbVm9O.md.png" alt="LbVm9O.md.png"></p>
<p><span class="red bold">Class锁：</span>Class锁会在调用该类静态方法时用到，只要是调用该类的静态方法，都要请求到这个Class对象锁，相当于是<span class="red">Class锁会将该类的静态方法全部锁定</span></p>
<hr>
<ol start="6">
<li><strong>静态方法 + 两个对象</strong></li>
</ol>
<p><span class="red bold">问题：</span>两个对象，谁先执行？</p>
<p><span class="red bold">解答：</span>结果和上面一样，发短信先执行，本来静态方法的调用就和对象没关系，并且Class锁并不是根据对象来锁的，也跟对象没关系</p>
<hr>
<ol start="7">
<li><strong>静态方法 + 非静态方法</strong></li>
</ol>
<p><span class="red bold">问题：</span>发短信是静态同步方法，打电话是普通同步方法，延时条件不变（main延时2s，发短信延时4s），谁先执行？</p>
<p><span class="red bold">解答：</span>打电话先执行，这是两把锁互不干涉，看时间延时来决定谁先执行</p>
<p><img src="https://s1.ax1x.com/2022/04/26/LbVKjH.md.png" alt="LbVKjH.md.png"></p>
<hr>
<ol start="8">
<li><strong>静态方法 + 非静态方法 + 两个对象</strong></li>
</ol>
<p><span class="red bold">问题：</span>在第7问的基础上将对象变为两个，谁先执行？</p>
<p><span class="red bold">解答：</span>打电话先执行，这里有两把锁互不干涉，看时间延时来决定谁先执行</p>
<h2 id="不安全的集合类"><a href="#不安全的集合类" class="headerlink" title="不安全的集合类"></a>不安全的集合类</h2><hr>
<p><strong>并发修改异常</strong></p>
<p>zszz，ArrayList只在单线程的时候会爆并发修改异常，而解决方法有以下几种：</p>
<ol>
<li>改用Vector（但还是会爆……）</li>
<li>使用工具类Collections静态方法 <code>synchronizedList(List&lt;T&gt; list)</code> 将集合变为同步集合</li>
<li>使用java.util.concurrent包下的CopyOnWriteArrayList（<span class="red">好处在于该类只在写入的时候加锁，读取的时候不加锁，提高效率</span>）</li>
</ol>
<br />

<p>Set同理，也会爆并发修改异常：</p>
<ol>
<li>使用工具类Collections静态方法 <code>synchronizedSet(Set&lt;T&gt; s)</code> 将集合变为同步集合</li>
<li>使用java.util.concurrent包下的CopyOnWriteArraySet</li>
</ol>
<p>Map同理：</p>
<ol>
<li>改用HashTable</li>
<li>使用工具类Collections静态方法 <code>synchronizedMap(Map&lt;K,V&gt; m)</code> 将集合变为同步集合</li>
<li>使用java.util.concurrent包下的<span class="red">ConcurrentHashMap</span></li>
</ol>
<h2 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h2><p>有返回值、可抛出异常、需要重写call()方法</p>
<hr>
<p><strong>启动Callable</strong></p>
<p><span class="red bold">问题：</span>Thread只能接收Runnable，如何启动Callable？</p>
<p><span class="red bold">解决：</span>使用适配器类FutureTask。</p>
<hr>
<p><strong>FutureTask</strong></p>
<p>FutureTask是Runnable的一个实现类，可以将Callable进行封装</p>
<p><span class="red bold">注意：</span></p>
<ol>
<li><p>被丢进FutureTask的线程<span class="red">只会执行一次</span>，再次执行时，Callable线程的状态已经改变</p>
<ul>
<li>线程状态：<br> FutureTask内定义了多个线程状态</li>
</ul>
<ol>
<li>当一个线程被丢进FutureTask构造方法时，状态被定义为NEW</li>
<li>在执行FutureTask的run()方法时，<span class="red">先检查线程状态，若线程状态不为NEW，则不会调用Callable的call()方法</span>，若为NEW，则会调用Callable的call()方法，call()方法执行完毕后，会接收call()方法的返回值并保留，此时线程状态被设置为COMPLETING</li>
<li>保留完返回值后，线程状态被设置为NORMAL</li>
</ol>
</li>
<li><p>使用FutureTask对象的方法 <code>get()</code>，以获取存储在FutureTask对象中的Call()方法返回值</p>
</li>
<li><p><code>get()</code> 方法会阻塞，当线程状态在NEW或COMPLETING时，get()方法会等待线程执行完毕</p>
</li>
</ol>
<h2 id="JUC三个常用辅助类——CountDownLatch"><a href="#JUC三个常用辅助类——CountDownLatch" class="headerlink" title="JUC三个常用辅助类——CountDownLatch"></a>JUC三个常用辅助类——CountDownLatch</h2><p>CountDownLatch是一个减法计数器，使用在 当某个事件需要发生在其他几个事件都完成后 的情况下</p>
<p><span class="red bold">构造方法：</span></p>
<p><code>CountDownLatch​(int count)</code>：给定一个计数器初值</p>
<p><span class="red bold">方法：</span></p>
<p><code>await()</code>：使当前线程在计数器归零前等待</p>
<p><code>await​(long timeout, TimeUnit unit)</code>：使当前线程在计数器归零前进行超时等待（timeout：时间数字；unit：时间单位），返回当前计数器是否已经归零</p>
<p><code>countDown()</code>：使计数器-1</p>
<p><code>getCount()</code>：返回当前计数器的值</p>
<p>下面的例子实现main线程的最后一句输出始终会在线程输出完之后执行</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public static void main(String[] args) throws InterruptedException &#123;
  CountDownLatch endSignal &#x3D; new CountDownLatch(3);

  for (int i &#x3D; 0; i &lt; 3; i++) &#123;
      new Thread(() -&gt; &#123;
          System.out.println(&quot;创建线程&quot;);
          endSignal.countDown();
      &#125;, String.valueOf(i)).start();
  &#125;

  endSignal.await();

  System.out.println(&quot;这将最后执行&quot;);
&#125;</code></pre>

<h2 id="JUC三个常用辅助类——CyclicBarrier"><a href="#JUC三个常用辅助类——CyclicBarrier" class="headerlink" title="JUC三个常用辅助类——CyclicBarrier"></a>JUC三个常用辅助类——CyclicBarrier</h2><p>CyclicBarrier是一个加法计数器，其计数依据不是数字，而是等待的线程数，当等待的线程数达到阈值时，他会唤醒所有等待线程</p>
<p>官方把它称作一个屏障，当有指定数量的线程到达屏障处等待时，屏障将消失，允许线程继续执行</p>
<p><span class="red bold">构造方法：</span></p>
<p><code>CyclicBarrier​(int parties)</code>：指定触发所需要的等待线程数</p>
<p><code>CyclicBarrier​(int parties, Runnable barrierAction)</code>：指定触发所需要的等待线程数，屏障触发后会执行barrierAction线程</p>
<p><span class="red bold">方法：</span></p>
<p><code>await()</code>：使当前线程在屏障消失前等待</p>
<p><code>await​(long timeout, TimeUnit unit)</code>：使当前线程在屏障消失前进行超时等待（timeout：时间数字；unit：时间单位）</p>
<p><code>getNumberWaiting()</code>：返回当前正在等待的线程数量</p>
<p><code>getParties()</code>：返回触发屏障消失所需的等待线程数</p>
<p><code>isBroken()</code>：此屏障是否已经触发</p>
<p><code>reset()</code>：重置屏障状态</p>
<p>下面的例子实现传入CyclicBarrier对象的线程会在下面五个线程都为等待状态时触发屏障而执行</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public static void main(String[] args) &#123;
  CyclicBarrier barrier &#x3D; new CyclicBarrier(5, () -&gt; System.out.println(&quot;屏障击破&quot;));


  for (int i &#x3D; 0; i &lt; 5; i++) &#123;
      new Thread(() -&gt; &#123;
          System.out.println(&quot;创建线程&quot;);
          try &#123;
              barrier.await();
          &#125; catch (InterruptedException e) &#123;
              e.printStackTrace();
          &#125; catch (BrokenBarrierException e) &#123;
              e.printStackTrace();
          &#125;
      &#125;).start();
  &#125;
&#125;</code></pre>

<h2 id="JUC三个常用辅助类——Semaphore"><a href="#JUC三个常用辅助类——Semaphore" class="headerlink" title="JUC三个常用辅助类——Semaphore"></a>JUC三个常用辅助类——Semaphore</h2><p>Semaphore类与上面两个计数器不同，Semaphore称为信号量，用于同一时间只能有指定数量的线程执行，执行完之后再把位置让给其他线程执行（像去茶餐厅吃饭找位置一样，同一个位置，别人吃完，你才能坐上去），通常用于限流</p>
<p><span class="red bold">构造方法：</span></p>
<p><code>Semaphore​(int permits)</code>：指定可被申请的位置数，默认非公平</p>
<p><code>Semaphore(int permits, boolean fair)</code>：指定可被申请的位置数，并指定是否公平</p>
<p><span class="red bold">方法：</span></p>
<p><code>acquire()</code>：使该线程从此信号量获得许可，或未获取到许可则阻塞</p>
<p><code>acquire​(int permits)</code>：使该线程从此信号量获得给定数量的许可，或未获取到许可则阻塞</p>
<p><code>release()</code>：使该线程释放获取到的许可</p>
<p><code>release​(int permits)</code>：使该线程释放给定数量的许可</p>
<p><code>tryAcquire()</code>：尝试申请许可，若申请不到则直接返回false</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public static void main(String[] args) &#123;
  Semaphore semaphore &#x3D; new Semaphore(3, true);

  for (int i &#x3D; 0; i &lt; 6; i++) &#123;
      final int temp &#x3D; i;
      new Thread(() -&gt; &#123;
          try &#123;
              semaphore.acquire();
              System.out.println(Thread.currentThread().getName() + &quot;请求到位置&quot;);
              Thread.sleep(temp * 1000);
              System.out.println(Thread.currentThread().getName() + &quot;释放位置&quot;);
              semaphore.release();
          &#125; catch (InterruptedException e) &#123;
              e.printStackTrace();
          &#125;
      &#125;).start();
  &#125;
&#125;</code></pre>

<h2 id="ReadWriteLock读写锁"><a href="#ReadWriteLock读写锁" class="headerlink" title="ReadWriteLock读写锁"></a>ReadWriteLock读写锁</h2><p>ReadWriteLock用于维护一对关联的锁，一个用于读取，一个用于写入，其中：</p>
<ul>
<li>读-读不互斥：读锁可被多个线程执行</li>
<li>写-写互斥：写锁不可以被多个线程执行</li>
</ul>
<p>规则：</p>
<ul>
<li>在非公平的情况下，允许读锁和写锁插队，但读锁能插队的条件是队列头结点不是想获取写锁的线程</li>
<li>读-写互斥：在任意线程获取到读锁时，不能有其他线程获取到写锁（防止读脏数据：指读到写过程中的中间状态），在任意线程获取到写锁时，不能再有线程获取到读锁</li>
</ul>
<p><span class="red bold">方法：</span></p>
<p><code>readLock()</code>：返回读锁</p>
<p><code>writeLock()</code>：返回写锁</p>
<p>获取到读写锁之后，使用方法与ReentrantLock一样</p>
<p><code>lock()</code>：加锁</p>
<p><code>unlock()</code>：解锁</p>
<p><span class="red bold">关于共享锁和独占锁：</span></p>
<ul>
<li><p>共享锁：共享锁就是读锁，可以有多个线程获取读锁</p>
</li>
<li><p>独占锁：独占锁就是写锁，写锁是排它锁</p>
</li>
</ul>
<h2 id="阻塞队列BlockingQueue"><a href="#阻塞队列BlockingQueue" class="headerlink" title="阻塞队列BlockingQueue"></a>阻塞队列BlockingQueue</h2><table>
<thead>
<tr>
<th align="center">阻塞队列的关系图</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="https://s1.ax1x.com/2022/04/30/OpFZhd.md.png" alt="OpFZhd.md.png"></td>
</tr>
</tbody></table>
<h2 id="阻塞队列的4组API"><a href="#阻塞队列的4组API" class="headerlink" title="阻塞队列的4组API"></a>阻塞队列的4组API</h2><table>
<thead>
<tr>
<th align="center">方式</th>
<th align="center">抛出异常</th>
<th align="center">不抛出异常，有返回值</th>
<th align="center">阻塞等待</th>
<th align="center">超时等待</th>
</tr>
</thead>
<tbody><tr>
<td align="center">增加</td>
<td align="center">add()</td>
<td align="center">offer()</td>
<td align="center">put()</td>
<td align="center">offer(E e, long timeout, TimeUnit unit)</td>
</tr>
<tr>
<td align="center">移除并返回</td>
<td align="center">remove()</td>
<td align="center">poll()</td>
<td align="center">take()</td>
<td align="center">poll(long timeout, TimeUnit unit)</td>
</tr>
<tr>
<td align="center">返回队首元素</td>
<td align="center">element()</td>
<td align="center">peek()</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
</tbody></table>
<ul>
<li>抛出异常列：当无法增加元素或取不到元素时会抛出运行时异常</li>
<li>不抛出异常列：当无法添加元素时或返回false，取不到元素是会返回null</li>
<li>阻塞等待列：当无法增加元素或取不到元素时会无限期等待</li>
<li>超时等待列：当无法增加元素或取不到元素时会进行超时等待，到达时间后未能执行的，跳过</li>
</ul>
<h2 id="同步队列SynchronousQueue"><a href="#同步队列SynchronousQueue" class="headerlink" title="同步队列SynchronousQueue"></a>同步队列SynchronousQueue</h2><p>同步队列是容量为1的阻塞队列，必须由多个线程来操作</p>
<p>使用 <code>put()</code> 方法将数据放入队列，使用 <code>take()</code> 方法将队列中的数据删除并返回</p>
<p><span class="red bold">注意：</span>若没有线程在等待删除数据，则 <code>put()</code> 会进行等待</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>线程池重点：3大方法、7大参数、4种拒绝策略</p>
<hr>
<p><strong>池化技术</strong></p>
<p>指将要重复开启关闭的资源事先准备好，有资源需要被使用则借出，使用完归还到池里</p>
<p><span class="red bold">好处：</span></p>
<ol>
<li>降低资源消耗</li>
<li>提高响应速度</li>
<li>方便管理（如：线程池可以使线程可复用、还可控制最大并发数、管理线程）</li>
</ol>
<hr>
<p><strong>三大方法</strong></p>
<p><span class="red bold">规范：</span>线程池的创建不允许使用Executors工具类，应当使用ThreadPoolExecutor</p>
<p><span class="red bold">三大方法：</span></p>
<p><code>newSingleThreadExecutor()</code>：创建一个可以存储一个线程的线程池</p>
<p><code>newFixedThreadPool(int nThreads)</code>：创建一个可以存储指定nThreads个线程的线程池</p>
<p><code>newCachedThreadPool()</code>：创建一个动态容量的线程池，该线程池会随需要的线程来决定开启的线程数</p>
<p><span class="red bold">注意：</span>线程池使用完要使用 <code>shutdown()</code> 关闭</p>
<hr>
<p><strong>初见ThreadPoolExecutor</strong></p>
<p>我们可以通过刚刚的三大方法的源码看到ThreadPoolExecutor，其实使用Executors来创建的线程池本质上就是使用ThreadPoolExexutor来创建</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public static ExecutorService newSingleThreadExecutor() &#123;
  return new FinalizableDelegatedExecutorService
      (new ThreadPoolExecutor(1, 1,
                              0L, TimeUnit.MILLISECONDS,
                              new LinkedBlockingQueue&lt;Runnable&gt;()));
&#125;

public static ExecutorService newFixedThreadPool(int nThreads) &#123;
  return new ThreadPoolExecutor(nThreads, nThreads,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue&lt;Runnable&gt;());
&#125;

public static ExecutorService newCachedThreadPool() &#123;
  return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                60L, TimeUnit.SECONDS,
                                new SynchronousQueue&lt;Runnable&gt;());
&#125;</code></pre>

<p>通过深入 <code>ThreadPoolExecutor()</code> 方法，我们可以得到：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public ThreadPoolExecutor(int corePoolSize,
                        int maximumPoolSize,
                        long keepAliveTime,
                        TimeUnit unit,
                        BlockingQueue&lt;Runnable&gt; workQueue,
                        ThreadFactory threadFactory,
                        RejectedExecutionHandler handler) &#123;
  if (corePoolSize &lt; 0 ||
      maximumPoolSize &lt;&#x3D; 0 ||
      maximumPoolSize &lt; corePoolSize ||
      keepAliveTime &lt; 0)
      throw new IllegalArgumentException();
  if (workQueue &#x3D;&#x3D; null || threadFactory &#x3D;&#x3D; null || handler &#x3D;&#x3D; null)
      throw new NullPointerException();
  this.corePoolSize &#x3D; corePoolSize;
  this.maximumPoolSize &#x3D; maximumPoolSize;
  this.workQueue &#x3D; workQueue;
  this.keepAliveTime &#x3D; unit.toNanos(keepAliveTime);
  this.threadFactory &#x3D; threadFactory;
  this.handler &#x3D; handler;
&#125;</code></pre>

<hr>
<p><strong>七大参数</strong></p>
<p>七大参数指的是通过ThreadPoolExxcutor创建线程池所传入的7个参数，他们分别是：</p>
<ul>
<li>corePoolSize：核心（默认）线程池大小</li>
<li>maximumPoolSize：最大线程池大小</li>
<li>keepAliveTime：超时释放时间（若超过这个时间无人调用则释放）</li>
<li>unit：超时单位</li>
<li>workQueue：阻塞队列</li>
<li>threadFactory：线程工厂（用于创建线程）</li>
<li>handler：拒绝策略</li>
</ul>
<table>
<thead>
<tr>
<th align="center">原生线程池通俗理解</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="https://s1.ax1x.com/2022/05/01/O9pvjK.md.png" alt="O9pvjK.md.png"></td>
</tr>
<tr>
<td align="center"><img src="https://s1.ax1x.com/2022/05/01/O998g0.md.png" alt="O998g0.md.png"></td>
</tr>
</tbody></table>
<ul>
<li>反观 <code>newCachedThreadPool()</code> 方法：我们可以知道：<ul>
<li>默认线程池大小为0</li>
<li>最大线程池大小为约21亿</li>
<li>闲置线程池超时释放时间为60秒</li>
<li>使用同步阻塞队列，只能容纳1个线程，队列中超过一个线程则启动线程池扩容</li>
<li>使用默认线程工厂（点进ThreadPoolExecutor方法可知）</li>
<li>使用默认拒绝策略（放弃过量的线程并抛出异常）（点进ThreadPoolExecutor方法可知）</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public static ExecutorService newCachedThreadPool() &#123;
  return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                60L, TimeUnit.SECONDS,
                                new SynchronousQueue&lt;Runnable&gt;());
&#125;</code></pre>

<blockquote>
<p>并且点开 <code>newSingleThreadExecutor()</code> 和 <code>newFixedThreadPool(int nThreads)</code> 方法我们可以知道为什么这两个线程池不会报错，因为其阻塞队列容量为Integer.MAX_VALUE，所以其阻塞队列不会满</p>
</blockquote>
<hr>
<p><strong>四大拒绝策略</strong></p>
<p><span class="red">当线程池的任务超出线程池队列可以存储的最大值之后，拒绝策略被触发</span></p>
<p>四大拒绝策略已经作为子类保存在ThreadPoolExecutor类中，他们分别是：</p>
<ol>
<li>AbortPolicy：拒绝新进任务并抛出异常</li>
<li>DiscardPolicy：忽略并抛弃新进任务</li>
<li>DiscardOldestPolicy：抛弃阻塞队列中位于头部的任务，并执行新进任务</li>
<li>CallerRunsPolicy：使用当前调用的线程执行新进任务（从哪里来回哪去 ）</li>
</ol>
<hr>
<p><strong>使用ThreadPoolExecutor创建线程池</strong></p>
<p>现在你已经知道了7大参数是什么意思，来试试用更底层的方法创建一个线程池：</p>
<p><span class="red bold">要求：</span>2个常开柜台，3个选开柜台，阻塞队列容量为3，拒绝策略为抛出异常</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">ThreadPoolExecutor threadPool &#x3D; new ThreadPoolExecutor(2, 5,
       3, TimeUnit.SECONDS,
       new ArrayBlockingQueue&lt;&gt;(3),
       Executors.defaultThreadFactory(),
       new ThreadPoolExecutor.DiscardOldestPolicy());</code></pre>

<hr>
<p><strong>最大线程该如何定义</strong></p>
<p><span class="red bold">设置依据——CPU密集型</span></p>
<p>CPU密集型：CPU有n个逻辑处理器（线程），则最多同时执行n条线程，<span class="red">多少线程的CPU就定义线程池最大容量为多少</span>，使效率最大化</p>
<ul>
<li><p>关于n核m线程（逻辑处理器）：如6核12线程（12个逻辑处理器），指的是有六个物理核心，每个核心进行双线程运算，则可以被理解为12个单线程核心</p>
<p>  代码获取CPU总线程数：</p>
  <pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">Runtime.getRuntime().availableProcessors()</code></pre></li>
</ul>
<p><span class="red bold">设置依据——IO密集型</span></p>
<p>IO密集型：指该项目中有n个十分消耗IO资源的线程，<span class="red">将线程池的最大容量设置为大于n即可，通常为2n</span></p>
<h2 id="四大函数式接口"><a href="#四大函数式接口" class="headerlink" title="四大函数式接口"></a>四大函数式接口</h2><p><span class="red bold">函数式接口：</span>指只有一个抽象方法的接口</p>
<p>四大函数式接口位于java.util.function包中</p>
<hr>
<p><strong>Function接口（函数）</strong><br><span class="red bold">（任意类型输入-&gt;任意类型输出）</span></p>
<p>Function接口是一种函数处理，在写该接口的实现类时要指定<span class="red">输入和输出</span>的数据类型</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">Function&lt;String, String&gt; function &#x3D; new Function&lt;String, String&gt;() &#123;
    @Override
    public String apply(String s) &#123;
        return s;
    &#125;
&#125;;

Function&lt;String, String&gt; function &#x3D; s -&gt; s;</code></pre>

<hr>
<p><strong>Predicate接口（断言）</strong><br><span class="red bold">（任意类型输入-&gt;布尔类型输出）</span></p>
<p>Predicate是一种判断，在写该接口的实现类的时候需要指定<span class="red">输入</span>的数据类型</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">Predicate&lt;String&gt; predicate &#x3D; new Predicate&lt;String&gt;() &#123;
    @Override
    public boolean test(String s) &#123;
        return null &#x3D;&#x3D; s ? false : s.isEmpty();
    &#125;
&#125;;</code></pre>

<hr>
<p><strong>Supplier接口</strong><br><span class="red bold">（无输入-&gt;任意类型输出）</span></p>
<p>Supplier是一种供给者，没有输入，只有输出</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">Supplier&lt;String&gt; supplier &#x3D; new Supplier&lt;String&gt;() &#123;
    @Override
    public String get() &#123;
        return null;
    &#125;
&#125;;</code></pre>

<hr>
<p><strong>Consumer接口</strong><br><span class="red bold">（任意类型输入-&gt;无输出）</span></p>
<p>Consumer是一种消费者，只有输入，没有输出</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">Consumer&lt;String&gt; consumer &#x3D; new Consumer&lt;&gt;() &#123;
    @Override
    public void accept(String o) &#123;
        System.out.println(o);
    &#125;
&#125;;</code></pre>

<h2 id="stream流式计算-x2F-链式编程"><a href="#stream流式计算-x2F-链式编程" class="headerlink" title="stream流式计算&#x2F;链式编程"></a>stream流式计算&#x2F;链式编程</h2><p>上面函数式接口简不简单？其实函数式接口是为stream服务哒</p>
<p>stream位于java.util.stream包下</p>
<p><span class="red bold">获取流：</span></p>
<p>stream是一个接口，无法被new出，我们可以通过以下方法获取流：</p>
<ol>
<li>collection对象的方法 <code>stream()</code> 获取集合的流</li>
<li>Arrays工具类静态方法 <code>stream()</code> 获取数组的流</li>
<li>通过BufferedReader对象的方法 <code>lines()</code> 获取BufferedReader读取的行的流</li>
<li>Files工具类中静态方法 <code>list​(Path dir)</code> 获取目录中的条目的流</li>
<li>使用Stream类静态方法 <code>of(T t)</code> 获取传入元素组成的流</li>
<li>……</li>
</ol>
<p><span class="red bold">流方法（判断）：</span></p>
<p><code>allMatch​(Predicate predicate)</code>：传入一个断言接口实现类，返回此流中的每一个元素是否都满足此断言</p>
<p><code>anyMatch​(Predicate predicate)</code>：传入一个断言接口实现类，返回此流中的任何一个元素是否满足此断言</p>
<p><code>noneMatch​(Predicate predicate)</code>：传入一个断言接口实现类，返回此流中是否没有元素满足此断言</p>
<p><span class="red bold">流方法（统计）：</span></p>
<p><code>count()</code>：返回此流中元素的数量</p>
<p><span class="red bold">流方法（功能性）：</span></p>
<p><code>filter​(Predicate predicate)</code>：流元素过滤器，传入一个断言接口实现类，返回所有满足此断言的元素组成的流</p>
<p><code>forEach​(Consumer action)</code>：无返回流元素消费器，传入一个消费型接口的实现类，对此流所有元素进行消费操作，<span class="red">并且会中断链式操作（指不能继续点下去）</span>，通常用于最后</p>
<p><code>limit​(long maxSize)</code>：对流进行截断，使流长度不超过限定值</p>
<p><code>map(Function mapper)</code>：流元素处理器，传入一个函数接口实现类，返回该流所有元素经过该函数处理后的元素组成的流</p>
<p><code>max​(Comparator comparator)</code>：流元素取最大，传入一个比较器，返回该流中最大的元素</p>
<p><code>min​(Comparator comparator)</code>：流元素取最小，传入一个比较器，返回该流中最小的元素</p>
<p><code>peek​(Consumer action)</code>：有返回流元素消费器，传入一个消费型接口的实现类，对此流所有元素进行消费操作，<span class="red">不会中断链式操作（指可以继续点下去）</span>，通常用于中间输出（peek：偷看（运行过程））或中间处理</p>
<p><code>skip​(long n)</code>：删除调用该方法的流的前n个元素，返回删除后的流</p>
<p><code>sorted()</code>：流元素排序器，对流元素进行自然排序</p>
<p><code>sorted​(Comparator comparator)</code>：流元素排序器，传入一个比较器，对流中的元素进行排序，返回排序后的流</p>
<ul>
<li><p>我们不仅可以重写Comparator中的compare方法，Comparator还提供一些默认方法供使用<br>  <code>reverseOrder()</code>：返回一个自然逆序排序器</p>
<p>  <code>comparing(Function keyExtractor)</code>：传入一个类的排序键，返回一个以该键值为依据的自然比较器（如：根据年龄的值排序，则传入 (类的对象名) -&gt; 类的对象名.getAge() 或 类名::getAge）</p>
<p>  <code>comparing(Function keyExtractor, Comparator keyComparator)</code>：传入一个类的排序键，并且传入一个自定义排序器，返回一个以该键值为依据的自定义比较器</p>
<p>  <code>reversed()</code>：返回调用该方法的比较器的逆序比较器</p>
<p>  <code>thenComparing​(Function keyExtractor)</code>：用于多字段排序，当前一个Comparing比较相同时，使用自然比较器比较该键值</p>
<p>  <code>thenComparing(Function keyExtractor, Comparator keyComparator)</code>：用于多字段排序，当前一个Comparing比较相同时，使用传入的自定义比较器比较该键值</p>
</li>
</ul>
<p><code>dropWhile​(Predicate predicate)</code>：传入一个断言接口实现类，从头开始丢弃掉流中的元素，直到流中的元素不满足该断言</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">Stream&lt;Character&gt; stream &#x3D; Stream.of(&#39;A&#39;, &#39;B&#39;, &#39;c&#39;, &#39;D&#39;, &#39;E&#39;);

stream.dropWhile(Character::isUpperCase).forEach(System.out::print);

&#x2F;*输出：
* cDE
*&#x2F;</code></pre>

<p><code>takeWhile​(Predicate predicate)</code>：传入一个断言接口实现类，从头开始提取流中的元素，直到流中的元素不满足该断言</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">Stream&lt;Character&gt; stream &#x3D; Stream.of(&#39;A&#39;, &#39;B&#39;, &#39;c&#39;, &#39;D&#39;, &#39;E&#39;);

stream.takeWhile(Character::isUpperCase).forEach(System.out::print);

&#x2F;*输出：
* AB
*&#x2F;</code></pre>

<h2 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h2><p>ForkJoinhiJDK1.7之后新增的功能</p>
<p>体现的是一种分治思想，将一个大任务拆分成若干小任务交给多条线程执行，每条线程会处理多个任务，任务会放在队列里</p>
<p><img src="https://s1.ax1x.com/2022/05/02/Oi1YB8.md.png" alt="Oi1YB8.md.png"></p>
<hr>
<p><strong>ForkJoin特点——工作窃取算法</strong></p>
<p>（麻了线程会内卷了）工作窃取指有的线程先把自己队列里的任务做完，与其让该线程干等，不如帮其他线程干活，这个线程就会去其他线程的任务队列里窃取一个任务来执行</p>
<p>而此时他们访问同一个队列，为了减少窃取任务的线程和被窃任务线程之间对任务的竞争，维护任务队列通常使用<span class="red">双端队列</span>，使正常执行的线程从队列头拿任务，窃取线程从队列尾拿任务</p>
<p><img src="https://s1.ax1x.com/2022/05/02/Oi1O4H.md.png" alt="Oi1O4H.md.png"></p>
<hr>
<p><strong>拆分合并任务（ForkJoinTask）</strong></p>
<p>ForkJoinTask抽象类位于java.util.concurrent包下</p>
<table>
<thead>
<tr>
<th align="center">ForkJoinTask类关系结构</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="https://s1.ax1x.com/2022/05/02/OiHRC6.png" alt="OiHRC6.png"></td>
</tr>
</tbody></table>
<ul>
<li>CountedCompleter：完成任务后将触发其他任务</li>
<li>RecursiveAction：递归事件，无返回值</li>
<li>RecursiveTask：递归任务，有返回值</li>
</ul>
<hr>
<p><strong>如何写一个拆分合并任务&#x2F;事件</strong></p>
<p>要写一个递归任务</p>
<ol>
<li>需要自创一个任务类，并且继承RecursiveTask类</li>
<li>需要有计算方法，重写 <code>compute()</code> 方法</li>
<li>需要有触发阈值，自行设定数据量达到多少时触发并行计算，没有达到阈值则使用普通方法计算</li>
</ol>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class Sum extends RecursiveTask&lt;Long&gt; &#123;
    public Sum(long start, long end) &#123;
        this.start &#x3D; start;
        this.end &#x3D; end;
    &#125;

    private static final long serialVersionUID &#x3D; 8786209935182254101L;

    &#x2F;&#x2F; 设定临界点，数据量不超过一万则使用普通方法，超过一万则使用并行计算
    private static final long threshold &#x3D; 1_0000;
    private long start;
    private long end;

    @Override
    protected Long compute() &#123;
        long sum &#x3D; 0;

        &#x2F;&#x2F; 临界点判断
        if (end - start &lt; threshold) &#123;
            &#x2F;&#x2F; 计算方法
        &#125; else &#123;
            &#x2F;&#x2F; 使用并行计算
            long middle &#x3D; (start + end) &#x2F; 2;

            Sum leftSum &#x3D; new Sum(start, middle);
            Sum rightSum &#x3D; new Sum(middle + 1, end);

            &#x2F;&#x2F; 执行子任务
            leftSum.fork();
            rightSum.fork();

            &#x2F;&#x2F; 接收任务结果
            Long leftResult &#x3D; leftSum.join();
            Long rightResult &#x3D; rightSum.join();

            &#x2F;&#x2F; 合并任务结果
            sum &#x3D; leftResult + rightResult;
        &#125;

        return sum;
    &#125;
&#125;</code></pre>

<hr>
<p><strong>执行一个递归任务</strong></p>
<p>使用 <code>ForkJoinPool()</code> 来提交任务，使用 <code>submit()</code> 提交任务，使用 <code>get()</code> 获取任务结果</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">ForkJoinPool forkJoinPool &#x3D; new ForkJoinPool();
ForkJoinTask&lt;Long&gt; submit &#x3D; forkJoinPool.submit(new Sum(1, 20000));
Long result &#x3D; submit.get();</code></pre>

<h2 id="Stream并行流计算"><a href="#Stream并行流计算" class="headerlink" title="Stream并行流计算"></a>Stream并行流计算</h2><p>计算交给流，流也可以并行，在java.util.stream包下，不仅有普通的Stream流，还有针对int、long、Double的流包装类 <code>IntStream</code>、<code>LongStream</code>、<code>DoubleStream</code></p>
<hr>
<p><strong>通过流包装类创建流</strong></p>
<p><span class="red">静态方法</span></p>
<p><code>range(long startInclusive, final long endExclusive)</code>：创建一个包含[startInclusive, endExclusive)<span class="red">（注意包含关系）</span>数的流</p>
<p><code>rangeClosed(long startInclusive, final long endInclusive)</code>：创建一个包含[startInclusive, endExclusive]<span class="red">（注意包含关系）</span>数的流</p>
<hr>
<p><strong>流串行化方法</strong></p>
<p><code>parallel()</code>：使用一个流对象调用该方法，修改流为并行状态并且返回流自身，<span class="red">注意该方法线程不安全</span></p>
<hr>
<p><strong>流计算方法</strong></p>
<p><code>reduce(long identity, LongBinaryOperator op)</code>：identity用于指定初值，传入一个BinaryOperator接口实现类，指定流中任意两数的处理方法，如：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">long reduce &#x3D; LongStream.rangeClosed(1, 100).reduce(0, Long::sum);</code></pre>

<h2 id="异步回调（Future）"><a href="#异步回调（Future）" class="headerlink" title="异步回调（Future）"></a>异步回调（Future）</h2><p>Future类：对将来的某个的某个事件的结果进行建模</p>
<p>CompletableFuture：Future的实现类</p>
<p><span class="red bold">异步：</span>指老板给你一个限时任务，规定要在某时间前完成，<span class="red">老板给完任务就去做其他事</span>，到了时间就找你要任务结果（当然如果你还没有完成，老板就要等了）</p>
<p><img src="https://s1.ax1x.com/2022/05/07/OQ204H.png" alt="OQ204H.png"></p>
<p><a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1662572461846283036&wfr=spider&for=pc">JAVA中使用CompletableFuture进行异步编程</a></p>
<hr>
<p><strong>提交异步任务</strong></p>
<p>CompletableFuture类提供了四个静态方法创建和提交异步任务</p>
<p><span class="red">注意：</span>异步任务中若发生异常，任务不会马上抛出异常，而是在被请求结果的时候将异常传回或抛出</p>
<br />

<p>&#x3D;&#x3D;&#x3D;</p>
<br />

<p><span class="red bold">1. 提交无返回值任务</span> </p>
<p><code>runAsync(Runnable runnable)</code>：使用默认的ForkJoinPool线程池<span class="red">自动异步执行（传入就执行）</span>传入的Runnable实现类<code>run()</code>方法</p>
<ul>
<li>ForkJoinPool线程池默认创建的线程数量是CPU核数</li>
</ul>
<p><code>runAsync(Runnable runnable, Executor executor)</code>：可以传入一个自定义参数的线程池<span class="red">（记得关线程池）</span></p>
<br />

<p>&#x3D;&#x3D;&#x3D;</p>
<br />

<p><span class="red bold">2. 提交有返回值任务</span></p>
<p><code>supplyAsync(Supplier&lt;U&gt; supplier)</code>：使用默认的ForkJoinPool线程池<span class="red">自动异步执行（传入就执行）</span>传入的供给型接口实现类 <code>get()</code> 方法</p>
<p><code>supplyAsync(Supplier&lt;U&gt; supplier, Executor executor)</code>：可以传入一个自定义参数的线程池<span class="red">（记得关线程池）</span></p>
<hr>
<p><strong>获取执行结果</strong></p>
<p><code>get()</code>：获取异步方法的执行结果（若异步方法未完成，则阻塞至完成为止），若异步方法抛出异常，则 <code>get()</code> 本身也会抛一个异常</p>
<ul>
<li><span class="red">注意：</span><code>get()</code> 方法强制程序员处理异常，它对异步方法抛出异常持悲观态度</li>
</ul>
<p><code>join()</code>：获取异步方法的执行结果（若异步方法未完成，则阻塞至完成为止），若异步方法抛出异常，则 <code>join()</code> 本身也会抛一个异常</p>
<ul>
<li><span class="red">注意：</span><code>join()</code> 方法无需程序员处理异常（不需要主动try-catch或抛出），它对异步方法抛出异常持乐观态度</li>
</ul>
<hr>
<p><strong>最终执行结果处理方法</strong></p>
<p>从这类开始都是成员方法</p>
<p>在写回调方法时，<span class="red">通常使用链式编程，可以保证在任务完成时及时回调</span>，而不是等主线程中途主动去询问</p>
<br />

<p>&#x3D;&#x3D;&#x3D;</p>
<br />

<p><span class="red bold">计算完成时回调方法（无返回值）</span></p>
<p><code>whenComplete(BiConsumer action)</code>：结果+异常消费器，传入一个强化版消费者接口实现类，任务正常执行的返回值作为第一个参数传入（若无：null），任务抛出的异常作为第二个参数传入（若无：null），<span class="red">执行任务的线程继续执行whenComplete中传入的强化版消费者任务</span></p>
<ul>
<li>BiConsumer：强化版消费者，可以消费两个变量，有两个泛型，分别是传入两个变量的类型</li>
</ul>
<p><code>whenCompleteAsync(BiConsumer action)</code>：结果+异常消费器，与上面的不同点在于，<span class="red">whenCompleteAsync中传入的强化版消费者任务交给默认线程池（ForkJoinPool）分配</span>，可能是执行任务的线程继续执行whenCompleteAsync，也可能不是</p>
<ul>
<li>ForkJoinPool线程池默认创建的线程数量是CPU核数</li>
</ul>
<p><code>whenCompleteAsync(BiConsumer action, Executor executor)</code>：结果+异常消费器，可以传入一个自定义参数的线程池<span class="red">（记得关线程池）</span></p>
<p><span class="red">方法不以Async结尾，意味着Action使用相同的线程执行，而Async可能会使用其他线程执行（如果是使用相同的线程池，也可能会被同一个线程选中执行）</span></p>
<br />

<p>&#x3D;&#x3D;&#x3D;</p>
<br />

<p><span class="red bold">计算完成时回调方法（有返回值）</span></p>
<p><code>handle(BiFunction fn)</code>：结果+异常处理器，传入一个强化版函数式接口，它可以处理两个参数，并且有一个返回值，可以作为任务的结果被 <code>获取执行结果方法</code> 获取，也可以进行进一步操作，<span class="red">执行任务的线程继续执行handle中传入的强化版消费者任务</span></p>
<ul>
<li>BiFunction：强化版函数型接口，可以处理两个变量，有三个泛型，分别是两个参数和一个返回值的类型</li>
</ul>
<p><code>handleAsync(BiFunction fn)</code>：与上面的不同点在于，<span class="red">whenCompleteAsync中传入的强化版函数任务交给默认线程池（ForkJoinPool）分配</span>，可能是执行任务的线程继续执行handleAsync，也可能不是</p>
<ul>
<li>ForkJoinPool线程池默认创建的线程数量是CPU核数</li>
</ul>
<p><code>handleAsync(BiFunction fn, Executor executor)</code>：可以传入一个自定义参数的线程池</p>
<br />

<p>&#x3D;&#x3D;&#x3D;</p>
<br />

<p><span class="red bold">计算完成时异常回调方法</span></p>
<p><code>exceptionally(Function fn)</code>：异常处理器，传入一个函数式接口，任务产生的异常将在这里作为参数传入函数式接口实现类的 <code>apply(T t)</code> 方法中，<span class="red">注意：规定该处理器的返回值必须和调用该处理器的方法的返回值相同类型，若调用该方法的是消费者接口处理器（无返回值），则与调用消费者接口处理器的方法的返回值相同</span></p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class CompletableFuture&lt;T&gt; &#123;
    &#x2F;&#x2F; 为避免混淆，这里返回值全部改成void

    &#x2F;&#x2F; handle不要求handle处理器的返回值与调用者返回值相同
    &#x2F;&#x2F; 该泛型方法另起一个未定义泛型U
    &#x2F;&#x2F; 既然U未定义，则&lt;? extends U&gt;也未定义
    public &lt;U&gt; void handle(
        BiFunction&lt;? super T, Throwable, ? extends U&gt; fn) &#123;
    &#125;

    &#x2F;&#x2F; exceptionally不是泛型方法，其参数指定为&lt;? extends T&gt;
    &#x2F;&#x2F; 而泛型T已经在类里面指定，也就是说在创建该类的对象时就已经指定了T的类型
    public void exceptionally(
        Function&lt;Throwable, ? extends T&gt; fn) &#123;
    &#125;

    &#x2F;&#x2F; 若不知道此时T的类型，不妨在此处先.var创建一个对象
    &#x2F;&#x2F; 即可通过看接收对象的类型的泛型来决定T
    CompletableFuture&lt;Integer&gt; supplyAsync &#x3D; CompletableFuture.supplyAsync(() -&gt; 1024)
    .whenCompleteAsync((t, u) -&gt; &#123;
        System.out.println(&quot;whenComplete-&gt;&quot; + Thread.currentThread().getName());
        &#x2F;&#x2F; 输出正常结果t
        System.out.println(t);
        &#x2F;&#x2F; 输出异常信息u
        System.out.println(u);
    &#125;);
&#125;</code></pre>

<br />

<p>&#x3D;&#x3D;&#x3D;</p>
<br />

<hr>
<p><strong>单任务依赖线程串行化方法</strong></p>
<p><span class="red bold">“然后处理”（结果 -&gt; f() -&gt; 新结果）</span></p>
<p><code>thenApply(Function fn)</code>：“然后处理”方法，当一个任务依赖另一个任务时使用，传入一个函数式接口，其参数是上一个任务的返回值，并且当前任务的返回值会作为CompletableFuture新的维护对象</p>
<p><code>thenApplyAsync(Function fn)</code>：“然后处理”的异步版本方法，与上面的不同点在于会将此函数式接口交给默认线程池（ForkJoinPool）来分配</p>
<p><code>thenApplyAsync(Function fn, Executor executor)</code>：“然后处理”的异步指定线程池版本方法</p>
<br />

<p>&#x3D;&#x3D;&#x3D;</p>
<br />

<p><span class="red bold">“然后消费”（结果 -&gt; f()）</span></p>
<p><code>thenAccept(Consumer action)</code>：“然后消费”方法，当一个任务依赖另一个任务时使用，传入一个消费型接口，其参数是上一个任务的返回值，由于消费者不会产生返回值，所以当前CompletableFuture的维护对象不变</p>
<p><code>thenAcceptAsync(Consumer action)</code>：“然后消费”方法的异步版本方法，与上面的不同点在于会将此函数式接口交给默认线程池（ForkJoinPool）来分配</p>
<p><code>thenAcceptAsync(Consumer action, Executor executor)</code>：“然后消费”方法的异步指定线程池版本方法</p>
<br />

<p>&#x3D;&#x3D;&#x3D;</p>
<br />

<p><span class="red bold">“然后执行”（没有参数间的依赖关系）</span></p>
<p><code>thenRun(Runnable action)</code>：“然后执行”方法，当一个任务<span class="red">只在执行过程上</span>依赖另一个任务时使用，传入一个Runnable接口，没有参数接收，也没有返回值，当前CompletableFuture的维护对象不变</p>
<p><code>thenRunAsync(Runnable action)</code>：“然后执行”方法的异步版本方法，与上面的不同点在于会将此函数式接口交给默认线程池（ForkJoinPool）来分配</p>
<p><code>thenRunAsync(Runnable action, Executor executor)</code>：“然后执行”方法的异步指定线程池版本方法</p>
<br />

<p>&#x3D;&#x3D;&#x3D;</p>
<br />

<p><span class="red bold">“然后交由另一任务处理”（结果 -&gt; 任务（f()） -&gt; 任务）</span></p>
<p><code>thenCompose(Function&lt;? super T, ? extends CompletionStage&lt;U&gt;&gt; fn)</code>：“然后交由另一任务处理”方法，当一个任务依赖另一个任务时使用，传入一个函数式接口，其参数是上一个任务的返回值，需要注意的是它会返回一个CompletionStage对象，<span class="red">通常用于连接两个任务</span>。该方法与 <code>thenApply</code> 非常像，下面会细说他们的一点区别，并且不妨看看下面的例子</p>
<ul>
<li><p>与<code>thenApply()</code>的区别：（<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903812520509447#heading-11">thenApply()和thenCompose()之间的区别</a>）</p>
<ol>
<li><code>thenApply()</code>用于转换前一个任务的结果，而其返回值会修改CompletableFuture对象的泛型，并不会改变CompletableFuture对象（在调用thenApply方法前后是同一个对象）</li>
<li><code>thenCompose()</code>用于<span class="red">使用一个预设的任务来处理上一个任务的结果</span>，并且返回一个新的CompletableFuture对象，会改变CompletableFuture对象</li>
</ol>
</li>
<li><p><code>thenCompose()</code>使用方法：</p>
</li>
</ul>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Test &#123;
    public void startTask() &#123;
        CompletableFuture.supplyAsync(() -&gt; &#123;
            return 100;
        &#125;).thenCompose((result) -&gt; this.otherFuture(result));
        &#x2F;&#x2F; 或 this::otherFuture
    &#125;

    &#x2F;&#x2F; 预设带参任务
    private CompletableFuture&lt;Integer&gt; otherFuture(Integer i) &#123;
        return CompletableFuture.supplyAsync(() -&gt; i + 1);
    &#125;
&#125;</code></pre>

<p><code>thenComposeAsync(Function&lt;? super T, ? extends CompletionStage&lt;U&gt;&gt; fn)</code>：“然后交由另一任务处理”方法的异步版本方法，与上面的不同点在于会将此函数式接口交给默认线程池分配</p>
<p><code>thenComposeAsync(Function&lt;? super T, ? extends CompletionStage&lt;U&gt;&gt; fn, Executor executor)</code>：“然后交由另一任务处理”方法的异步指定线程池版本方法</p>
<hr>
<p><strong>双任务依赖线程串行化方法——AND联合结果</strong></p>
<p><span class="red bold">“联合结果处理”（结果① AND 结果② -&gt; f() -&gt; 新结果）</span></p>
<p><code>thenCombine(CompletionStage other, BiFunction fn)</code>：“联合结果处理”方法，当一个任务依赖另外两个任务时使用，传入另一个任务和一个增强型函数式接口，当调用的任务和other任务都执行完之后执行fn。函数式接口实现方法传入的参数分别为：</p>
<ol>
<li>调用任务返回值</li>
<li>other任务返回值</li>
</ol>
<p>fn的返回值作为CompletableFuture新的维护对象</p>
<p><code>thenCombineAsync(CompletionStage other, BiFunction fn)</code>：“联合结果处理”方法的异步版本方法，与上面的不同点在于会将此函数式接口交给默认线程池（ForkJoinPool）来分配</p>
<p><code>thenCombineAsync(CompletionStage other, BiFunction fn, Executor executor)</code>：“联合结果处理”方法的异步指定线程池版本方法</p>
<br />

<p>&#x3D;&#x3D;&#x3D;</p>
<br />

<p><span class="red bold">“联合结果消费”（结果① AND 结果② -&gt; f()）</span></p>
<p><code>thenAcceptBoth(CompletionStage other, BiConsumer action)</code>：“联合结果消费”方法，当一个任务依赖另外两个任务时使用，传入一个增强型消费型接口，当调用的任务和other任务都执行完之后执行action。消费型接口实现方法传入的参数分别为：</p>
<ol>
<li>调用任务返回值</li>
<li>other任务返回值</li>
</ol>
<p>由于action没有返回值，当前CompletableFuture的维护对象仍为调用该方法的任务的返回值</p>
<p><code>thenAcceptBothAsync(CompletionStage other, BiConsumer action)</code>：“联合结果消费”方法的异步版本方法，与上面的不同点在于会将此函数式接口交给默认线程池分配</p>
<p><code>thenAcceptBothAsync(CompletionStage other, BiConsumer action, Executor executor)</code>：“联合结果消费”方法的异步指定线程池版本方法</p>
<br />

<p>&#x3D;&#x3D;&#x3D;</p>
<br />

<p><span class="red bold">“都完成然后执行”（没有参数间的依赖关系）</span></p>
<p><code>runAfterBoth(CompletionStage other, Runnable action)</code>：“都完成然后执行”任务，当一个任务<span class="red">只在执行过程上</span>依赖另外两个任务时使用，传入一个Runnable接口，没有参数接收，也没有返回值。当前CompletableFuture的维护对象仍为调用该方法的任务的返回值</p>
<p><code>runAfterBothAsync(CompletionStage other, Runnable action)</code>：“都完成然后执行”任务的异步版本方法，与上面的不同点在于会将此函数式接口交给默认线程池分配</p>
<p><code>runAfterBothAsync(CompletionStage other, Runnable action, Executor executor)</code>：“都完成然后执行”方法的异步指定线程池版本方法</p>
<hr>
<p><strong>双任务依赖线程串行化方法——OR二者取一</strong></p>
<p><span class="red bold">“取一结果处理”（结果① OR 结果② -&gt; f() -&gt; 新结果）</span></p>
<p><code>applyToEither(CompletionStage other, Function fn)</code>：“取一结果处理”方法，当一个任务依赖另外两个任务的任意一个时使用，传入另一个任务和一个函数式接口，当调用的任务和other任务有一个执行完之后执行fn。函数式接口实现方法传入的参数为：</p>
<ul>
<li>先执行完的任务的返回值</li>
</ul>
<p>fn的返回值作为CompletableFuture新的维护对象</p>
<p><code>applyToEitherAsync(CompletionStage other, Function fn)</code>：“取一结果处理”方法的异步版本方法，与上面的不同点在于会将此函数式接口交给默认线程池分配</p>
<p><code>applyToEitherAsync(CompletionStage other, Function fn, Executor executor)</code>：“取一结果处理”方法的异步指定线程池版本方法</p>
<br />

<p>&#x3D;&#x3D;&#x3D;</p>
<br />

<p><span class="red bold">“取一结果消费”（结果① OR 结果② -&gt; f()）</span></p>
<p><code>acceptEither(CompletionStage other, Consumer action)</code>：“取一结果消费”方法，当一个任务依赖另外两个任务的任意一个时使用，传入一个消费型接口，当调用的任务和other任务有一个执行完之后执行action。消费型接口实现方法传入的参数为：</p>
<ul>
<li>先执行完的任务的返回值</li>
</ul>
<p>由于action没有返回值，当前CompletableFuture的维护对象仍为调用该方法的任务的返回值</p>
<p><code>acceptEitherAsync(CompletionStage other, Consumer action)</code>：“取一结果消费”方法的异步版本方法，与上面的不同点在于会将此函数式接口交给默认线程池分配</p>
<p><code>acceptEitherAsync(CompletionStage other, Consumer action, Executor executor)</code>：“取一结果消费”方法的异步指定线程池版本方法</p>
<br />

<p>&#x3D;&#x3D;&#x3D;</p>
<br />

<p><span class="red bold">“有完成然后执行”（没有参数间的依赖关系）</span></p>
<p><code>runAfterEither(CompletionStage other, Runnable action)</code>：“有完成然后执行”方法，当一个任务<span class="red">只在执行过程上</span>依赖另外两个任务的任意一个时使用，传入一个Runnable接口，没有参数接收，也没有返回值。当前CompletableFuture的维护对象仍为调用该方法的任务的返回值</p>
<p><code>runAfterEitherAsync(CompletionStage other, Runnable action)</code>：“有完成然后执行”方法的异步版本方法，与上面的不同点在于会将此函数式接口交给默认线程池分配</p>
<p><code>runAfterEitherAsync(CompletionStage&lt;?&gt; other, Runnable action, Executor executor)</code>：“有完成然后执行”方法的异步指定线程池版本方法</p>
<hr>
<p><strong>多任务依赖线程串行化方法</strong></p>
<p>这两个方法是静态的</p>
<p><code>allOf(CompletableFuture... cfs)</code>：等待所有任务完成，传入一个任务数组，通常该方法后面会跟一个单任务依赖无参串行化方法。如下：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">List&lt;CompletableFuture&lt;Void&gt;&gt; completableFutureList &#x3D; Arrays.asList(
                CompletableFuture.runAsync(() -&gt; System.out.println(&quot;Hi&quot;)),
                CompletableFuture.runAsync(() -&gt; System.out.println(&quot;Java&quot;)),
                CompletableFuture.runAsync(() -&gt; System.out.println(&quot;!&quot;))
        );

        &#x2F;&#x2F; 注意这里不能指定泛型，否则会报错
        &#x2F;&#x2F; 可以去掉&lt;?&gt;
        CompletableFuture&lt;?&gt;[] futures &#x3D; completableFutureList.toArray(new CompletableFuture&lt;?&gt;[]&#123;&#125;);


        CompletableFuture&lt;Void&gt; allComplete &#x3D; CompletableFuture.allOf(futures);
        allComplete.thenRun(() -&gt; &#123;
            &#x2F;&#x2F; do something
        &#125;);</code></pre>

<p><code>anyOf(CompletableFuture... cfs)</code>：等待其中一个任务完成，传入一个任务数组，通常该方法后面会跟一个单任务依赖无参串行化方法</p>
<h2 id="理解Volatile"><a href="#理解Volatile" class="headerlink" title="理解Volatile"></a>理解Volatile</h2><hr>
<p><strong>Java内存模型（JMM）</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zjcjava/article/details/78406330">JMM概述</a></p>
<p>JVM是Java虚拟机，JMM是Java内存模型</p>
<p><span class="red bold">什么是JMM：</span>Java Memory Model，指Java内存模型，内存模型指在特定的操作协议下，对的内存进行读写访问过程的抽象描述，是一种概念，实际上不存在</p>
<table>
<thead>
<tr>
<th align="center">Java内存模型</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="https://s1.ax1x.com/2022/05/03/OAAjQU.png" alt="OAAjQU.png"></td>
</tr>
</tbody></table>
<p><span class="red bold">JMM内存模型：</span></p>
<ol>
<li><span class="red">所有变量存储在主内存中（Main Memory）。每个线程拥有自己的工作内存</span></li>
<li>线程的工作内存中保存着该线程会用到的变量的<span class="red">主内存的副本拷贝</span>，因此不同线程之间无法直接访问对方工作内存中的变量，线程之间的值传递通过主内存来完成</li>
</ol>
<p><span class="red bold">JMM同步约定：</span></p>
<ol>
<li>线程加锁前，必须读取内存中的最新值到工作内存中</li>
<li>线程解锁前，必须把共享变量立刻刷新回主内存</li>
<li>加锁与解锁必须是同一把锁</li>
</ol>
<p><span class="red bold">Java内存交互操作：</span></p>
<p>对于如何将一个变量从主内存拷贝到工作内存，再从工作内存同步回主内存，Java内存交互定义了8种操作</p>
<table>
<thead>
<tr>
<th align="center">Java内存交互</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="https://s1.ax1x.com/2022/05/03/OAMKRs.md.png" alt="OAMKRs.md.png"></td>
</tr>
</tbody></table>
<ol>
<li>lock（锁定）：作用于主内存变量，把主内存中的一个变量标记为一条线程独占的状态</li>
<li>unlock（解锁）：作用于主内存变量，把一个处于独占状态的变量释放，使其可以被其他线程访问</li>
<li>read（读取）：作用于主内存变量（<strong>取</strong>），把主内存中一个变量传输到线程的工作内存中</li>
<li>load（载入）：作用于工作内存变量（<strong>取</strong>），把read操作得到的变量值放入到工作内存的变量副本中</li>
<li>use（使用）：作用于工作内存变量（<strong>取</strong>），把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行该操作</li>
<li>assign（赋值）：作用于工作内存变量（<strong>存</strong>），把一个从执行引擎返回的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时会执行该操作</li>
<li>store（存储）：作用于工作内存变量（<strong>存</strong>），把工作内存中一个变量的值传回到之内存中</li>
<li>write（写入）：作用于主内存变量（<strong>存</strong>），把store操作得到的变量值放入主内存变量中</li>
</ol>
<blockquote>
<p>除此之外，还规定以下规则：</p>
<ol>
<li><p>不允许read与load，store与write中只有一个操作出现</p>
</li>
<li><p>变量在工作内存中改变了之后必须把该变化同步回主内存</p>
</li>
<li><p>不允许一个线程无原因（没有进行assign）地把数据从工作内存同步到主内存中</p>
</li>
<li><p>一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化(load或assign)的变量</p>
</li>
<li><p>一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁</p>
</li>
<li><p>如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作以初始化变量的值</p>
</li>
<li><p>如果一个变量没有被执行lock操作，那么不允许对它执行unlock操作，也不允许unlock一个被其他线程lock过的变量</p>
</li>
<li><p>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中</p>
</li>
</ol>
</blockquote>
<hr>
<p><strong>理解Volatile</strong></p>
<p><span class="red bold">volatile特点：</span></p>
<ol>
<li>保证可见性</li>
<li><span class="red">不保证原子性</span></li>
<li>禁止指令重排</li>
</ol>
<hr>
<p><span class="red bold">①. volatile保证可见性</span></p>
<p>阅读以下程序，即可知道问题所在：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class Main &#123;
    private static int num &#x3D; 0;
    public static void main(String[] args) &#123;

        &#x2F;&#x2F; 开启线程并执行
        new Thread(() -&gt; &#123;
            while (num &#x3D;&#x3D; 0);
        &#125;).start();

        &#x2F;&#x2F; 等待子线程开启并开始执行
        try &#123;
            TimeUnit.SECONDS.sleep(1);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;

        num &#x3D; 1;
        System.out.println(num);
    &#125;
&#125;</code></pre>

<p>该指令的结果是main线程在修改完num的值之后，其子线程并不知道主内存中的num的值被修改，从而一直循环，程序不会停止</p>
<p><span class="red bold">问题：</span>线程不知道主内存中的值被修改</p>
<p><span class="red bold">什么是可见性：</span>指每个线程对其需要使用的变量在主内存中都是可见的（一个线程对共享变量做了修改之后，其他线程能够立刻看到变量的修改情况）</p>
<hr>
<p><span class="red bold">②. volatile不保证原子性</span></p>
<p><span class="red bold">什么是原子性：</span>原子性指不可再分，即线程在执行任务的之后不可被打断，线程执行的所有任务是一个整体，不可被分割，要么该线程的任务都成功要么都失败（类比事务）</p>
<p><span class="red bold">前菜：</span></p>
<ol>
<li>synchronized是保证原子性的</li>
<li>Lock也是保证原子性的（前提是要同一把锁）</li>
<li>什么是原子性操作：<span class="red">指在汇编层面不允许多个线程进行同时操作（指在汇编中就只有一个操作）</span>（Java中只有对基本类型变量的读取和写入才是原子性操作，其他都不是原子性操作）</li>
</ol>
<p><span class="red bold">验证：</span></p>
<p>若volatile是原子性操作，则涉及到对该变量操作的语句在同一时间都只有一条线程可以进入</p>
<p>对于下面的代码，结果应该是4000，而真的是这样吗？</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class Main &#123;
    private volatile static int num &#x3D; 0;

    public static void add() &#123;
        num++;
    &#125;

    public static void main(String[] args) &#123;
        for (int i &#x3D; 1; i &lt;&#x3D; 20; i++) &#123;
            new Thread(() -&gt; &#123;
                for (int j &#x3D; 0; j &lt; 200; j++) &#123;
                    add();
                &#125;
            &#125;).start();
        &#125;

        &#x2F;&#x2F; 保证主线程不会在子线程之前执行完(main gc)
        while (Thread.activeCount() &gt; 2) &#123;
            Thread.yield();
        &#125;

        System.out.println(num);
    &#125;
&#125;</code></pre>

<p>结果是随机的，但就不会是4000，同时IDEA会报一个警告 <code>Non-atomic operation on volatile field &#39;num&#39;</code> （对volatile字段num的非原子性操作）</p>
<p><span class="red bold">解析：</span><code>num++</code> 本身并不是原子性操作，它在汇编层面涉及三个操作：</p>
<ol>
<li>取num的值</li>
<li>将其+1</li>
<li>将结果赋回给num</li>
</ol>
<p>而上面的结果不为4000，说明不只有一个线程执行了num++，说明对num的操作不只有一个线程进行，说明volatile不保证原子性</p>
<hr>
<p><span class="red bold">③.  volatile禁止指令重排</span></p>
<p><span class="red bold">什么是指令重排：</span></p>
<p>实际上从Java源代码到最底层的指令序列，指令小概率会经历三次重排序：</p>
<p><img src="https://s1.ax1x.com/2022/05/04/OEuk2n.md.png" alt="OEuk2n.md.png"></p>
<p><span class="red bold">排序原则：</span></p>
<ul>
<li><p><strong>数据依赖性</strong></p>
<p>  针对单条线程，其指令之间若存在数据依赖性，则这些指令不会被重排列（这个和as-if-serial一起看，他们差不多）</p>
</li>
<li><p><strong>as-if-serial</strong></p>
<p>  指无论如何重排序，都要保证在单线程下，程序的执行结果不会改变，如：</p>
  <pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F; 数据依赖性
x &#x3D; 0;
y &#x3D; x;
x &#x3D; 1;

&#x2F;&#x2F; as-if-serial
y &#x3D; x;
x &#x3D; 1;

x &#x3D; 2;
x &#x3D; 3;</code></pre>

<ol>
<li>由于 <code>y = x</code> 对 <code>x=0</code> 存在依赖性，因此这两条指令不会被重排列</li>
<li>由于重排列 <code>y = x;x = 1;</code> 之后，单线程下y的结果会发生改变，因此这两条指令不会被重排列</li>
<li>由于重排列 <code>x = 2;x = 3;</code> 之后，单线程下x的结果会发生改变，因此这两条指令不会被重排列</li>
</ol>
</li>
</ul>
<p>现代处理器都会允许对写-读操作重排序，这在多线程下显得不安全，看以下例子：</p>
<p>初始化x &#x3D; 0，y &#x3D; 0</p>
<table>
<thead>
<tr>
<th align="center">线程A</th>
<th align="center">线程B</th>
</tr>
</thead>
<tbody><tr>
<td align="center">x &#x3D; 2</td>
<td align="center">y &#x3D; 1</td>
</tr>
<tr>
<td align="center">b &#x3D; y</td>
<td align="center">a &#x3D; x</td>
</tr>
</tbody></table>
<p>因为重排列只保证在单线程下执行结果正确，因此线程A和线程B的两个操作都互相不存在依赖性，允许重排列，因此可能出现以下执行情况：<br><img src="https://s1.ax1x.com/2022/05/04/OEMIbV.png" alt="OEMIbV.png"></p>
<p><span class="red bold">volatile如何防止指令重排：<span></p>
<p>通过在对声明了volatile的变量的操作指令前后增加内存屏障，保证屏障前的指令不会和屏障后的指令进行重排</p>
<h2 id="原子性包装类"><a href="#原子性包装类" class="headerlink" title="原子性包装类"></a>原子性包装类</h2><p>针对如何不使用Lock和Synchronized实现对一个变量的原子性操作，Java给出了原子性包装类</p>
<p>原子性包装类位于java.util.concurrent.atomic包下，包含对int、long、boolean的原子包装类，若想要一个自定对象的操作是原子性的，则可以使用原子引用 <code>AtomicReference&lt;V&gt;</code></p>
<table>
<thead>
<tr>
<th align="center">包装类</th>
<th align="center">原子包装类</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Integer</td>
<td align="center">AtomicInteger</td>
</tr>
<tr>
<td align="center">Boolean</td>
<td align="center">AtomicBoolean</td>
</tr>
<tr>
<td align="center">Long</td>
<td align="center">AtomicLong</td>
</tr>
<tr>
<td align="center">Object</td>
<td align="center">AtomicReference&lt;V&gt;</td>
</tr>
</tbody></table>
<hr>
<p><strong>一些笔记</strong></p>
<p>getAndIncrement和incrementAndGet的区别，两个的返回值不同：</p>
<ul>
<li>getAndIncrement会返回修改这个数<span class="red">之前</span>的值</li>
<li>incrementAndGet会返回修改这个数<span class="red">之后</span>的值</li>
</ul>
<hr>
<p><strong>原子性包装类底层（CAS）</strong></p>
<p>顺着任意一个原子包装类的代码我们可以找到Unsafe类，这是一个Java通过调用C++导致Java可以间接操作内存的类</p>
<p>就以 <code>incrementAndGet()</code> 方法为例，其效果是将一个原子的Integer加一：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F; 该方法用于获取一个非静态属性在对象中的偏移量
private static final long VALUE &#x3D; U.objectFieldOffset(AtomicInteger.class, &quot;value&quot;);
&#x2F;* 传入以下参数：
 * this: 调用该方法的对象
 * VALUE: AtomicInteger类在内存中的固定偏移量
 * 1: 增加值
 *&#x2F;
public final int incrementAndGet() &#123;
    return U.getAndAddInt(this, VALUE, 1) + 1;
&#125;</code></pre>

<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public final int getAndAddInt(Object o, long offset, int delta) &#123;
    int v;
    &#x2F;&#x2F; 自旋锁，若内存中的值已经不等于v的值，重复获取内存中的值
    do &#123;
        &#x2F;&#x2F; 定位并获取o对象内存中指定偏移量位置下存储的值
        v &#x3D; getIntVolatile(o, offset);
    &#125; while (!weakCompareAndSetInt(o, offset, v, v + delta));
    return v;
&#125;</code></pre>

<p><code>weakCompareAndSetInt(o, offset, v, v + delta)</code>：若内存中的值等于v的值，则将内存中的值改为v + delta，修改成功返回true，否则返回false</p>
<p><span class="red bold">CAS</span>：指compareAndSet（或compareAndSwap）对比并设置（或交换），<span class="red">比较当前线程工作内存（变量v属于局部变量，会被放入线程的工作内存中）中的变量与主内存中的变量（通过偏移量获取），若值没有被修改，则执行操作</span></p>
<p><span class="red bold">CAS优点：</span>通过自旋锁达到阻塞效果，无需切换线程状态（切换线程状态性能消耗大）</p>
<p><span class="red bold">CAS缺点：</span></p>
<ul>
<li>底层是自旋锁，循环耗时</li>
<li>一次只能保证一个共享变量的原子性</li>
<li>存在ABA问题</li>
</ul>
<hr>
<p><strong>ABA问题</strong></p>
<p><span class="red bold">ABA问题：</span></p>
<p>指一个线程的CAS操作中存在其他线程的多次CAS操作：<br>    <img src="https://s1.ax1x.com/2022/05/06/OnNa8A.md.png" alt="OnNa8A.md.png"></p>
<ol>
<li>线程AB几乎同时从主存中获取值</li>
<li>线程B进行了一次对比并交换操作（主存：10-&gt;12）</li>
<li>线程B进行了第二次对比并交换操作（主存：12-&gt;10）</li>
</ol>
<hr>
<p><strong>对于一个基本类型的原子包装类的ABA问题</strong></p>
<p><span class="red bold">注意：</span><span class="red">基本类型的原子包装类底层比较的是数值</span>，对于基本类型的ABA问题，通常结果不会发生变化</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class IntegerAtomic &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        AtomicInteger integer &#x3D; new AtomicInteger(200);

        new Thread(() -&gt; &#123;
            &#x2F;&#x2F; 子线程进行两次CAS操作
            System.out.println(integer.compareAndSet(200, 250));
            System.out.println(integer.compareAndSet(250, 200));
        &#125;).start();
        
        &#x2F;&#x2F; 等待子线程完成CAS
        TimeUnit.SECONDS.sleep(2);

        System.out.println(integer.compareAndSet(200, 100));
    &#125;
&#125;

&#x2F;* 输出：
 * true
 * true
 * true
 * 三次修改都成功，主存内数值为100
 *&#x2F;</code></pre>

<hr>
<p><strong>对于对象的原子包装类的ABA问题</strong></p>
<p><span class="red bold">注意：</span><span class="red">对象的原子包装类（原子引用）底层比较的是地址</span>，对于对象来说，由于修改对象内的值，对象本身的地址并不会改变，线程不知道数据已经被修改是很危险的</p>
<blockquote>
<p>另：因为原子引用比较的是地址，强烈不建议使用原子引用包装基本类型的包装类</p>
<p>原因：基本类型包装类有缓冲区，在某个范围内的数值使用预设好的缓冲区，相同数值相同地址（在该区间内可以使用&#x3D;&#x3D;比较）</p>
<p>但一旦超过这个范围就和数值没什么关系了，相同数值地址也不同（这种情况下必须使用equals比较）</p>
</blockquote>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class Main &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        User user &#x3D; new User(&quot;张三&quot;, 12);

        AtomicReference&lt;User&gt; userAtomic &#x3D; new AtomicReference&lt;&gt;(user);

        new Thread(() -&gt; &#123;
            User user1 &#x3D; new User(&quot;张三&quot;, 18);
            System.out.println(userAtomic.compareAndSet(user, user1));
            &#x2F;&#x2F; user.setAge(15);
            System.out.println(userAtomic.compareAndSet(user1, user));
        &#125;).start();

        &#x2F;&#x2F; 等待子线程执行两次CAS操作
        TimeUnit.SECONDS.sleep(2);

        System.out.println(userAtomic.compareAndSet(user, null));
        System.out.println(userAtomic.get());
    &#125;
&#125;

&#x2F;* 输出：
 * true
 * true
 * true
 * 主存内对象的值为null
 *&#x2F;</code></pre>

<hr>
<p><strong>到时间戳原子引用解决ABA问题</strong></p>
<p>AtomicStampedReference带时间戳的原子引用类，该类不仅维护了一个对象，还额外维护了一个int类型的标记</p>
<p><span class="red bold">特点：</span>该类在进行对象传入和对象CAS操作时，需要同时比对对象地址和标记值</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public static void main(String[] args) &#123;
    User u1 &#x3D; new User(&quot;张三&quot;, 20);
    User u2 &#x3D; new User(&quot;李四&quot;, 21);

    AtomicStampedReference&lt;User&gt; userAtomicStampedReference &#x3D; new AtomicStampedReference&lt;User&gt;(u1, 1);
    
    userAtomicStampedReference.compareAndSet(u1, u2,
            userAtomicStampedReference.getStamp(), userAtomicStampedReference.getStamp() + 1);
&#125;</code></pre>

<h2 id="单例模式——单例与反射之争"><a href="#单例模式——单例与反射之争" class="headerlink" title="单例模式——单例与反射之争"></a>单例模式——单例与反射之争</h2><hr>
<p><strong>饿汉式</strong></p>
<p>饿汉它很饿，一上来就迫不及待地把对象new出：</p>
<p><span class="red bold">好处：</span>线程安全（但不防反射）</p>
<p><span class="red bold">缺点：</span>饿汉式会在类发生初始化时就创建类的实例，当该类下有一些十分占用内存的变量时，饿汉式单例会造成长期占用资源</p>
<p><span class="red bold">通常用于：</span>一个类需要被很频繁地使用</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class Hungry &#123;
    private Hungry() &#123;

    &#125;

    private static final Hungry hungry &#x3D; new Hungry();

    public static Hungry getInstance() &#123;
        return hungry;
    &#125;
&#125;</code></pre>

<hr>
<p><strong>普通懒汉式</strong></p>
<p><span class="red bold">优点：</span>在需要的时候才创建对象</p>
<p><span class="red bold">缺点：</span>线程不安全</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class Lazy &#123;
    private Lazy() &#123;

    &#125;

    private static Lazy lazy;

    public static Lazy getInstance() &#123;
        if (null &#x3D;&#x3D; lazy) &#123;
            lazy &#x3D; new Lazy();
        &#125;
        return lazy;
    &#125;
&#125;</code></pre>

<hr>
<p><strong>DCL（Double-Check Locking）懒汉式</strong></p>
<p>DCL懒汉式是普通懒汉式的线程安全版本</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class Lazy &#123;
    private Lazy() &#123;

    &#125;

    private static Lazy lazy &#x3D; null;

    public static Lazy getInstance() &#123;
        if (null &#x3D;&#x3D; lazy) &#123;
            &#x2F;&#x2F; 加锁
            synchronized (Lazy.class) &#123;
                if (null &#x3D;&#x3D; lazy) &#123;
                    lazy &#x3D; new Lazy();
                &#125;
            &#125;
        &#125;
        return lazy;
    &#125;
&#125;</code></pre>

<p><span class="red bold">双重检查的意义：</span></p>
<ol>
<li><p>第一个if用于判断是否有必要获取锁，在创建实例之后，若再调用该方法，可以不获取锁直接返回，节省时间</p>
</li>
<li><p>第二个if用于在获取锁之后再做一次判断，旨在有多个线程通过第一道if之后也不会创建多个实例</p>
<p> <img src="https://s1.ax1x.com/2022/05/05/OeZPqf.png" alt="OeZPqf.png"></p>
</li>
</ol>
<p><span class="red bold">新问题：</span></p>
<p>实际上，<code>lazy = new Lazy();</code> 的底层并不是原子性操作，而是分了三步：</p>
<ol>
<li>开辟内存空间</li>
<li>执行构造方法，初始化对象</li>
<li>将对象指向这个内存空间</li>
</ol>
<p>出现问题有个前提：构造方法中含有该对象的成员变量赋值或处理语句</p>
<p>在极端情况下，<code>lazy = new Lazy();</code> 的三步操作可能遭到重排列，步骤3（将对象指向内存）和步骤2（执行构造方法）可以不按次序完成</p>
<p>若执行顺序为 132，则导致：</p>
<ul>
<li><p>虽然对象不为空</p>
</li>
<li><p>但是对象没有完全被初始化，对象内成员变量的值为默认值，而不是构造方法中的赋值（导致某个线程获取到的对象里面的成员变量的值错误）</p>
<p>  <img src="https://s1.ax1x.com/2022/05/05/Oeu0cd.png" alt="Oeu0cd.png"></p>
</li>
</ul>
<p><span class="red bold">解决方法：</span></p>
<ol>
<li>volatile（<span class="red">推荐</span>）：声明一个变量为volatile，将禁止对该对象的所有读写操作进行重排列，这将保证 <code>lazy = new Lazy();</code> 底层语句不会被重排列</li>
<li>final：不可变（final）对象的读和写操作是原子性操作</li>
</ol>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private volatile static Lazy lazy &#x3D; null;</code></pre>

<hr>
<p><strong>持有者（Holder）模式</strong></p>
<p><span class="red bold">优点：</span>在没有任何锁的情况下实现线程安全：原因：</p>
<ul>
<li>内部类在外部类加载时并不会一起加载，而是内部类被引用时才会加载内部类并且执行类初始化（又因为instance是static变量，所以会在类初始化时实例化）</li>
<li>类只会被加载并初始化一次，因此类里面的静态变量也只会初始化一次</li>
</ul>
<p><span class="red bold">缺点：</span>还是不防反射（反射可以获取一个类的构造方法，可以直接跳过内部类）</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class Lazy &#123;
    private Lazy() &#123;

    &#125;

    private static class LazyHolder &#123;
        private static Lazy lazy &#x3D; new Lazy();
    &#125;

    public static Lazy getInstance() &#123;
        return LazyHolder.lazy;
    &#125;

    public static void main(String[] args) &#123;
        for (int i &#x3D; 0; i &lt; 5; i++) &#123;
            new Thread(() -&gt; &#123;
                System.out.println(Lazy.getInstance());
            &#125;).start();
        &#125;
    &#125;
&#125;</code></pre>

<hr>
<p><strong>枚举</strong></p>
<p>枚举，一个神奇的类，它默认就不可以被new</p>
<p><span class="red bold">优点：</span>由于枚举中的对象默认是静态对象，因此当枚举被加载时，对象就会被&lt;clinit&gt;()初始化，仅此一份，<span class="red">由JVM确保线程安全</span></p>
<p><span class="red bold">为什么仅此一份？既然它自己能创建对象，那就一定有构造方法，构造方法呢？</span>：</p>
<ol>
<li>枚举的构造方法藏得很隐蔽，并且并不是无参构造，这使得反射很难发现</li>
<li>并且在执行 <code>newInstance(Object ... initargs)</code> 方法时，方法体内有检测该类是否为枚举类，若为枚举类则抛出异常</li>
</ol>
<p><span class="red bold">单例模式——枚举：</span><br><span class="red">需要注意的是，以下代码枚举单例模式为饿汉式</span>，在枚举被加载时就构造对象</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F; 对，就是这么简单
public enum EnumSingle &#123;
    INSTANCE;
&#125;
&#x2F;&#x2F; 如何获取？还是这么简单
EnumSingle enumSingle &#x3D; EnumSingle.INSTANCE;</code></pre>

<h2 id="单例模式——破坏"><a href="#单例模式——破坏" class="headerlink" title="单例模式——破坏"></a>单例模式——破坏</h2><p>破坏以上几种单例模式（除枚举外）有两种方法：</p>
<ol>
<li>反序列化</li>
<li>反射</li>
</ol>
<hr>
<p><strong>反序列化</strong></p>
<p>若一个使用了单例模式的类支持序列化，则任何单例模式都是废物，反序列化会通过反射调用无参构造创建一个新的对象</p>
<hr>
<p><strong>反射</strong></p>
<p>BUG一般的存在！破除任何单例模式，除了枚举- -</p>
<h2 id="锁总结"><a href="#锁总结" class="headerlink" title="锁总结"></a>锁总结</h2><p>包括：公平&#x2F;非公平；重入&#x2F;不可重入；自旋&#x2F;非自旋；乐观&#x2F;悲观；死锁</p>
<hr>
<p><strong>公平锁与非公平锁</strong></p>
<p><span class="red bold">公平锁：</span>很公平，先来后到，线程不可以插队<br><span class="red bold">非公平锁（默认）：</span>不公平，线程可以插队</p>
<hr>
<p><strong>可重入锁和不可重入锁</strong></p>
<p><span class="red bold">可重入锁：</span>又称递归锁，指允许统一线程同一对象上套多个锁，所有锁都是可重入锁（包括synchronized），看下面例子：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class Main &#123;
    public static void main(String[] args) &#123;
        RLock rLock &#x3D; new RLock();

        new Thread(() -&gt; &#123;
            rLock.outLock();
        &#125;).start();
    &#125;
&#125;

class RLock &#123;
    private ReentrantLock lock &#x3D;  new ReentrantLock();

    public void outLock() &#123;
        lock.lock();
        try &#123;
            System.out.println(Thread.currentThread() +  &quot;加锁&quot;);
            inLock();
        &#125; finally &#123;
            System.out.println(Thread.currentThread() +  &quot;解锁&quot;);
            lock.unlock();
        &#125;
    &#125;

    public void inLock() &#123;
        lock.lock();
        try &#123;
            System.out.println(Thread.currentThread() +  &quot;加锁&quot;);
        &#125; finally &#123;
            System.out.println(Thread.currentThread() +  &quot;解锁&quot;);
            lock.unlock();
        &#125;
    &#125;
&#125;</code></pre>

<table>
<thead>
<tr>
<th align="center">递归锁</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="https://s1.ax1x.com/2022/05/06/Ou2jw4.md.png" alt="Ou2jw4.md.png"></td>
</tr>
<tr>
<td align="center">加锁前，state为0</td>
</tr>
<tr>
<td align="center"><img src="https://s1.ax1x.com/2022/05/06/OuRFOO.md.png" alt="OuRFOO.md.png"></td>
</tr>
<tr>
<td align="center">加第一把锁后，state为1</td>
</tr>
<tr>
<td align="center"><img src="https://s1.ax1x.com/2022/05/06/OuRekd.md.png" alt="OuRekd.md.png"></td>
</tr>
<tr>
<td align="center">加第二把锁后，state为2</td>
</tr>
<tr>
<td align="center"><img src="https://s1.ax1x.com/2022/05/06/OuRlX8.md.png" alt="OuRlX8.md.png"></td>
</tr>
</tbody></table>
<p><span class="red bold">可重入锁的原理：</span></p>
<ul>
<li>每一把锁都会关联一个线程（exclusiveOwnerThread）和一个计数器（state）<ol>
<li>计数器为0表示没有线程持有该锁，当一个线程请求该锁成功时，锁会记录该线程，并且将计数器加一</li>
<li>若此时有其他线程请求锁，判断请求线程与占有该锁的线程是否为同一线程：是——则计数器加一；否——则请求线程等待</li>
</ol>
</li>
</ul>
<p><span class="red bold">不可重入锁：</span>不可重入锁需要自己写类定制，不可重入锁指不允许有嵌套方法重复给一个对象加锁，否则会陷入死锁</p>
<hr>
<p><strong>自旋锁与非自旋锁</strong></p>
<p><span class="red bold">自旋锁：</span>自旋锁指锁在线程获取不到锁的时候会通过循环不断尝试获取锁。<span class="red">自旋锁的特点是不会停下来</span></p>
<p><span class="red bold">非自旋锁：</span>非自旋锁指线程在获取不到锁的时候会切换线程状态，让自身休眠，知道持有锁的线程释放。<span class="red">非自旋锁的特点是会停下来</span></p>
<p><span class="red bold">自旋与非自旋：</span>非自旋锁切换线程状态会造成很大开销，非自旋锁会在获取到锁之前一直占用CPU资源。</p>
<ul>
<li>在同步代码块内容不多的情况下，可以使用自旋锁让别的线程“在线等待”</li>
<li>在同步代码块内容复杂的情况下，自旋锁造成的线程持续占用资源的开销可能会比线程切换造成的开销还要大，此时适用非自旋锁</li>
</ul>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class Main &#123;
    public static void main(String[] args) &#123;
        SpinLock spinLock &#x3D; new SpinLock();

        &#x2F;&#x2F; 线程A持有锁5秒
        new Thread(() -&gt; &#123;
            spinLock.lock();
            try &#123;
                TimeUnit.SECONDS.sleep(5);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125; finally &#123;
                spinLock.unlock();
            &#125;
        &#125;, &quot;A&quot;).start();

        &#x2F;&#x2F; 保证线程A获取锁
        TimeUnit.SECONDS.sleep(3);

        &#x2F;&#x2F; 线程B在三秒后请求锁，并且自旋约两秒
        new Thread(() -&gt; &#123;
            spinLock.lock();
            try &#123;
                &#x2F;&#x2F; do something...
            &#125; finally &#123;
                spinLock.unlock();
            &#125;
        &#125;, &quot;B&quot;).start();
    &#125;
&#125;

class SpinLock &#123;
    &#x2F;&#x2F; 使用原子引用维护线程
    AtomicReference&lt;Thread&gt; threadAtomicReference &#x3D; new AtomicReference&lt;&gt;();

    public void lock() &#123;
        Thread current &#x3D; Thread.currentThread();

        while (!threadAtomicReference.compareAndSet(null, current)) &#123;
            &#x2F;&#x2F; 若修改失败，继续尝试获取锁
            System.out.println(&quot;回れ&quot;);
            TimeUnit.MILLISECONDS.sleep(500);
        &#125;
        &#x2F;&#x2F; 若成功获取到锁
        System.out.println(Thread.currentThread().getName() + &quot;加锁&quot;);
    &#125;

    public void unlock() &#123;
        Thread current &#x3D; Thread.currentThread();
        threadAtomicReference.compareAndSet(current, null);
        System.out.println(Thread.currentThread().getName() + &quot;解锁&quot;);
    &#125;
&#125;</code></pre>

<p><img src="https://s1.ax1x.com/2022/05/06/OKQGNR.png" alt="OKQGNR.png"></p>
<hr>
<p><strong>乐观锁和悲观锁</strong></p>
<p><span class="red bold">乐观锁：</span>乐观锁就是很乐观，怕什么，根本不上锁</p>
<p>虽然乐观锁不上锁，但是乐观锁会通过在提交时验证主存数据是否是原数据（CAS）来判断是否存在数据冲突（如：原子包装类操作 ）</p>
<p><span class="red bold">悲观锁：</span>悲观锁就是用尽一切方法来防止数据冲突，会在获取并修改数据之前对数据进行加锁，在其提交数据并解锁之前，任何线程不得访问该数据（如：加任何读写锁，可重入锁）</p>
<hr>
<p><strong>死锁</strong></p>
<p>死锁就是两条线程分别占有自己的资源不放手，并且想要获取对方的资源</p>
<p><img src="https://z3.ax1x.com/2021/10/16/5JTvtJ.png" alt="5JTvtJ.png"></p>
<p>这是一个生活中的死锁：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class Main &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F; 当你需要出示健康码但是手机坏了，现在去商场买手机时：
        String code &#x3D; &quot;健康码&quot;;
        String phone &#x3D; &quot;手机&quot;;

        new Thread(() -&gt; &#123;
            new ResourceAllocation(code, phone).getAllResource();
        &#125;, &quot;你&quot;).start();
        new Thread(() -&gt; &#123;
            new ResourceAllocation(phone, code).getAllResource();
        &#125;, &quot;商场保安&quot;).start();

    &#125;
&#125;

&#x2F;&#x2F; 对两个资源进行分配的类
class ResourceAllocation &#123;
    private Object keepResource;
    private Object waitResource;

    public ResourceAllocation(Object keepResource, Object waitResource) &#123;
        this.keepResource &#x3D; keepResource;
        this.waitResource &#x3D; waitResource;
    &#125;

    public void getAllResource() &#123;
        synchronized (keepResource) &#123;
            System.out.println(Thread.currentThread().getName() + &quot;获取到资源&quot; + keepResource);

            &#x2F;&#x2F; do something
            try &#123;
                TimeUnit.SECONDS.sleep(1);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;

            System.out.println(Thread.currentThread().getName() + &quot;尝试获取资源&quot; + waitResource);
            synchronized (waitResource) &#123;
                System.out.println(Thread.currentThread().getName() + &quot;获取到资源&quot; + waitResource);
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

<h2 id="死锁排查"><a href="#死锁排查" class="headerlink" title="死锁排查"></a>死锁排查</h2><hr>
<p><strong>命令行工具（堆栈跟踪）</strong></p>
<p>Java自带一些可以使用命令行调用的工具：</p>
<ol>
<li>使用 <code>jps -l</code> 获取所有Java进程及其进程号</li>
<li>使用 <code>jstack 进程号</code> 进行进程监视</li>
</ol>
<p>对上一个死锁例子进行进程监视</p>
<pre class="line-numbers language-none"><code class="language-none">Found one Java-level deadlock:
&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
&quot;你&quot;:
  waiting to lock monitor 0x0000018e5c885280 (object 0x00000007189a71f8, a java.lang.String),
  which is held by &quot;商场保安&quot;
&quot;商场保安&quot;:
  waiting to lock monitor 0x0000018e5bc64700 (object 0x00000007189a71c8, a java.lang.String),
  which is held by &quot;你&quot;
</code></pre>

<hr>
<p><strong>图形化工具（堆栈跟踪）</strong></p>
<p>Java自带一个图形化内存监视工具 <code>jconsole.exe</code></p>
<blockquote>
<p>选择线程-&gt;不安全的链接-&gt;线程-&gt;检测死锁</p>
</blockquote>
<hr>
<p><strong>日志</strong></p>
<p>找运维看日志</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/04/22/Java-IO%E6%B5%81/" rel="prev" title="Java IO流">
                  <i class="fa fa-chevron-left"></i> Java IO流
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/05/10/MySQL%E5%9F%BA%E6%9C%AC/" rel="next" title="MySQL基本">
                  MySQL基本 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Loliconkelvin</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/components/prism-core.min.js" integrity="sha256-4mJNT2bMXxcc1GCJaxBmMPdmah5ji0Ldnd79DKd1hoM=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/plugins/autoloader/prism-autoloader.min.js" integrity="sha256-dL6vkUiCn30lPTN9cVrmQHo5UQmEwDMrx2ppAk4IhVk=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/plugins/line-numbers/prism-line-numbers.min.js" integrity="sha256-9cmf7tcLdXpKsPi/2AWE93PbZpTp4M4tqzFk+lWomjU=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
