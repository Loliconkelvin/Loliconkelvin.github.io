<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"loliconkelvin.github.io","root":"/","images":"/images","scheme":"Pisces","version":"8.7.1","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":true,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content=".red {     color: red; }  .blue {     color: blue; }   Java多线程">
<meta property="og:type" content="article">
<meta property="og:title" content="Java多线程">
<meta property="og:url" content="https://loliconkelvin.github.io/2021/09/25/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="萝莉控的小窝">
<meta property="og:description" content=".red {     color: red; }  .blue {     color: blue; }   Java多线程">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://z3.ax1x.com/2021/09/28/4fgqPS.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1328967/201906/1328967-20190605221210905-58853278.png">
<meta property="og:image" content="https://img-blog.csdn.net/20171201125413448?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenhoNDc2NzcxNzU2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://z3.ax1x.com/2021/10/13/5MVJjH.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/10/13/5MVtud.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/10/13/5MVGge.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/10/13/5MV39O.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/10/12/5nMCp8.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/10/15/5394iT.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/10/15/5395JU.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/10/16/5JTvtJ.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/10/16/5JHCCj.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/01/IPExTU.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/10/31/Ip60H0.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/01/IP1oz8.png">
<meta property="article:published_time" content="2021-09-25T01:44:45.000Z">
<meta property="article:modified_time" content="2022-02-16T09:10:23.172Z">
<meta property="article:author" content="Loliconkelvin">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://z3.ax1x.com/2021/09/28/4fgqPS.png">


<link rel="canonical" href="https://loliconkelvin.github.io/2021/09/25/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://loliconkelvin.github.io/2021/09/25/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/","path":"2021/09/25/Java多线程/","title":"Java多线程"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Java多线程 | 萝莉控的小窝</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">萝莉控的小窝</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">多线程的一些概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%89%E7%A7%8D%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="nav-number">2.</span> <span class="nav-text">线程三种创建方式（重点）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BFThread%E7%B1%BB%EF%BC%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%EF%BC%89"><span class="nav-number">2.1.</span> <span class="nav-text">继承Thread类（不建议使用）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E7%BD%91%E5%9B%BE%E4%B8%8B%E8%BD%BD"><span class="nav-number">2.1.1.</span> <span class="nav-text">应用——网图下载</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3%EF%BC%88%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%EF%BC%89"><span class="nav-number">2.2.</span> <span class="nav-text">实现Runnable接口（建议使用）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E8%AF%86%E5%B9%B6%E5%8F%91%EF%BC%88%E7%BA%BF%E7%A8%8B%E5%90%8D%E5%9C%A8%E8%BF%99%E9%87%8C%EF%BC%89%E4%B8%8E%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="nav-number">2.3.</span> <span class="nav-text">初识并发（线程名在这里）与并发问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E7%81%AB%E8%BD%A6%E7%A5%A8"><span class="nav-number">2.3.1.</span> <span class="nav-text">应用——火车票</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E9%BE%9F%E5%85%94%E8%B5%9B%E8%B7%91"><span class="nav-number">2.3.2.</span> <span class="nav-text">应用——龟兔赛跑</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3%EF%BC%88%E4%BA%86%E8%A7%A3%E5%8D%B3%E5%8F%AF-%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89"><span class="nav-number">2.4.</span> <span class="nav-text">实现Callable接口（了解即可 线程池）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%88Lamda%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%8C%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E5%9C%A8%E8%BF%99%E9%87%8C%EF%BC%89"><span class="nav-number">2.5.</span> <span class="nav-text">静态代理（Lamda表达式，函数式接口在这里）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.5.1.</span> <span class="nav-text">函数式接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Lamda%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E7%AE%80%E5%8C%96%EF%BC%89"><span class="nav-number">2.5.2.</span> <span class="nav-text">Lamda表达式（匿名内部类的简化）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%AE%80%E5%8C%96"><span class="nav-number">2.5.3.</span> <span class="nav-text">Lambda表达式的简化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E4%BE%8B%E5%AD%90%E2%80%94%E2%80%94%E7%94%B5%E5%BD%B1%E4%B8%8E%E5%B9%BF%E5%91%8A"><span class="nav-number">2.5.4.</span> <span class="nav-text">静态代理例子——电影与广告</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E4%BE%8B%E5%AD%90%E2%80%94%E2%80%94%E7%BB%93%E5%A9%9A%E8%80%85%E4%B8%8E%E5%A9%9A%E5%BA%86%E5%85%AC%E5%8F%B8%EF%BC%88%E8%BF%99%E4%B8%AA%E4%BE%8B%E5%AD%90%E6%9B%B4%E7%9B%B4%E8%A7%82%EF%BC%89"><span class="nav-number">2.5.5.</span> <span class="nav-text">静态代理例子——结婚者与婚庆公司（这个例子更直观）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.5.6.</span> <span class="nav-text">静态代理与多线程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="nav-number">3.</span> <span class="nav-text">线程状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Thread-currentThread"><span class="nav-number">4.</span> <span class="nav-text">Thread.currentThread()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%96%B9%E6%B3%95"><span class="nav-number">5.</span> <span class="nav-text">线程方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B"><span class="nav-number">5.1.</span> <span class="nav-text">终止线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%BC%91%E7%9C%A0%EF%BC%88sleep%EF%BC%89"><span class="nav-number">5.2.</span> <span class="nav-text">线程休眠（sleep）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F%E7%BD%91%E7%BB%9C%E5%BB%B6%E6%97%B6"><span class="nav-number">5.2.1.</span> <span class="nav-text">模拟网络延时</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F%E5%80%92%E8%AE%A1%E6%97%B6"><span class="nav-number">5.2.2.</span> <span class="nav-text">模拟倒计时</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%A4%BC%E8%AE%A9%EF%BC%88yield%EF%BC%89"><span class="nav-number">5.3.</span> <span class="nav-text">线程礼让（yield）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%BA%E5%88%B6%E7%BA%BF%E7%A8%8B%E5%8A%A0%E5%85%A5%E6%89%A7%E8%A1%8C%EF%BC%88join%EF%BC%89"><span class="nav-number">5.4.</span> <span class="nav-text">强制线程加入执行（join）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%B5%8B%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%EF%BC%88state%EF%BC%89"><span class="nav-number">5.5.</span> <span class="nav-text">检测线程状态（state）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%88priority%EF%BC%89"><span class="nav-number">5.6.</span> <span class="nav-text">线程优先级（priority）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%EF%BC%88daemon%EF%BC%89"><span class="nav-number">5.7.</span> <span class="nav-text">守护线程（daemon）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5-%E5%B9%B6%E5%8F%91%EF%BC%88%E9%87%8D%E7%82%B9-%E9%9A%BE%E7%82%B9%EF%BC%89"><span class="nav-number">6.</span> <span class="nav-text">线程同步 并发（重点 难点）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="nav-number">6.1.</span> <span class="nav-text">线程为什么不安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8sleep%E4%BC%9A%E5%A2%9E%E5%8A%A0%E9%97%AE%E9%A2%98%E7%9A%84%E5%8F%91%E7%94%9F%E6%80%A7"><span class="nav-number">6.2.</span> <span class="nav-text">为什么使用sleep会增加问题的发生性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%9F%E5%88%97"><span class="nav-number">6.3.</span> <span class="nav-text">队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%EF%BC%88synchronized%EF%BC%89"><span class="nav-number">6.4.</span> <span class="nav-text">锁（synchronized）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%88%E9%94%81%E9%A2%84%E5%A4%87%EF%BC%89%E5%90%8C%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E4%B8%8D%E5%90%8C%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">6.5.</span> <span class="nav-text">（锁预备）同一个实例的多线程与不同实例的多线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%EF%BC%88synchronized%E6%96%B9%E6%B3%95%EF%BC%89"><span class="nav-number">6.6.</span> <span class="nav-text">同步方法（synchronized方法）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E7%81%AB%E8%BD%A6%E7%A5%A8%E4%BC%98%E5%8C%96"><span class="nav-number">6.6.1.</span> <span class="nav-text">同步方法应用——火车票优化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%9D%97%EF%BC%88synchronized%E5%9D%97%EF%BC%89"><span class="nav-number">6.7.</span> <span class="nav-text">同步块（synchronized块）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%9D%97%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E9%93%B6%E8%A1%8C%E4%BC%98%E5%8C%96"><span class="nav-number">6.7.1.</span> <span class="nav-text">同步块应用——银行优化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E9%94%81%E5%92%8C%E7%B1%BB%E9%94%81"><span class="nav-number">6.8.</span> <span class="nav-text">对象锁和类锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CopyOnWriteArrayList"><span class="nav-number">6.9.</span> <span class="nav-text">CopyOnWriteArrayList</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">6.10.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E4%BE%8B%E5%AD%90%E2%80%94%E2%80%94%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E8%AF%B4%E8%AF%B4%E6%AD%BB%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">6.10.1.</span> <span class="nav-text">死锁例子——面试官：说说死锁的概念</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lock%E9%94%81%E2%80%94%E2%80%94ReentrantLock%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="nav-number">6.11.</span> <span class="nav-text">Lock锁——ReentrantLock可重入锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%8D%8F%E4%BD%9C"><span class="nav-number">7.</span> <span class="nav-text">线程协作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%A1%E7%A8%8B%E6%B3%95"><span class="nav-number">7.1.</span> <span class="nav-text">管程法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E7%81%AF%E6%B3%95%EF%BC%88%E7%BC%93%E5%AD%98%E4%B8%BA1%E7%9A%84%E7%AE%A1%E7%A8%8B%E6%B3%95%EF%BC%89"><span class="nav-number">7.2.</span> <span class="nav-text">信号灯法（缓存为1的管程法）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">8.</span> <span class="nav-text">线程池</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Loliconkelvin"
      src="/uploads/avatar.png">
  <p class="site-author-name" itemprop="name">Loliconkelvin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Loliconkelvin" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Loliconkelvin" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:loliconkelvin@gmail.com" title="E-Mail → mailto:loliconkelvin@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



          </div>
        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://loliconkelvin.github.io/2021/09/25/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Loliconkelvin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萝莉控的小窝">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java多线程
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-25 09:44:45" itemprop="dateCreated datePublished" datetime="2021-09-25T09:44:45+08:00">2021-09-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-02-16 17:10:23" itemprop="dateModified" datetime="2022-02-16T17:10:23+08:00">2022-02-16</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <style>
.red {
    color: red;
}

.blue {
    color: blue;
}
</style>

<p>Java多线程</p>
<span id="more"></span>

<h2 id="多线程的一些概念"><a href="#多线程的一些概念" class="headerlink" title="多线程的一些概念"></a>多线程的一些概念</h2><ul>
<li>一条线程就是一条独立的执行路径</li>
<li>在程序运行时，即使没有创建自己的线程，后台也会有多个线程，比如主线程和gc线程（垃圾回收）</li>
<li>main()称为主线程，为系统的入口</li>
<li>在一个进程中，若开辟了多线程，线程的先后运行由调度器安排，不能人为干预</li>
<li>多线程对同一份资源进行操作时，会存在资源抢夺问题，需要加入并发机制（边消费边取钱）</li>
<li>多线程会带来额外的开销（如CPU调度时间），可以用并发控制开销</li>
<li>每个线程在自己的工作内存交互，内存控制不当会导致数据不一致</li>
</ul>
<h2 id="线程三种创建方式（重点）"><a href="#线程三种创建方式（重点）" class="headerlink" title="线程三种创建方式（重点）"></a>线程三种创建方式（重点）</h2><h3 id="继承Thread类（不建议使用）"><a href="#继承Thread类（不建议使用）" class="headerlink" title="继承Thread类（不建议使用）"></a>继承Thread类（不建议使用）</h3><ul>
<li><p>创建步骤：</p>
<ol>
<li>创建一个类 并且 继承Thread类</li>
<li>重写 <code>run()</code> 方法 （这里就是写你这条线程要执行的东西）</li>
<li>创建线程：回到主线程，new一个刚刚创建的类的对象</li>
<li>开启线程：调用该类的 <code>start()</code> 方法<br> （若调用run方法，则是单线程，就跟平时调用方法一样，走完run()再回到主线）</li>
<li>当 <code>run()</code> 方法执行完之后，线程就会自动死亡<br /></li>
</ol>
</li>
<li><p>线程开启不一定立即执行，而是由CPU调度与主线程交替并行</p>
</li>
</ul>
<h4 id="应用——网图下载"><a href="#应用——网图下载" class="headerlink" title="应用——网图下载"></a>应用——网图下载</h4><ol>
<li><p>事前准备</p>
<ol>
<li>下载 <code>commons-io</code> 工具包（jar）</li>
<li>在项目文件夹下新增lib文件夹，把下载的工具包扔进去</li>
<li>将其增加为项目的库函数<blockquote>
<p>右键工具包 -&gt; Add as library -&gt; OK</p>
<br /></blockquote>
</li>
</ol>
</li>
<li><p>写多线程类</p>
<ol>
<li>写一个类 并 继承Thread类</li>
<li>重写 <code>run()</code> 方法,使用 commons-io 工具包下的 FileUtils 类 中的 <code>copyURLToFile</code> 方法实现网图下载</li>
<li>发现该方法要传入两个参数：<ol>
<li>URL类型的形参，new一个<ul>
<li>URL类型的构造需要传入一个String，在方法外面创建一个，作为构造多线程类所需要的形参</li>
</ul>
</li>
<li>File类型的形参，new一个<ul>
<li>File类型的构造需要传入一个String，同上</li>
</ul>
</li>
</ol>
<ul>
<li>这里可以在方法外面new，也可以在形参这里new匿名对象</li>
</ul>
</li>
<li>发现该方法还用Throws甩了一个异常，用try-catch包围（Alt + Enter自动纠错大法好）,并处理异常</li>
<li>写该多线程类的构造方法<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.company.demo;

import org.apache.commons.io.FileUtils;

import java.io.File;
import java.io.IOException;
import java.net.URL;

public class DownloadThread extends Thread &#123;
    private final String url;
    private final String fileName;

    public DownloadThread(String url, String fileName) &#123;
        this.url &#x3D; url;
        this.fileName &#x3D; fileName;
    &#125;

    @Override
    public void run() &#123;
        try &#123;
            FileUtils.copyURLToFile(new URL(url), new File(fileName));
            System.out.println(fileName + &quot;文件已下载&quot;);
        &#125; catch (IOException e) &#123;
            System.out.println(&quot;IO流错误，来自run&quot;);
            e.printStackTrace();
        &#125;
    &#125;
&#125;</code></pre>
<br /></li>
</ol>
</li>
<li><p>写主函数</p>
<ol>
<li>在主函数里new一个或多个多线程类，根据其构造方法传入对应参数</li>
<li>分别使用 <code>对象名.start();</code> 启动一个或多个线程<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.company.demo;

public class Main &#123;
    public static void main(String[] args) &#123;
        DownloadThread thread1 &#x3D; new DownloadThread(&quot;https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20190829105807206.png&quot;, &quot;1.jpg&quot;);
        DownloadThread thread2 &#x3D; new DownloadThread(&quot;https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20190829105807206.png&quot;, &quot;2.jpg&quot;);
        thread1.start();
        thread2.start();
    &#125;
&#125;</code></pre></li>
</ol>
</li>
</ol>
<h3 id="实现Runnable接口（建议使用）"><a href="#实现Runnable接口（建议使用）" class="headerlink" title="实现Runnable接口（建议使用）"></a>实现Runnable接口（建议使用）</h3><ul>
<li><p>创建步骤：</p>
<ol>
<li>写一个类 并 实现Runnable接口</li>
<li>马上重写 <code>run()</code></li>
<li>回到主函数，new一个刚刚写的类</li>
<li><span class="red">接下来的步骤与继承Thread类的不同：</span><ul>
<li>new一个Thread类，并把刚刚new的多线程类的对象作为形参丢进去，<span class="red">用new出来的Thread对象调用 <code>start()</code> 方法</span><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">TestThread testThread &#x3D; new TestThread();

&#x2F;&#x2F; 创建线程对象，通过线程对象开启线程 代理
new Thread(testThread).start();</code></pre></li>
</ul>
</li>
</ol>
</li>
<li><p>好处：避免单继承的局限性，接口可以多继承，可以实现一个多线程对象被多个线程调用（详见下一标题）</p>
</li>
</ul>
<h3 id="初识并发（线程名在这里）与并发问题"><a href="#初识并发（线程名在这里）与并发问题" class="headerlink" title="初识并发（线程名在这里）与并发问题"></a>初识并发（线程名在这里）与并发问题</h3><ul>
<li>并发是指多线程操作一个对象，他们共享对象里的变量</li>
</ul>
<h4 id="应用——火车票"><a href="#应用——火车票" class="headerlink" title="应用——火车票"></a>应用——火车票</h4><p><span id="ticket">&nbsp;</span></p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.company.demo;

public class TrainTickets implements Runnable&#123;
    private int ticketsNumber &#x3D; 10;

    @Override
    public void run() &#123;
        while (true) &#123;

            if (ticketsNumber &#x3D;&#x3D; 0) &#123;
                break;
            &#125;

            &#x2F;&#x2F; 模拟延时
            try &#123;
                Thread.sleep(200);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;

            System.out.println(Thread.currentThread().getName() + &quot;拿到了&quot; + ticketsNumber-- + &quot;号票&quot;);
        &#125;
    &#125;
&#125;</code></pre>

<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">TrainTickets trainTickets &#x3D; new TrainTickets();
&#x2F;&#x2F; 可以使用第二个参数给线程命名
new Thread(trainTickets, &quot;1&quot;).start();
new Thread(trainTickets, &quot;2&quot;).start();
new Thread(trainTickets, &quot;3&quot;).start();

&#x2F;*
其中一次输出：
2拿到了10号票
1拿到了9号票
3拿到了9号票
3拿到了6号票
1拿到了7号票
2拿到了8号票
1拿到了4号票
2拿到了3号票
3拿到了5号票
3拿到了2号票
1拿到了1号票
2拿到了2号票
*&#x2F;</code></pre>

<ul>
<li>可以看到有重复的票，这就是不安全的线程，即并发问题</li>
</ul>
<h4 id="应用——龟兔赛跑"><a href="#应用——龟兔赛跑" class="headerlink" title="应用——龟兔赛跑"></a>应用——龟兔赛跑</h4><ol>
<li><p>程序规划</p>
<ol>
<li>需要一条赛道</li>
<li>每次跑需要判断比赛是否结束，结束了就不用跑了</li>
<li>如果有胜利者，打印出胜利者</li>
<li>龟和兔一起跑，为双线程</li>
<li>（扩展）模拟兔子睡觉<br /></li>
</ol>
</li>
<li><p>程序实现</p>
<ol>
<li><p>需要赛道</p>
<ul>
<li>我们可以直接在类里把赛道长度写死，也可以使用传入参数至构造函数的方法在主函数定义赛道</li>
</ul>
<ol>
<li>首先创建一个类实现Runnable接口，重写run()方法，（如需自定义赛道）写有参构造<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.company.demo;

public class Race implements Runnable &#123;
    private int length;

    &#x2F;&#x2F; 定义赛道长度
    public Race(int length) &#123;
        this.length &#x3D; length;
    &#125;

    @Override
    public void run() &#123;
    &#125;
&#125;</code></pre></li>
<li>开始跑，写一个for记录步数，当步数的范围是 0~赛道长度 （可以等于）<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">for (int step &#x3D; 0; step &lt;&#x3D; length; step++) &#123;
    System.out.println(Thread.currentThread().getName() + &quot;跑了&quot; + step + &quot;步&quot;);
&#125;</code></pre>
<br /></li>
</ol>
</li>
<li><p>写一个方法，判断是否已有选手完赛，若没有，判断自身是否完赛</p>
<ul>
<li>注意是下图逻辑，就不要想else if了<br><img src="https://z3.ax1x.com/2021/09/28/4fgqPS.png" alt="4fgqPS.png"></li>
</ul>
<ol>
<li>写方法以判断是否有胜者<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private static String winner;

private boolean gameOver(int step) &#123;
    &#x2F;&#x2F; 有胜者了
    if (winner !&#x3D; null) &#123;
        return true;
        &#x2F;&#x2F;还没有胜者，判断当前选手是否跑完
    &#125; else &#123;
        if (step &gt;&#x3D; length) &#123;
            winner &#x3D; Thread.currentThread().getName();
            System.out.println(&quot;winner is &quot; + winner);
            return true;
            &#x2F;&#x2F; 还没有胜者，当前选手没跑完，返回假
        &#125; else &#123;
            return false;
        &#125;
    &#125;
&#125;</code></pre></li>
<li>选手每跑一步执行该方法判断一下（在输出步数下面加）<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F; 比赛结束就不用跑了
if (gameOver(step))&#123;
    break;
&#125;</code></pre></li>
</ol>
</li>
<li><p>在主函数启动线程</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.company.demo;

public class Main &#123;
    public static void main(String[] args) &#123;
        Race race &#x3D; new Race(100);

        new Thread(race, &quot;兔子&quot;).start();
        new Thread(race, &quot;乌龟&quot;).start();
    &#125;
&#125;</code></pre>
<br /></li>
</ol>
</li>
<li><p>模拟兔子睡觉</p>
</li>
</ol>
<ul>
<li><p>这里会提一下sleep线程休眠，后面还会详细讲到</p>
</li>
<li><p>这里还会有如何让特定的线程休眠</p>
</li>
<li><p>如何让特定的线程休眠：</p>
<ol>
<li>首先线程一定要有名字</li>
<li>CPU执行什么线程有它自己决定，说明同一时间只能执行一个线程，因此只需要通过判断一下线程名得知目前执行的线程是否是要休眠的线程即可,然后就可以让当前线程睡觉<ul>
<li>使用 <code>equals()</code> 方法对比</li>
</ul>
</li>
<li>注意线程休眠函数会甩个异常出来<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F; 模拟兔子睡觉
if (Thread.currentThread().getName().equals(&quot;兔子&quot;) &amp;&amp; (step % 10 &#x3D;&#x3D; 0)) &#123;
    try &#123;
        Thread.sleep(10);
    &#125; catch (InterruptedException e) &#123;
        e.printStackTrace();
    &#125;
&#125;</code></pre></li>
</ol>
</li>
</ul>
<h3 id="实现Callable接口（了解即可-线程池）"><a href="#实现Callable接口（了解即可-线程池）" class="headerlink" title="实现Callable接口（了解即可 线程池）"></a>实现Callable接口（了解即可 线程池）</h3><ul>
<li>好处：<ol>
<li>可以拥有返回值</li>
<li>可以抛出异常</li>
</ol>
</li>
<li>坏处：<ol>
<li>代码复杂</li>
</ol>
</li>
</ul>
<ol>
<li><p>写一个类 并 实现 Callable接口</p>
<ul>
<li><span class="red">注意：Callable接口需要一个返回值，在Callable后面跟一个&lt;&gt;</span></li>
<li><span class="red">该返回值是一个类，不是基本数据类型（注意区分Boolean和boolean）</span></li>
</ul>
 <pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.company.demo;

import java.util.concurrent.Callable;

public class CallableTest implements Callable&lt;Boolean&gt; &#123;

    @Override
    public Boolean call() throws Exception &#123;
        &#x2F;&#x2F; write code here
        return true;
    &#125;
&#125;</code></pre>
<br /></li>
<li><p>在主函数开启线程</p>
<ol>
<li>创建线程</li>
<li>创建线程池</li>
<li>把线程扔进线程池</li>
<li>接收线程执行结果</li>
<li>关闭线程池<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.company.demo;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class Main &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F; 创建线程
        CallableTest callable01 &#x3D; new CallableTest();
        CallableTest callable02 &#x3D; new CallableTest();

        &#x2F;&#x2F; 创建一个可以存放两个线程的线程池
        ExecutorService server &#x3D; Executors.newFixedThreadPool(2);

        &#x2F;&#x2F; 把线程扔（提交）进线程池
        Future&lt;Boolean&gt; r1 &#x3D; server.submit(callable01);
        Future&lt;Boolean&gt; r2 &#x3D; server.submit(callable02);

        &#x2F;&#x2F; 获取线程执行结果，注意接收异常
        try &#123;
            boolean rs1 &#x3D; r1.get();
            boolean rs2 &#x3D; r2.get();
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125; catch (ExecutionException e) &#123;
            e.printStackTrace();
        &#125;

        &#x2F;&#x2F; 关闭线程池
        server.shutdownNow();
    &#125;
&#125;</code></pre></li>
</ol>
</li>
</ol>
<h3 id="静态代理（Lamda表达式，函数式接口在这里）"><a href="#静态代理（Lamda表达式，函数式接口在这里）" class="headerlink" title="静态代理（Lamda表达式，函数式接口在这里）"></a>静态代理（Lamda表达式，函数式接口在这里）</h3><h4 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h4><ul>
<li><p>如果一个接口只包含一个抽象方法，那他就是函数式接口</p>
<br /></li>
<li><p>对于函数式接口，我们可以通过lamda表达式创建该接口的对象</p>
</li>
</ul>
<h4 id="Lamda表达式（匿名内部类的简化）"><a href="#Lamda表达式（匿名内部类的简化）" class="headerlink" title="Lamda表达式（匿名内部类的简化）"></a>Lamda表达式（匿名内部类的简化）</h4><ul>
<li><p><span class="red">用于简化创建函数式接口的对象，解决类只用一次的问题</span></p>
</li>
<li><p>可以写成匿名内部类的就可以写成Lambda表达式，格式为：</p>
  <pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F; 形参可选
(形参) -&gt; &#123;返回值&#125;

(形参) -&gt; &#123;语句;&#125;

&#x2F;&#x2F; 当只有一条语句时
(形参) -&gt; 语句;</code></pre></li>
<li><p>因为Lambda表达式的本质就是匿名内部类，因此他需要一个对象来接收，或者直接在一个以对象为形参的方法中被调用</p>
  <pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F; 接口
public interface ILove &#123;
    void printLove(String name);
&#125;

&#x2F;&#x2F; Main方法
public class Main &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F; 使用Lambda表达式实现接口
        &#x2F;&#x2F; 这里的形参可以不使用String name声明格式
        ILove iLove &#x3D; (name) -&gt; System.out.println(&quot;I love &quot; + name);
        &#x2F;&#x2F; 调用方法
        iLove.printLove(&quot;婉儿&quot;);
    &#125;
&#125;</code></pre></li>
</ul>
<h4 id="Lambda表达式的简化"><a href="#Lambda表达式的简化" class="headerlink" title="Lambda表达式的简化"></a>Lambda表达式的简化</h4><ul>
<li>当形参只有一个时，小括号可以去掉</li>
<li>当语句只有一条时，大括号可以去掉</li>
<li>形参的参数类型可以省略，当多个形参的情况下，要省略参数类型，就将全部形参的参数类型都省略</li>
</ul>
<h4 id="静态代理例子——电影与广告"><a href="#静态代理例子——电影与广告" class="headerlink" title="静态代理例子——电影与广告"></a>静态代理例子——电影与广告</h4><ul>
<li>电影院播放电影总是在电影前后播放一些广告，但是电影原原本的功能就是播放电影，他希望自己专注于电影的播放，则我们可以通过代理实现广告的播放 ——代理：对对象的功能进行拓展，完成一些对象不能完成的功能</li>
</ul>
<ol>
<li><p>需要一个播放器，抽象方法：播放</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public interface MoviePlayer &#123;
    void play();
&#125;</code></pre></li>
<li><p>对于电影这个类本身，他的实例是需要被播放的，因此它需要继承接口</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class Movie implements MoviePlayer&#123;
    @Override
    public void play() &#123;
        System.out.println(&quot;正在播放电影&quot;);
    &#125;
&#125;</code></pre></li>
<li><p>有请代理商</p>
<ol>
<li>他的广告也是需要被播放的，因此它也需要继承接口，并且他重写的方法可以加一些自己所需要的功能（方法）</li>
<li>名曰代理，因此他还需要顺便播放一下电影<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class Proxy implements MoviePlayer&#123;

    private Movie movie;

    public Proxy() &#123;
    &#125;

    public Proxy(Movie movie) &#123;
        this.movie &#x3D; movie;
    &#125;

    @Override
    public void play() &#123;
        advertisement();
        movie.play();
        advertisement();
    &#125;

    private void advertisement() &#123;
        System.out.println(&quot;正在播放广告&quot;);
    &#125;
&#125;</code></pre></li>
</ol>
</li>
<li><p>在Main方法里面创建电影实例，创建代理商实例，把电影实例丢给代理商，并由代理商执行play方法</p>
</li>
</ol>
<h4 id="静态代理例子——结婚者与婚庆公司（这个例子更直观）"><a href="#静态代理例子——结婚者与婚庆公司（这个例子更直观）" class="headerlink" title="静态代理例子——结婚者与婚庆公司（这个例子更直观）"></a>静态代理例子——结婚者与婚庆公司（这个例子更直观）</h4><ol>
<li><p>接口</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public interface Merry &#123;
    void getMerry();
&#125;</code></pre></li>
<li><p>本体</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class MerryPeople implements Merry&#123;
    @Override
    public void getMerry() &#123;
        System.out.println(&quot;婚礼开始了&quot;);
    &#125;
&#125;</code></pre></li>
<li><p>代理</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class MerryProxy implements Merry&#123;
    private MerryPeople people;

    public MerryProxy(MerryPeople people) &#123;
        this.people &#x3D; people;
    &#125;

    @Override
    public void getMerry() &#123;
        beforeMerry();
        people.getMerry();
        afterMerry();
    &#125;

    private void beforeMerry() &#123;
        System.out.println(&quot;婚礼之前，收定金，布置现场&quot;);
    &#125;

    private void afterMerry() &#123;
        System.out.println(&quot;婚礼之后，收尾款&quot;);
    &#125;
&#125;</code></pre></li>
<li><p>Main方法</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class Main &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F; 新建要结婚的对象（只有一个？）
        MerryPeople you &#x3D; new MerryPeople();
        &#x2F;&#x2F; 把对象扔给婚庆公司
        MerryProxy merryProxy &#x3D; new MerryProxy(you);
        &#x2F;&#x2F; 婚庆公司干活
        merryProxy.getMerry();
    &#125;
&#125;</code></pre></li>
</ol>
<h4 id="静态代理与多线程"><a href="#静态代理与多线程" class="headerlink" title="静态代理与多线程"></a>静态代理与多线程</h4><ul>
<li>在实现Runnable接口方法中，需要创建一个类实现Runnable接口并重写方法，然后创建该类的实例，将实例丢给Thread后由Thread执行start，这就是一个代理：Thread类代理了我们创建的类</li>
</ul>
<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><ul>
<li><p>线程的五大状态：</p>
<ol>
<li>创建状态：new出来了</li>
<li>就绪状态：执行了start()但还没有被CPU调度</li>
<li>运行状态：被CPU调度了</li>
<li>阻塞状态：遇到等待输入，线程休眠等</li>
<li>死亡状态：线程自然自行完毕或外部终止线程，<span class="red">线程一旦进入死亡状态就不能再启动</span><br /></li>
</ol>
</li>
<li><p>在Thread类中有定义State枚举变量来反映线程状态，其枚举成员有：</p>
<ol>
<li>NEW: 新生状态</li>
<li>RUNNABLE: 就绪状态</li>
<li>BLOCKED: 阻塞状态，另一个线程获取了锁，目前的线程正在等待另一线程释放锁，被另一线程阻塞</li>
<li>WAITING: 在目前线程运行过程中，有其他线程使用 <code>join()</code> 插队，目前线程正在等待另一线程执行完毕，并且没有超时限制</li>
<li>TIMED_WAITING: 目前线程正在等待另一线程执行完毕，并且带有超时限制，或目前线程使用了 <code>sleep()</code> 方法</li>
<li>TERMINATED: 死亡状态<br /></li>
</ol>
<ul>
<li>关于BLOCKED、WAITING、TIMED_WAITING的说法参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/liweiminlining/article/details/102490259">BLOCKED,WAITING,TIMED_WAITING有什么区别？</a></li>
</ul>
</li>
</ul>
<h2 id="Thread-currentThread"><a href="#Thread-currentThread" class="headerlink" title="Thread.currentThread()"></a>Thread.currentThread()</h2><ul>
<li>该函数会返回一个当前线程的Thread类成员，可以应用于任何需要填入 Thread类成员 的方法中，如：Thread.currentThread().getName();</li>
</ul>
<h2 id="线程方法"><a href="#线程方法" class="headerlink" title="线程方法"></a>线程方法</h2><p>设定线程优先级 setPrioriry(int new Priority)<br>指定毫秒数让线程休眠 sleep(long millis)<br>等待该线程终止 join()<br>暂停当前正在执行的线程对象，执行其他线程 yield()<br>中断线程（不建议使用） interrupt()<br>测试线程是否活动 isAlive()</p>
<h3 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h3><ul>
<li><p><span class="red">不推荐使用JDK提供的stop().destroy等过期方法</span></p>
<br /></li>
<li><p><span class="red">使用一个私有标志位，并对外提供改变标志位的方法，让线程自己检测标志位为特定条件时自行停止</span></p>
<br /></li>
<li><p>如何让线程自己停止：</p>
<ol>
<li>有次数的循环/非死循环</li>
<li>设置标志位，通过外部改变标志位</li>
<li>不使用过时方法</li>
</ol>
</li>
</ul>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class ThreadStopTest implements Runnable &#123;
    private boolean flag &#x3D; true;

    @Override
    public void run() &#123;
        int i &#x3D; 0;
        while (flag) &#123;
            System.out.println(&quot;Running&quot; + i++);
        &#125;
    &#125;

    public void threadStop() &#123;
        this.flag &#x3D; false;
    &#125;
&#125;</code></pre>
<pre><code>* 在main方法中决定什么条件执行threadStop()方法以结束线程
</code></pre>
<h3 id="线程休眠（sleep）"><a href="#线程休眠（sleep）" class="headerlink" title="线程休眠（sleep）"></a>线程休眠（sleep）</h3><ul>
<li><span id="sleep">使用 <code>Thread.sleep(毫秒数);</code> 指定当前线程的阻塞毫秒数</span></li>
<li>注意：<code>sleep();</code> 方法抛出一个异常</li>
<li>时间到后线程进入就绪状态</li>
<li><span class="red">每个线程对象都有一个锁，sleep不会释放锁</span></li>
<li>一般用于模拟网络延时、倒计时</li>
</ul>
<h4 id="模拟网络延时"><a href="#模拟网络延时" class="headerlink" title="模拟网络延时"></a>模拟网络延时</h4><ul>
<li>见 <a href="#ticket">应用——火车票</a></li>
</ul>
<h4 id="模拟倒计时"><a href="#模拟倒计时" class="headerlink" title="模拟倒计时"></a>模拟倒计时</h4><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">import java.text.SimpleDateFormat;
import java.util.Date;

public class Main &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F; 定义时间变量
        Date time;

        while(true) &#123;
            try &#123;
                &#x2F;&#x2F; 获取系统当前时间
                time &#x3D; new Date(System.currentTimeMillis());
                &#x2F;&#x2F; 打印当前时间
                System.out.println(new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(time));
                &#x2F;&#x2F; 主线程休眠一秒
                Thread.sleep(1000);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

<h3 id="线程礼让（yield）"><a href="#线程礼让（yield）" class="headerlink" title="线程礼让（yield）"></a>线程礼让（yield）</h3><ul>
<li><span class="red">让当前线程从运行状态转为就绪状态，但线程礼让不一定成功</span>，因为线程被转换为就绪状态之后，CPU没事做，要找一个线程执行，可能还是会选择执行被转为就绪状态的线程</li>
</ul>
<ol>
<li><p>写一个线程类</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F; 礼让不一定成功，看CPU心情
public class YieldTest implements Runnable &#123;
    @Override
    public void run() &#123;
        System.out.println(Thread.currentThread().getName() + &quot;线程开始&quot;);
        &#x2F;&#x2F; 线程1礼让
        if (Thread.currentThread().getName().equals(&quot;线程1&quot;)) &#123;
            Thread.yield();
        &#125;
        System.out.println(Thread.currentThread().getName() + &quot;线程结束&quot;);
    &#125;
&#125;</code></pre></li>
<li><p>在main方法开启两个线程</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class Main &#123;
    public static void main(String[] args) &#123;
        YieldTest yieldTest &#x3D; new YieldTest();

        new Thread(yieldTest, &quot;线程1&quot;).start();
        new Thread(yieldTest, &quot;线程2&quot;).start();
    &#125;
&#125;</code></pre></li>
<li><p>得到如下结果：<br> 线程1礼让成功</p>
 <pre class="line-numbers language-none"><code class="language-none">线程1线程开始
线程2线程开始
线程1线程结束
线程2线程结束</code></pre>

<p> 另一种是线程1礼让失败，刷不出来，结果应该是这样的</p>
 <pre class="line-numbers language-none"><code class="language-none">线程1线程开始
线程1线程结束
线程2线程开始
线程2线程结束</code></pre></li>
</ol>
<h3 id="强制线程加入执行（join）"><a href="#强制线程加入执行（join）" class="headerlink" title="强制线程加入执行（join）"></a>强制线程加入执行（join）</h3><ul>
<li>使用 <code>Thread类成员.join();</code> 即可插队</li>
<li><span class="red">插队之后，其他线程为阻塞状态，需要等待插队的线程死亡后，才能继续执行</span></li>
</ul>
<ol>
<li><p>创建一个线程类</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class JoinTest implements Runnable &#123;
    @Override
    public void run() &#123;
        for (int i &#x3D; 1; i &lt;&#x3D; 50; i++) &#123;
            System.out.println(&quot;开水 开水 让一让 &quot; + i);
        &#125;
    &#125;
&#125;</code></pre></li>
<li><p>在主函数写一个主线程，并且决定什么时候子线程强制插队</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class Main &#123;
    public static void main(String[] args) &#123;
        JoinTest joinTest &#x3D; new JoinTest();

        &#x2F;&#x2F;
        Thread thread &#x3D; new Thread(joinTest);
        thread.start();

        &#x2F;&#x2F; 主线程
        for (int i &#x3D; 1; i &lt;&#x3D; 50; i++) &#123;
            &#x2F;&#x2F; 当主线程进行到第20次时，子线程强制插队
            if (i &#x3D;&#x3D; 20) &#123;
                try &#123;
                    thread.join();
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
            System.out.println(&quot;主线程：&quot; + i);
        &#125;
    &#125;
&#125;</code></pre></li>
<li><p>结果</p>
<blockquote>
<p>主线程在执行到第20次之前，两个线程执行顺序随机，20次时，子线程一直执行到结束，然后再轮到主线程执行至结束</p>
</blockquote>
</li>
</ol>
<h3 id="检测线程状态（state）"><a href="#检测线程状态（state）" class="headerlink" title="检测线程状态（state）"></a>检测线程状态（state）</h3><ul>
<li>使用 <code>Thread类成员.getState();</code> 获取线程状态，返回值为一个Thread.State类型的值，是Thread类里面的一个枚举类型</li>
</ul>
<h3 id="线程优先级（priority）"><a href="#线程优先级（priority）" class="headerlink" title="线程优先级（priority）"></a>线程优先级（priority）</h3><ul>
<li><span class="red">先设置优先级，再启动</span></li>
<li>线程优先级用数字表示，范围从1~10（默认为5），但线程优先级高不一定先跑，只是先跑的机会比较大</li>
<li>使用 <code>Thread类成员.getPriority();</code> 获取指定线程优先级</li>
<li>使用 <code>Thread类成员.setPriority(int i);</code> 设定线程优先级</li>
</ul>
<h3 id="守护线程（daemon）"><a href="#守护线程（daemon）" class="headerlink" title="守护线程（daemon）"></a>守护线程（daemon）</h3><ul>
<li><p>线程分为 <span class="red">用户线程</span> 和 <span class="red">守护线程</span></p>
</li>
<li><p><span class="red">虚拟机必须确保用户线程执行完毕，但不需要等待守护线程执行完毕，用户线程全部执行完毕，守护线程也就停止</span>，守护线程就是天使，天使守护人类，若人类灭绝，则天使也没有了存在的必要</p>
</li>
<li><p>功能：后台记录操作日志，监控内存，垃圾回收等</p>
</li>
<li><p>默认线程为用户线程，使用 <code>thread类成员.setDaemon(true);</code> 设定线程为守护线程</p>
</li>
<li><p><span class="red">若要设置守护线程，先设定，再启动</span></p>
</li>
</ul>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class God implements Runnable &#123;
    @Override
    public void run() &#123;
        while (true) &#123;
            System.out.println(&quot;众神之父今天会庇佑我们&quot;);
        &#125;
    &#125;
&#125;

public class You implements Runnable &#123;
    @Override
    public void run() &#123;
        &#x2F;&#x2F; 狗子扫描了365次
        for (int i &#x3D; 0; i &lt; 365; i++) &#123;
            System.out.println(&quot;正在检查这片区域&quot;);
        &#125;
        &#x2F;&#x2F; 直接送走
        System.out.println(&quot;我重伤倒地&quot;);
    &#125;
&#125;

public class Main &#123;
    public static void main(String[] args) &#123;
        God god &#x3D; new God();
        You you &#x3D; new You();

        &#x2F;&#x2F; 把众神之父扔进代理
        Thread thread &#x3D; new Thread(god);
        &#x2F;&#x2F; 他是守护线程
        thread.setDaemon(true);

        &#x2F;&#x2F; 众神之父起来干活
        thread.start();

        &#x2F;&#x2F; 把狗子扔进代理，狗子干活
        new Thread(you).start();
    &#125;
&#125;</code></pre>

<h2 id="线程同步-并发（重点-难点）"><a href="#线程同步-并发（重点-难点）" class="headerlink" title="线程同步 并发（重点 难点）"></a>线程同步 并发（重点 难点）</h2><ul>
<li>多个线程需要同时操作同一个资源</li>
</ul>
<h3 id="线程为什么不安全"><a href="#线程为什么不安全" class="headerlink" title="线程为什么不安全"></a>线程为什么不安全</h3><ul>
<li>憋说话，先看图<br><img src="https://img2018.cnblogs.com/blog/1328967/201906/1328967-20190605221210905-58853278.png" alt="主内存与工作内存1"></li>
</ul>
<p><img src="https://img-blog.csdn.net/20171201125413448?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenhoNDc2NzcxNzU2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="主内存与工作内存2"></p>
<blockquote>
<ol>
<li>各线程的工作内存不可共享，不可通讯</li>
<li>线程不可以直接读写主内存中的变量，而是把主内存中的变量拷贝到工作内存中进行操作（修改等），再将操作完的值覆写到主内存</li>
</ol>
</blockquote>
<br />

<ul>
<li><p>假设现在有两个线程要操作一个值，则可能发生如下情况：</p>
<ul>
<li>期望效果：每个线程对i加一次1<br /></li>
</ul>
<blockquote>
<p>线程1和线程2都看到了主内存中要操作的值为 i = 10</p>
</blockquote>
<p>  <a target="_blank" rel="noopener" href="https://imgtu.com/i/5MVJjH"><img src="https://z3.ax1x.com/2021/10/13/5MVJjH.png" alt="5MVJjH.png"></a></p>
<blockquote>
<p>线程1和线程2将主内存中的值拷贝到自己的工作内存中</p>
</blockquote>
<p>  <a target="_blank" rel="noopener" href="https://imgtu.com/i/5MVtud"><img src="https://z3.ax1x.com/2021/10/13/5MVtud.png" alt="5MVtud.png"></a></p>
<blockquote>
<p>两个线程对值进行操作之后覆写到主内存</p>
</blockquote>
<p>  <a target="_blank" rel="noopener" href="https://imgtu.com/i/5MVGge"><img src="https://z3.ax1x.com/2021/10/13/5MVGge.png" alt="5MVGge.png"></a></p>
<blockquote>
<p>主内存的值被覆写了两次 i = 11,而期望的值为 i = 12</p>
</blockquote>
<p>  <a target="_blank" rel="noopener" href="https://imgtu.com/i/5MV39O"><img src="https://z3.ax1x.com/2021/10/13/5MV39O.png" alt="5MV39O.png"></a></p>
</li>
</ul>
<h3 id="为什么使用sleep会增加问题的发生性"><a href="#为什么使用sleep会增加问题的发生性" class="headerlink" title="为什么使用sleep会增加问题的发生性"></a>为什么使用sleep会增加问题的发生性</h3><ul>
<li>因为sleep</li>
</ul>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul>
<li>处理多线程问题时，多个线程访问同一个对象，并且某些线程还想修改这个对象，这时候我们就需要一种等待机制，即线程同步，多个需要同时访问此对象的线程进入 这个对象的等待池 ，让线程形成队列，等待前面的线程使用完毕，下一个线程再使用</li>
</ul>
<h3 id="锁（synchronized）"><a href="#锁（synchronized）" class="headerlink" title="锁（synchronized）"></a>锁（synchronized）</h3><ul>
<li><p>经典厕所问题：</p>
<blockquote>
<p>100个人<span class="blue">（线程）</span>要使用<span class="blue">（操作）</span>1个厕所<span class="blue">（对象）</span><br>  若线程已经形成队列，却没有锁，仍然会出现问题：不安全，一个人进厕所之后没有把厕所锁上，其他人也能进</p>
</blockquote>
</li>
<li><p>锁，用于保证目前只会有一个人使用这个厕所<span class="blue">（只会有一个线程操作对象）</span></p>
</li>
<li><p><span class="red">每个线程对象都有一把 排他锁 ，独占资源，其他线程必须等待</span></p>
</li>
</ul>
<p><img src="https://z3.ax1x.com/2021/10/12/5nMCp8.png" alt="5nMCp8.png"></p>
<ul>
<li>牺牲性能问题：<ol>
<li>一个线程持有锁会导致其他所有需要此锁的线程挂起</li>
<li>在多线程竞争下，加锁，释放锁会导致比较多的上下文切换和调度延时，引起性能问题</li>
<li>若一个优先级高的线程等待一个优先级低的线程释放锁，就会导致性能倒置问题</li>
</ol>
</li>
</ul>
<h3 id="（锁预备）同一个实例的多线程与不同实例的多线程"><a href="#（锁预备）同一个实例的多线程与不同实例的多线程" class="headerlink" title="（锁预备）同一个实例的多线程与不同实例的多线程"></a>（锁预备）同一个实例的多线程与不同实例的多线程</h3><p>看下面例子</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class Main &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F; new出来多个MultipleThread对象，三个对象各有一个i，他们的i不共享
        MultipleThread multipleThread01 &#x3D; new MultipleThread();
        MultipleThread multipleThread02 &#x3D; new MultipleThread();
        MultipleThread multipleThread03 &#x3D; new MultipleThread();

        multipleThread01.start();
        multipleThread02.start();
        multipleThread03.start();

        &#x2F;&#x2F; new出来一个singleThread对象，将它交给三个代理，三个线程操作的是一个对象，只有那个对象的j可以操作，不存在多个j
        SingleThread singleThread &#x3D; new SingleThread();

        new Thread(singleThread, &quot;代理01&quot;).start();
        new Thread(singleThread, &quot;代理02&quot;).start();
        new Thread(singleThread, &quot;代理03&quot;).start();
    &#125;
&#125;

class MultipleThread extends Thread &#123;
    private int i;
    @Override
    public void run() &#123;
        System.out.println(++i);
    &#125;
&#125;

class SingleThread implements Runnable &#123;
    private int j;
    @Override
    public void run() &#123;
        System.out.println(++j);
    &#125;
&#125;</code></pre>

<pre class="line-numbers language-none"><code class="language-none">输出：
1
1
1
1
2
3</code></pre>

<h3 id="同步方法（synchronized方法）"><a href="#同步方法（synchronized方法）" class="headerlink" title="同步方法（synchronized方法）"></a>同步方法（synchronized方法）</h3><ul>
<li>在方法前加入 <code>synchronized</code> 修饰符，即可将方法变为同步方法。</li>
<li>同步方法一旦执行，就独占该锁，直到该方法返回才释放锁，后面被堵塞的线程才能获得这个锁，继续执行</li>
<li>缺陷：将一个功能强大的方法声明为 <code>synchronized</code> 会影响效率</li>
</ul>
<h4 id="同步方法应用——火车票优化"><a href="#同步方法应用——火车票优化" class="headerlink" title="同步方法应用——火车票优化"></a>同步方法应用——火车票优化</h4><ul>
<li><p>之前的火车票会出现票数负数，两个人抢到同一张票的情况</p>
</li>
<li><p>只需要在买票的 <code>buy()</code> 方法前加入 <code>synchronized</code> 修饰符，并且把模拟延时移动到 <code>run()</code> 方法中调用 <code>buy()</code> 方法后即可</p>
<blockquote>
<p>我们想要的效果是一个线程抢到了锁执行完之后就一边歇着去，把机会留给其他线程，而把 <code>sleep()</code> 写进同步方法会导致线程抱着锁睡觉，大大增加下一次也抢到锁的概率</p>
</blockquote>
</li>
<li><p>源代码中对象的关系是这样的：<br><img src="https://z3.ax1x.com/2021/10/15/5394iT.png" alt="5394iT.png"></p>
</li>
</ul>
<blockquote>
<p>注意：synchronized方法默认锁得是this，也就是Thread对象，在火车票案例中，由于使用了代理，执行同步方法<code>buy()</code> 的对象this指的是我们在主函数中new<br>出来的unsafeTicket对象，虽然我们有三条线程，但始终只有一个Runnable类的实例-&gt;unsafeTicket对象去操作 <code>buy()</code> 方法，因此对象锁适用于该案例</p>
</blockquote>
<ul>
<li>优化后的代码：</li>
</ul>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class Main &#123;
   public static void main(String[] args) &#123;
       UnsafeTicket unsafeTicket &#x3D; new UnsafeTicket();

       new Thread(unsafeTicket, &quot;我&quot;).start();
       new Thread(unsafeTicket, &quot;你&quot;).start();
       new Thread(unsafeTicket, &quot;黄牛&quot;).start();
   &#125;
&#125;

class UnsafeTicket implements Runnable &#123;
    &#x2F;&#x2F; 定义票
    private int ticketNumbers &#x3D; 10;
    &#x2F;&#x2F; 定义外部停止标志
    private boolean flag &#x3D; true;

    @Override
    public void run() &#123;
        while (flag) &#123;
            buy();
            try &#123;
                Thread.sleep(100);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;

    private synchronized void buy() &#123;
        &#x2F;&#x2F; 判断是否有票
        if (ticketNumbers &lt;&#x3D; 0) &#123;
            this.flag &#x3D; false;
            return;
        &#125; else &#123;
            System.out.println(this);
            System.out.println(Thread.currentThread().getName() + &quot;获得了&quot; + ticketNumbers-- + &quot;号票&quot;);
        &#125;
    &#125;

    public void stop() &#123;
        this.flag &#x3D; false;
    &#125;
&#125;</code></pre>

<h3 id="同步块（synchronized块）"><a href="#同步块（synchronized块）" class="headerlink" title="同步块（synchronized块）"></a>同步块（synchronized块）</h3><ul>
<li>方法里面需要修改的内容才需要锁，锁得太多会浪费资源，这时候就用到了同步块，其格式为：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">synchronized(锁) &#123;
    
&#125;</code></pre></li>
</ul>
<h4 id="同步块应用——银行优化"><a href="#同步块应用——银行优化" class="headerlink" title="同步块应用——银行优化"></a>同步块应用——银行优化</h4><ul>
<li>银行源代码：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class Main &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F; 新建卡
        Account account &#x3D; new Account(100, &quot;结婚基金&quot;);

        &#x2F;&#x2F; 新建卡的操作对象 Thread对象You
        Drawing you &#x3D; new Drawing(account, 50, &quot;你&quot;);
        &#x2F;&#x2F; 新建卡的操作对象 Thread对象girlFriend
        Drawing girlFriend &#x3D; new Drawing(account, 100, &quot;你妻子&quot;);

        you.start();
        girlFriend.start();
    &#125;
&#125;

&#x2F;&#x2F; 银行卡类，主要用于设定银行卡
class Account &#123;
    &#x2F;&#x2F; 卡里的钱
    private int money;
    &#x2F;&#x2F; 卡名
    private String name;

    public int getMoney() &#123;
        return this.money;
    &#125;

    public void setMoney(int money) &#123;
        this.money &#x3D; money;
    &#125;

    public String getName() &#123;
        return this.name;
    &#125;

    public void setName(String name) &#123;
        this.name &#x3D; name;
    &#125;

    public Account() &#123;

    &#125;

    public Account(int money, String name) &#123;
        this.setMoney(money);
        this.setName(name);
    &#125;
&#125;

&#x2F;&#x2F; 银行 模拟取钱 用于操作银行卡
class Drawing extends Thread &#123;
    private Account account;
    &#x2F;&#x2F; 取了多少钱
    private int drawingMoney;
    &#x2F;&#x2F; 手里现有多少钱
    private int nowMoney;

    public Drawing() &#123;

    &#125;

    public Drawing(Account account, int drawingMoney, String name) &#123;
        &#x2F;&#x2F; 设定的name为线程名，调用父类的Thread(name)方法设定线程名字
        super(name);
        this.account &#x3D; account;
        this.drawingMoney &#x3D; drawingMoney;
    &#125;

    @Override
    public void run() &#123;
        &#x2F;&#x2F; 够不够钱
        if (this.account.getMoney()-this.drawingMoney &lt; 0) &#123;
            System.out.println(Thread.currentThread().getName() + &quot;钱不够了&quot;);
            return;
        &#125; else &#123;
            try &#123;
                Thread.sleep(1000);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;

            &#x2F;&#x2F; 够钱就取钱
            this.account.setMoney(this.account.getMoney() - this.drawingMoney);

            &#x2F;&#x2F; 手里的钱
            this.nowMoney -&#x3D; this.drawingMoney;
            &#x2F;&#x2F; 打印一下账户余额
            System.out.println(account.getName() + &quot;余额为&quot; + this.account.getMoney());
            &#x2F;&#x2F; 打印手里的钱
            System.out.println(this.getName() + &quot;手里的钱&quot; + nowMoney);
        &#125;
    &#125;
&#125;</code></pre></li>
<li>很明显这里的对象关系是这样的：<br><img src="https://z3.ax1x.com/2021/10/15/5395JU.png" alt="5395JU.png"></li>
</ul>
<blockquote>
<p>在这里，锁 <code>run()</code> 方法是不行的，在 火车票优化-&gt;对象关系 中提到 <code>synchronized</code> 默认锁this，而这里两个 <code>run()</code> 方法从属于两个对象：<br>    ①第一个run的this -&gt; you<br>    ②第二个run的this -&gt; girlFriend<br><br /><br><span class="red">两个对象两把锁，互不干涉，一个对象上run这个厕所，并不影响另一个对象上另一个run的厕所</span><br>因此这里要锁的是account</p>
</blockquote>
<ul>
<li>优化后：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public void run() &#123;
    synchronized (account) &#123;
        &#x2F;&#x2F; 需要对account增删改查的代码
    &#125;
&#125;</code></pre></li>
</ul>
<h3 id="对象锁和类锁"><a href="#对象锁和类锁" class="headerlink" title="对象锁和类锁"></a>对象锁和类锁</h3><ul>
<li>对象锁（锁this）：只有使用同一实例的线程才会受锁的影响，多个实例调用同一方法则对象锁不适用</li>
<li>类锁是所有线程共享的锁，同一时刻只能有一个线程使用加了锁的方法和方法体，不管是否为同一实例</li>
</ul>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><ul>
<li>这样理解：CopyOnWrite ArrayList<br>  ArrayList：这个类本质上是创建一个数组，并且自带对该数组修改和增加的方法，还能保证多个线程对数组修改时的安全<br>  CopyOnWrite：在修改和增加数组时，会自动复制一份原来的数组然后再修改或增加</li>
</ul>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class Main &#123;
    &#x2F;* &lt;&gt;中的内容为ArrayList中存储的数据的类型
    因为他本质上也只是个数组，要指定里面存什么类型*&#x2F;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F; 
        CopyOnWriteArrayList&lt;String&gt; list &#x3D; new CopyOnWriteArrayList&lt;String&gt;();
        
        &#x2F;&#x2F; 创建1000条线程，每条线程往list里面写自己的线程名
        for (int i &#x3D; 0; i &lt; 1000; i++) &#123;
            new Thread(() -&gt; &#123;
                list.add(Thread.currentThread().getName());
            &#125;).start();
        &#125;
        &#x2F;&#x2F; 主线程先等等，否则主线程执行完，其他线程还没有执行完
        try &#123;
            Thread.sleep(3000);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        &#x2F;&#x2F; 最后打印list里面存了多少线程名
        System.out.println(list.size());
    &#125;</code></pre>

<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul>
<li>通俗的讲：死锁就是多个线程互相在不肯释放自己拥有的资源的前提下想要对方抱着的资源<br><img src="https://z3.ax1x.com/2021/10/16/5JTvtJ.png" alt="5JTvtJ.png"></li>
<li>产生死锁的四个条件：<ol>
<li>互斥条件：一个资源只能被一个进程占用（static）</li>
<li>请求与保持条件：一个进程请求资源而阻塞时，对已获得资源保持不放（抱着一个锁请求另外一个锁）</li>
<li>不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺（被抱着的锁不能强行放开）</li>
<li>循环等待条件：若干进程之间倾城一种头尾相接的循环等待资源关系（多个进程都在互相请求对方的锁，并且这个请求呈现一种像剪刀石头布一样的环形关系）</li>
</ol>
</li>
</ul>
<h4 id="死锁例子——面试官：说说死锁的概念"><a href="#死锁例子——面试官：说说死锁的概念" class="headerlink" title="死锁例子——面试官：说说死锁的概念"></a>死锁例子——面试官：说说死锁的概念</h4><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class DeadLock &#123;
    public static void main(String[] args) &#123;
        Interview jobSeeker &#x3D; new Interview();
        Interview interviewer &#x3D; new Interview();

        new Thread(jobSeeker, &quot;求职者&quot;).start();
        new Thread(interviewer, &quot;面试官&quot;).start();
    &#125;
&#125;

class Offer &#123;

&#125;

class DeadLockConception &#123;

&#125;

class Interview implements Runnable &#123;
    &#x2F;&#x2F; 双方各持有一个Offer和一个死锁概念
    static Offer offer &#x3D; new Offer();
    static DeadLockConception deadLockConception &#x3D; new DeadLockConception();

    @Override
    public void run() &#123;
        try &#123;
            Quarrel();
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    private void Quarrel() throws InterruptedException &#123;
        if (Thread.currentThread().getName().equals(&quot;面试官&quot;)) &#123;
            &#x2F;&#x2F; 面试官持有Offer
            synchronized (offer) &#123;
                System.out.println(&quot;请说说你对死锁的理解&quot;);
                &#x2F;&#x2F; 包着offer锁等待
                Thread.sleep(1000);
                &#x2F;&#x2F; 尝试从面试者获得死锁概念
                synchronized (deadLockConception) &#123;
                    System.out.println(&quot;面试官已经获得回答&quot;);
                &#125;
            &#125;
        &#125; else &#123;
            &#x2F;&#x2F; 求职者持有死锁概念
            synchronized (deadLockConception) &#123;
                System.out.println(&quot;你先给我offer，我再给你讲&quot;);
                &#x2F;&#x2F; 包着死锁概念等待
                Thread.sleep(1000);
                &#x2F;&#x2F; 尝试获取offer
                synchronized (offer) &#123;
                    System.out.println(&quot;面试者已获取offer&quot;);
                &#125;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<p><img src="https://z3.ax1x.com/2021/10/16/5JHCCj.png" alt="5JHCCj.png"></p>
<blockquote>
<p>静态变量是一个类中所有实例的共有变量，是一个类的变量，而不是实例的变量，若offer和deadLockConception不是静态变量，则每个Interview实例都会有一个offer和deadLockConception</p>
</blockquote>
<h3 id="Lock锁——ReentrantLock可重入锁"><a href="#Lock锁——ReentrantLock可重入锁" class="headerlink" title="Lock锁——ReentrantLock可重入锁"></a>Lock锁——ReentrantLock可重入锁</h3><ul>
<li><p>Lock锁可以显式加锁和释放锁</p>
</li>
<li><p>ReentrantLock类（可重入锁）实现了Lock接口，他拥有与synchronized相同的并发性和内存语义</p>
</li>
<li><p>每次只能有一个线程对Lock对象加锁，线程开始访问共享资源直线应先获得Lock对象</p>
<br /></li>
<li><p><span class="red">Lock锁只能锁代码块，当有线程执行该代码块时，会尝试获得代码块的锁</span></p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F; 定义锁
private final ReentrantLock lock &#x3D; new ReentrantLock();

&#x2F;&#x2F; 在执行代码块之前获取锁
lock.lock()
try &#123;
    &#x2F;&#x2F; 要锁住的代码块
&#125; finally &#123;
    &#x2F;&#x2F; 解锁
    lock.unlock();
&#125;</code></pre></li>
</ul>
<h2 id="线程协作"><a href="#线程协作" class="headerlink" title="线程协作"></a>线程协作</h2><ul>
<li>生产者消费者模型：<br><img src="https://z3.ax1x.com/2021/11/01/IPExTU.png" alt="生产者消费者模型"></li>
</ul>
<h3 id="管程法"><a href="#管程法" class="headerlink" title="管程法"></a>管程法</h3><p><img src="https://z3.ax1x.com/2021/10/31/Ip60H0.png" alt="管程法"></p>
<blockquote>
<p>生产者类：在唤醒时生产数据并放到缓冲区<br>消费者类：在唤醒时从缓冲区提取数据<br>数据类：就是数据，要存储的东西，可以是原本的数据类型，也可以新建一个类<br>数据缓冲区类：同时具有 缓冲数据 检测数据是否空/满 的功能 数据的送入和传出方法也写在这里</p>
</blockquote>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F; 主方法
public class Main &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F; 新建缓冲区，定义大小
        DataPackagesBuffer dataPackagesBuffer &#x3D; new DataPackagesBuffer(15);

        &#x2F;&#x2F; 新建生产者消费者
        Producer producer &#x3D; new Producer(dataPackagesBuffer);
        Consumer consumer &#x3D; new Consumer(dataPackagesBuffer);

        new Thread(producer).start();
        new Thread(consumer).start();
    &#125;
&#125;

&#x2F;&#x2F; 数据类
class DataPackage &#123;
    int packageId;

    public DataPackage(int packageId) &#123;
        this.packageId &#x3D; packageId;
    &#125;
&#125;

&#x2F;&#x2F; 数据缓冲区类
class DataPackagesBuffer &#123;
    DataPackage[] dataPackagesBuffer;
    int count &#x3D; 0;

    public DataPackagesBuffer(int length) &#123;
        &#x2F;&#x2F; 定义缓冲区大小
        dataPackagesBuffer &#x3D; new DataPackage[length];
    &#125;

    public synchronized void send(DataPackage dataPackage) &#123;
        &#x2F;&#x2F; 如果容器满了，生产者等待（只有生产者会调用这个方法，因此当前获取到这个对象的锁的一定是生产者）
        while (count &#x3D;&#x3D; dataPackagesBuffer.length) &#123;
            &#x2F;&#x2F; 使当前访问该对象的线程等待
            try &#123;
                this.wait();
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        &#x2F;&#x2F; 若容器没有满，放入数据，唤醒所有等待线程（其实只有消费者一个等待线程）
        dataPackagesBuffer[count] &#x3D; dataPackage;
        count++;
        this.notifyAll();
    &#125;

    public synchronized DataPackage receive() &#123;
        &#x2F;&#x2F; 用于暂存接收的数据
        DataPackage dataPackage;

        &#x2F;&#x2F; 若容器为空，消费者等待（只有消费者会调用这个方法，因此当前获得这个对象的锁的一定是消费者）
        while (count &#x3D;&#x3D; 0) &#123;
            try &#123;
                this.wait();
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        &#x2F;&#x2F; 若容器不为空，取出数据，唤醒所有等待线程（其实只有生产者一个等待线程）
        count--;
        dataPackage &#x3D; dataPackagesBuffer[count];
        this.notifyAll();
        return dataPackage;
    &#125;
&#125;

&#x2F;&#x2F; 生产者类
class Producer implements Runnable &#123;
    &#x2F;&#x2F; 将生产者与缓冲区建立连接
    DataPackagesBuffer dataPackagesBuffer;

    public Producer(DataPackagesBuffer dataPackagesBuffer) &#123;
        this.dataPackagesBuffer &#x3D; dataPackagesBuffer;
    &#125;

    @Override
    public void run() &#123;
        for (int i &#x3D; 1; i &lt;&#x3D; 60; i++) &#123;
            System.out.println(&quot;正在送出第&quot; + i + &quot;个数据包&quot;);
            dataPackagesBuffer.send(new DataPackage(i));
        &#125;
    &#125;
&#125;

&#x2F;&#x2F; 消费者类
class Consumer implements Runnable &#123;
    &#x2F;&#x2F; 将消费者与缓冲区建立连接
    DataPackagesBuffer dataPackagesBuffer;

    public Consumer(DataPackagesBuffer dataPackagesBuffer) &#123;
        this.dataPackagesBuffer &#x3D; dataPackagesBuffer;
    &#125;

    @Override
    public void run() &#123;
        for (int i &#x3D; 1; i &lt;&#x3D; 60; i++) &#123;
            System.out.println(&quot;已接收到第&quot; + dataPackagesBuffer.receive().packageId + &quot;号数据包&quot;);
        &#125;
    &#125;
&#125;</code></pre>

<h3 id="信号灯法（缓存为1的管程法）"><a href="#信号灯法（缓存为1的管程法）" class="headerlink" title="信号灯法（缓存为1的管程法）"></a>信号灯法（缓存为1的管程法）</h3><p><img src="https://z3.ax1x.com/2021/11/01/IP1oz8.png" alt="信号灯法"></p>
<blockquote>
<p>寄件人类：在唤醒时生产数据并放到驿站<br>收件人类：在唤醒时从驿站提取数据<br>驿站类：同时具有 缓冲一个数据 检测驿站是否有内容 的功能 寄件和收件的方法也写在这里</p>
</blockquote>
<blockquote>
<p>注意：因为信号灯法使用存一取一的方式，因此将提取数据的输出移出同步方法外可能会造成存取输出混乱（两行同时出现寄件）</p>
</blockquote>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class Main &#123;
    public static void main(String[] args) &#123;
        PostStation postStation &#x3D; new PostStation();

        new Addressee(postStation).start();
        new Sender(postStation).start();
    &#125;
&#125;

&#x2F;&#x2F; 一个只能放一个快递的驿站
class PostStation &#123;
    &#x2F;*  有快递吗？
        没有：收件人等待
        有：寄件人等待
     *&#x2F;
    boolean flag &#x3D; false;

    &#x2F;&#x2F; 寄出去的内容（也可以是新建的一个类）
    int content;

    &#x2F;&#x2F; 寄件
    public synchronized void send(int content) &#123;
        &#x2F;&#x2F; 若已经有一个快递，寄件人等待
        while (flag) &#123;
            try &#123;
                this.wait();
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        &#x2F;&#x2F; 若没有快递，寄快递（写入内容），更新标志位，通知收件人
        this.content &#x3D; content;
        System.out.println(&quot;寄出一个快递，内容为：&quot; + this.content);
        this.flag &#x3D; true;
        this.notifyAll();
    &#125;

    &#x2F;&#x2F; 收件
    public synchronized void receive() &#123;
        &#x2F;&#x2F; 若没有快递，收件人等待
        while (!flag) &#123;
            try &#123;
                this.wait();
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        &#x2F;&#x2F; 若有快递，接收快递（返回值或直接输出），更新标志位
        System.out.println(&quot;接收到了快递，内容为：&quot; + this.content);
        this.flag &#x3D; false;
        this.notifyAll();
    &#125;
&#125;

&#x2F;&#x2F; 寄件人类
class Sender extends Thread &#123;
    &#x2F;&#x2F; 与驿站建立联系
    PostStation postStation;

    public Sender(PostStation postStation) &#123;
        this.postStation &#x3D; postStation;
    &#125;

    @Override
    public void run() &#123;
        for (int i &#x3D; 1; i &lt;&#x3D; 30; i++) &#123;
            postStation.send(i);
        &#125;
    &#125;
&#125;

&#x2F;&#x2F; 收件人类
class Addressee extends Thread &#123;
    &#x2F;&#x2F; 与驿站建立联系
    PostStation postStation;

    public Addressee(PostStation postStation) &#123;
        this.postStation &#x3D; postStation;
    &#125;

    @Override
    public void run() &#123;
        for (int i &#x3D; 1; i &lt;&#x3D; 30; i++) &#123;
            postStation.receive();
        &#125;
    &#125;
&#125;</code></pre>

<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><ul>
<li><p>经常创建和销毁线程会使用大量的资源从而影响性能</p>
</li>
<li><p>我们可以提前创建好多个线程，放入线程池中，使用的时候获取线程，使用完就放回线程池，实现线程的重复利用</p>
</li>
<li><p>线程池的好处：</p>
<ol>
<li>提高响应速度</li>
<li>降低资源损耗</li>
<li>便于线程管理<br /></li>
</ol>
</li>
<li><p>涉及两个工具类：</p>
<ol>
<li>ExecutorService: 线程池接口，常见子类ThreadPoolExecutor</li>
<li>Executors: 工具类、线程池工厂类，用于创建并返回不同类型的线程池</li>
</ol>
</li>
</ul>
<ol>
<li><p>创建线程池</p>
<ul>
<li>使用 <code>ExecutorService service = Executors.newFixedThreadPool(线程池大小);</code> 创建线程池</li>
</ul>
</li>
<li><p>提交线程</p>
<ul>
<li>使用 <code>ExecutorService接口的对象.execute(线程对象);</code> 向线程池里面扔线程</li>
</ul>
</li>
<li><p>关闭连接</p>
<ul>
<li>使用 <code>ExecutorService接口的对象.shutdown();</code> 销毁线程池<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public static void main(String[] args) &#123;
    &#x2F;&#x2F; 创建线程池
    &#x2F;&#x2F; newFixedThreadPool: 参数为线程池大小
    ExecutorService service &#x3D; Executors.newFixedThreadPool(10);

    &#x2F;&#x2F; 丢线程进去，执行Runnable接口的实现类
    service.execute(new MyThread());
    service.execute(new MyThread());
    service.execute(new MyThread());

    &#x2F;&#x2F; 关闭连接
    service.shutdown();
&#125;</code></pre></li>
</ul>
</li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/09/20/Idea%E5%85%B3%E4%BA%8E%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E7%9A%84%E8%AE%BE%E5%AE%9A/" rel="prev" title="Idea关于代码格式的设定">
                  <i class="fa fa-chevron-left"></i> Idea关于代码格式的设定
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/11/07/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" rel="next" title="Java网络编程">
                  Java网络编程 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Loliconkelvin</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdn.jsdelivr.net/npm/ribbon.js@1.0.2/dist/ribbon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.24.1/components/prism-core.min.js" integrity="sha256-dz05jjFU9qYuMvQQlE6iWDtNAnEsmu6uMb1vWhKdkEM=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.24.1/plugins/autoloader/prism-autoloader.min.js" integrity="sha256-sttoa+EIAvFFfeeIkmPn8ypyOOb6no2sZ2NbxtBXgqU=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.24.1/plugins/line-numbers/prism-line-numbers.min.js" integrity="sha256-K837BwIyiXo5k/9fCYgqUyA14bN4/Ve9P2SIT0KmZD0=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
