<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"loliconkelvin.github.io","root":"/","images":"/images","scheme":"Pisces","version":"8.7.1","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":true,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content=".keyword{     color: red; }   计算机二级——JAVA">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机二级——JAVA">
<meta property="og:url" content="https://loliconkelvin.github.io/2022/01/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BA%8C%E7%BA%A7%E2%80%94%E2%80%94JAVA/index.html">
<meta property="og:site_name" content="萝莉控的小窝">
<meta property="og:description" content=".keyword{     color: red; }   计算机二级——JAVA">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s4.ax1x.com/2022/02/13/HBs57V.png">
<meta property="og:image" content="https://s4.ax1x.com/2022/02/15/Hc6CR0.png">
<meta property="og:image" content="https://s4.ax1x.com/2022/02/15/Hc69Gq.png">
<meta property="og:image" content="https://s4.ax1x.com/2022/02/15/Hc63LD.png">
<meta property="og:image" content="https://s4.ax1x.com/2022/02/15/Hc6RWq.png">
<meta property="og:image" content="https://s4.ax1x.com/2022/02/16/HfOPr6.png">
<meta property="og:image" content="https://s4.ax1x.com/2022/02/16/HhKxxA.png">
<meta property="og:image" content="https://s4.ax1x.com/2022/02/23/bP1LYd.png">
<meta property="og:image" content="https://s4.ax1x.com/2022/02/23/bP1qFH.png">
<meta property="og:image" content="https://s4.ax1x.com/2022/02/23/bPJRHK.jpg">
<meta property="og:image" content="https://s4.ax1x.com/2022/02/23/bPJ2B6.jpg">
<meta property="og:image" content="https://s4.ax1x.com/2022/02/23/bPJgnx.jpg">
<meta property="article:published_time" content="2022-01-18T06:16:38.000Z">
<meta property="article:modified_time" content="2022-02-23T15:00:29.277Z">
<meta property="article:author" content="Loliconkelvin">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s4.ax1x.com/2022/02/13/HBs57V.png">


<link rel="canonical" href="https://loliconkelvin.github.io/2022/01/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BA%8C%E7%BA%A7%E2%80%94%E2%80%94JAVA/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://loliconkelvin.github.io/2022/01/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BA%8C%E7%BA%A7%E2%80%94%E2%80%94JAVA/","path":"2022/01/18/计算机二级——JAVA/","title":"计算机二级——JAVA"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>计算机二级——JAVA | 萝莉控的小窝</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">萝莉控的小窝</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JAVA%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">1.</span> <span class="nav-text">JAVA的特点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="nav-number">2.</span> <span class="nav-text">JAVA虚拟机</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JDK%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="nav-number">3.</span> <span class="nav-text">JDK控制台常用指令</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JAVA%E6%BA%90%E6%96%87%E4%BB%B6%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="nav-number">4.</span> <span class="nav-text">JAVA源文件的命名规则</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JAVA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8EJAVA-Applet"><span class="nav-number">5.</span> <span class="nav-text">JAVA应用程序与JAVA Applet</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JAVA%E6%A0%87%E8%AF%86%E7%AC%A6%E4%B8%8E%E5%85%B6%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="nav-number">6.</span> <span class="nav-text">JAVA标识符与其命名规则</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JAVA%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">7.</span> <span class="nav-text">JAVA关键字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JAVA%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">8.</span> <span class="nav-text">JAVA数据类型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JAVA%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">9.</span> <span class="nav-text">JAVA运算符</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-number">10.</span> <span class="nav-text">流程控制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">11.</span> <span class="nav-text">面向对象</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81"><span class="nav-number">12.</span> <span class="nav-text">继承与多态</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E7%B1%BB%E7%89%B9%E6%80%A7"><span class="nav-number">13.</span> <span class="nav-text">高级类特性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">14.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%92%8C%E6%96%AD%E8%A8%80"><span class="nav-number">15.</span> <span class="nav-text">异常和断言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81"><span class="nav-number">16.</span> <span class="nav-text">输入输出流</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-number">17.</span> <span class="nav-text">线程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#awt%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2"><span class="nav-number">18.</span> <span class="nav-text">awt图形界面</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#swing%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2"><span class="nav-number">19.</span> <span class="nav-text">swing图形界面</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Applet%E5%BA%94%E7%94%A8"><span class="nav-number">20.</span> <span class="nav-text">Applet应用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9B%86%E5%90%88"><span class="nav-number">21.</span> <span class="nav-text">集合</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B"><span class="nav-number">22.</span> <span class="nav-text">泛型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">23.</span> <span class="nav-text">树与二叉树</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Loliconkelvin"
      src="/uploads/avatar.png">
  <p class="site-author-name" itemprop="name">Loliconkelvin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">38</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Loliconkelvin" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Loliconkelvin" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:loliconkelvin@gmail.com" title="E-Mail → mailto:loliconkelvin@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



          </div>
        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://loliconkelvin.github.io/2022/01/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BA%8C%E7%BA%A7%E2%80%94%E2%80%94JAVA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Loliconkelvin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萝莉控的小窝">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机二级——JAVA
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-01-18 14:16:38" itemprop="dateCreated datePublished" datetime="2022-01-18T14:16:38+08:00">2022-01-18</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-02-23 23:00:29" itemprop="dateModified" datetime="2022-02-23T23:00:29+08:00">2022-02-23</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <style>
.keyword{
    color: red;
}
</style>

<p>计算机二级——JAVA</p>
<span id="more"></span>

<h1 id="JAVA的特点"><a href="#JAVA的特点" class="headerlink" title="JAVA的特点"></a>JAVA的特点</h1><hr>
<ol>
<li><span class="keyword">简单性</span></li>
<li><span class="keyword">面向对象</span></li>
<li><span class="keyword">分布式处理</span></li>
<li><span class="keyword">可靠性与安全性</span></li>
<li><span class="keyword">平台无关性</span></li>
<li><span class="keyword">可移植性</span></li>
<li><span class="keyword">高性能</span></li>
<li><span class="keyword">多线程</span></li>
<li><span class="keyword">动态性</span></li>
</ol>
<h1 id="JAVA虚拟机"><a href="#JAVA虚拟机" class="headerlink" title="JAVA虚拟机"></a>JAVA虚拟机</h1><hr>
<ul>
<li>JAVA虚拟机运行代码时会执行的操作有：<ol>
<li><span class="keyword">加载代码</span></li>
<li><span class="keyword">校验代码</span></li>
<li><span class="keyword">执行代码</span></li>
</ol>
</li>
</ul>
<blockquote>
<p>tips: JAVA的编译并不在虚拟机下执行，而在ide（集成开发环境）中执行，编译的过程为：JAVA源程序(.JAVA) → 字节码文件(.class)</p>
</blockquote>
<ul>
<li>JAVA的字节码文件再不同的操作系统下会经过不同的JAVA虚拟机进行字节码解释，因此<span class="keyword">JAVA的字节码文件与操作系统分离</span></li>
</ul>
<h1 id="JDK控制台常用指令"><a href="#JDK控制台常用指令" class="headerlink" title="JDK控制台常用指令"></a>JDK控制台常用指令</h1><hr>
<ol>
<li>javac：JAVA编译器，将JAVA源文件(.java)编译成字节码文件(.class)</li>
<li>java: JAVA解释器，执行字节码文件</li>
<li>jdb：JAVA调试器，用于调试JAVA程序</li>
<li>javap：JAVA反编译器，将字节码文件(.class)还原回方法和变量</li>
<li>javadoc：文档生成器，用于生成该类的帮助文档</li>
<li>appletviewer：applet解释器，用于解释已经转换为字节码文件(.class)的JAVA小应用程序</li>
</ol>
<h1 id="JAVA源文件的命名规则"><a href="#JAVA源文件的命名规则" class="headerlink" title="JAVA源文件的命名规则"></a>JAVA源文件的命名规则</h1><hr>
<ol>
<li>源文件仅一个类：取该类名</li>
<li>源文件有多个类且无public类：取任一类名</li>
<li>源文件有多个类且有一个public类：取public类名</li>
<li>源文件有多个public类：<span class="keyword">源文件不允许有多个public类</span></li>
</ol>
<h1 id="JAVA应用程序与JAVA-Applet"><a href="#JAVA应用程序与JAVA-Applet" class="headerlink" title="JAVA应用程序与JAVA Applet"></a>JAVA应用程序与JAVA Applet</h1><hr>
<ul>
<li><p>JAVA应用程序</p>
<ol>
<li>是一个完整的应用程序</li>
<li>可以独立运行</li>
<li>运行于JVM（JAVA虚拟机）上</li>
<li>必须有main方法</li>
</ol>
</li>
<li><p>JAVA applet</p>
<ol>
<li>不是一个完整的应用程序，是一个框架程序中的一个模块</li>
<li>运行于浏览器上</li>
<li>可以没有main方法</li>
</ol>
</li>
</ul>
<h1 id="JAVA标识符与其命名规则"><a href="#JAVA标识符与其命名规则" class="headerlink" title="JAVA标识符与其命名规则"></a>JAVA标识符与其命名规则</h1><hr>
<ul>
<li><p>什么是标识符：<br>  变量名、类名、方法名和接口名等都称为标识符</p>
<br /></li>
<li><p><span class="keyword">标识符的命名规则：<br>  字母、下划线和美元符号$开头，后接字母、数字、下划线、数字</span><br>  <strong>禁止数字开头</strong></p>
<br /></li>
<li><p>标识符命名约定:</p>
<ol>
<li>常量：全大写，下滑线分割单词</li>
<li>变量用首字母大写的驼峰命名法</li>
<li>类名用首字母大写的驼峰命名法</li>
</ol>
</li>
</ul>
<h1 id="JAVA关键字"><a href="#JAVA关键字" class="headerlink" title="JAVA关键字"></a>JAVA关键字</h1><hr>
<ul>
<li>什么是关键字：<br>  JAVA自身所使用的标识符，他们不能被用户所使用</li>
</ul>
<h1 id="JAVA数据类型"><a href="#JAVA数据类型" class="headerlink" title="JAVA数据类型"></a>JAVA数据类型</h1><hr>
<ul>
<li>对于不同操作系统，JAVA各基本数据类型所占的位固定</li>
</ul>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">位长</th>
</tr>
</thead>
<tbody><tr>
<td align="center">boolean</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">byte</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">16</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">16</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">32</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">64</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">32</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">64</td>
</tr>
</tbody></table>
<blockquote>
<p>浮点型常量的表示：<br>    1. 可以使用数字+小数点<br>    2. 可以使用科学计数法，如23e-2，表示23*(10^-2) </p>
</blockquote>
<blockquote>
<p>计算当中涉及byte，char，short，会自动转换为int进行计算，结果也必定为int，若需将结果赋回给byte，char，short类型的变量，使用强制类型转换</p>
</blockquote>
<h1 id="JAVA运算符"><a href="#JAVA运算符" class="headerlink" title="JAVA运算符"></a>JAVA运算符</h1><hr>
<p>考点：</p>
<ul>
<li><p>自增自减的前置后置用法</p>
<ol>
<li>前置：先自增/自减再取值</li>
<li>先将值取出给另一变量或表达式，再自增/自减</li>
</ol>
</li>
<li><p>字符型数据的运算（char要转为int计算，结果为int）</p>
</li>
<li><p>逻辑运算符：与(&amp;&amp;)或(||)非(!)</p>
</li>
<li><p>唯一运算符的计算（左移乘2，右移除2） </p>
</li>
<li><p>优先级</p>
<blockquote>
<p>如：int x = 1, y= 2, n = 10则<br>  x+y+(–n)*(x&gt;y&amp;&amp;x&gt;0?(x+1):y)</p>
  <br />
  是等效于 x+y+(--n)*((x>y && x>0)?(x+1):y)
  因此结果为17
</blockquote>
<blockquote>
<p>又如：下面运算符优先级最高的是（）<br>  A.+=<br>  B.==<br>  C.&amp;&amp;<br>  D.++</p>
</blockquote>
</li>
</ul>
<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><hr>
<ul>
<li><p>流程控制的三种基本结构：</p>
<ol>
<li>顺序结构</li>
<li>分支（选择）结构</li>
<li>循环结构</li>
</ol>
</li>
<li><p>判断语句常用例：闰年的判断（该年份可以整除4，但不可以整除100，或 该年份可以整除400）</p>
</li>
<li><p>分支选择语句：case后面的值不能相等，break的作用</p>
</li>
<li><p>三个跳转语句：break continue return</p>
</li>
<li><p>带标号的break语句</p>
<pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">loop: for(int i &#x3D; 0; i &lt; 4; i++) &#123;
    for(int j &#x3D; 0; j &lt; 4; j++) &#123;
        if(n &#x3D;&#x3D; 10) &#123;
            break loop;
        &#125;
    &#125;
&#125;
&#x2F;&#x2F; 带标号的break会直接跳出标记的层次
&#x2F;&#x2F; 该break会直接结束这两个互相嵌套的循环</code></pre></li>
<li><p>带标号的continue语句：表示结束被标记嵌套循环的本轮循环，开始被标记嵌套的下一轮循环</p>
</li>
</ul>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><hr>
<ul>
<li>类修饰符：<ol>
<li>public：公共类，若不写public，则为包访问</li>
<li>abstract：抽象类，没有实例，只能用于被子类继承</li>
<li>final：最后类，禁止被继承<blockquote>
<p>Object类是所有类的父类</p>
</blockquote>
</li>
</ol>
</li>
<li>接口的格式：（可实现多个接口）  <pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">public class dog implements animal, pet &#123;

&#125;</code></pre></li>
<li>类的命名规则：首字母大写的驼峰命名法<br /></li>
</ul>
<hr>
<ul>
<li><p>成员变量 修饰符</p>
<ul>
<li><p>访问范围：</p>
<ol>
<li>public：任何类都可以访问</li>
<li>protected：本类与同包的类可访问，其所有子类（不管是否同包）都可以访问</li>
<li>无修饰符（default）：同一个包的类可以访问</li>
<li>private：仅本类可访问<blockquote>
<p>属性与方法的访问范围不可超过类的访问范围，若一个类访问范围是default，则其成员变量与方法即使为public也仅为包访问</p>
</blockquote>
</li>
</ol>
</li>
<li><p>作用域：</p>
<ol>
<li>无修饰符：成员变量，是实例的属性<blockquote>
<p>生存期：依赖于实例，实例被创建后才有该变量/方法</p>
</blockquote>
</li>
<li>static：类变量，是整个类的属性，可以以类名为前缀调用<blockquote>
<p>生存期：不依赖于实例，只要类被加载，static变量/方法就会被生成</p>
</blockquote>
</li>
</ol>
</li>
<li><p>常量：</p>
<ol>
<li>final：常量<br /></li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>方法 修饰符</p>
<ul>
<li><p>访问范围：</p>
<ol>
<li>public</li>
<li>protected</li>
<li>private</li>
</ol>
</li>
<li><p>作用域：</p>
<ol>
<li>无</li>
<li>static：静态方法，独立于对象<blockquote>
<p>静态方法可以调用其他静态方法<br>静态方法只能访问静态变量<br>静态方法内不能出现this（表示该对象）与super（表示该对象的父类对象）</p>
</blockquote>
</li>
</ol>
</li>
<li><p>禁止重写：</p>
<ol>
<li>final：该方法不能被子类重写（@override）</li>
</ol>
</li>
<li><p>抽象的：</p>
<ol>
<li>abstract：该方法为抽象方法，无方法体，子类必须重写该方法<blockquote>
<p>抽象方法必须在抽象类中<br>抽象方法中禁止出现this与super，抽象方法存在时，实例不一定存在</p>
</blockquote>
</li>
</ol>
</li>
<li><p>本地方法：</p>
<ol>
<li>native：用其他语言编写的方法在Java中成为本地方法</li>
</ol>
</li>
<li><p>同步的：</p>
<ol>
<li>synchronized：该方法为同步方法<br /></li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>方法的重载：指多个同名不同参的方法（返回值与方法名也可不同但不作为方法重载的特点）</p>
<blockquote>
<p>注意：重载的方法的访问范围修饰符可以扩大但不能缩小</p>
</blockquote>
</li>
<li><p>方法的参数：方法的参数可以与成员变量名相同，若出现这种情况，而在方法中又出现这个参数名，则该名字表示的是参数而不是成员变量</p>
<blockquote>
<p>若要使用成员变量，使用this.成员变量</p>
</blockquote>
</li>
<li><p>方法体内的变量：</p>
<ol>
<li>null变量：空变量必须指代一个对象的实例为空（还没new出来）<blockquote>
<p>如: Stack stack = null</p>
</blockquote>
</li>
<li>this.变量：指当前实例的成员变量</li>
<li>super.变量：指当前实例的父类实例的成员变量</li>
<li>局部变量：仅能在方法内部使用<br /></li>
</ol>
</li>
</ul>
<hr>
<ul>
<li><p>包</p>
<ul>
<li>java.lang包会在程序运行时自动引入</li>
<li>导包：import</li>
</ul>
</li>
<li><p>构造方法</p>
<ul>
<li>用于给实例初始化</li>
<li>构造方法必须满足以下条件：<ol>
<li>名称与类名完全相同</li>
<li>无返回值类型（这里的无指的是不写返回值修饰符，而不是void）</li>
<li>用new关键字调用</li>
</ol>
</li>
<li>允许一个类有多个构造方法（方法重载）<blockquote>
<p>注意：若用户自行定义了一个有参构造方法，则磨人的无参构造会失效，需要再写一个无参构造，并且无参的代码通常在有参的前面</p>
</blockquote>
</li>
<li>调用重载的构造方法：使用this调用：  <pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">RunDemo() &#123;

&#125;

RunDemo(String name) &#123;
    this.username &#x3D; name;
&#125;

RunDemo(String name, String pwd) &#123;
    &#x2F;&#x2F; 调用含有一个参数的构造方法，传入参数name
    this(name);
    this.password &#x3D; pwd;
&#125;</code></pre></li>
</ul>
</li>
</ul>
<br />
---

<ul>
<li>Object类常用方法<ol>
<li>toString()：返回值为代表这个实例信息的字符串，形如：：类名@代表实例的数字序列</li>
<li>equals(Object obj)：用于比较当前对象和形参对象是否相同<blockquote>
<p>注意：比较字符串内容是否相同必须使用到这个方法，否则系统将比较两个字符串的指针，结果必为false</p>
</blockquote>
</li>
<li>hashcode()：返回当前实例的哈希值</li>
<li>getClass()：返回当前对象所对应的Class对象</li>
<li>clone()：产生一个当前对象的复制，并返回复制的对象</li>
<li>finalize()：把对象从内存中清除，由垃圾回收机制自动调用</li>
</ol>
</li>
</ul>
<br />
---

<ul>
<li><p>Class类</p>
<ul>
<li>每个类的加载都伴随着一个Class类的对象，隐藏在字节码文件中，用于描述该类的属性，由JAVA编译器自动生成</li>
<li>作用：实现动态性，在程序执行期间动态加载新的类</li>
</ul>
</li>
<li><p>Class类常用方法</p>
<ol>
<li>Class.forName(String className)：该方法为静态方法，使用类名Class直接调用，返回被加载的类所对应的Class对象（看上面，每个类被加载的时候会自动产生一个对应的Class对象），如<code>Class t = Class.forName(&quot;java.lang.Thread&quot;);</code></li>
</ol>
</li>
</ul>
<br />
---

<ul>
<li><p>String类（字符串常量）</p>
<ul>
<li>使用java.lang包中的String类来创建的一个字符串变量  <pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">String s &#x3D; new String(&quot;Hello&quot;);</code></pre></li>
</ul>
</li>
<li><p>String类除正常创建外的两种常用构造方法</p>
<ol>
<li>String(char a[])：用字符数组创建<br> String(char a[], int startIndex, iont count)：提取字符串数组a中以编号startIndex开头的总共count个字符<blockquote>
<p>如：</p>
<pre><code> char c[] = &#123;&#39;s&#39;, &#39;t&#39;, &#39;b&#39;, &#39;u&#39;, &#39;s&#39;, &#39;n&#39;&#125;;
 String s = new String(c, 2, 3);
 // 则字符串s为bus
</code></pre>
</blockquote>
</li>
<li><code>String s = &quot;Hello&quot;;</code> 引用字符串常量对象</li>
</ol>
</li>
<li><p>注意：用 <code>==</code> 比较两个字符串时，使用正常方法会导致两个字符串的对象不一样，而使用 引用字符串常量对象 则两个字符串对象相同：</p>
  <pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">String s1 &#x3D; new String(&quot;Hello&quot;);
String s2 &#x3D; new String(&quot;Hello&quot;);
system.out.println(s1 &#x3D;&#x3D; s2);
&#x2F;&#x2F; 输出为假，因为s1与s2是两个不同的实例（在内存中不同位置），即使其内容相同
system.out.println(s1.equals(s2));
&#x2F;&#x2F; 输出为真，equals用于比较两个字符串的内容

String s3 &#x3D; &quot;Hello&quot;;
String s4 &#x3D; &quot;Hello&quot;;
system.out.println(s3 &#x3D;&#x3D; s4);
&#x2F;&#x2F; 输出为真，因为s3与s4指向同一个字符串常量（在内存中相同位置）</code></pre></li>
<li><p>String类常用方法</p>
<ol>
<li>length()：返回字符串长度</li>
<li>indexOf(String s)：在调用该方法的字符串中从头开始检索字符串s，返回首次出现字符串s的位置，没有出现返回-1<br> indexOf(String s, int startIndex)：从第startIndex位开始检索<br> lastIndexOf(String s)：返回最后出现字符串s的位置</li>
<li>charAt(int index)：返回调用该方法的字符串的第index位的字符</li>
<li>replace(char oldChar, cahr newChar)：使调用该方法的字符串中的oldChar字符替换为newChar字符</li>
<li>getChars(int start, int end, char c[], int offset)：将调用该方法的字符串从start开始至(end-1)结束的字符复制到字符数组c中，复制时，会以字符数组c的第offset位开始放</li>
<li>toCharArray()：将调用该方法的字符串转换为字符数组</li>
<li>getBytes()：将调用该字符串的数组转换为字节数组，每个字符都存储为字节编码</li>
<li>equals(String s)：比较两个字符串的内容</li>
<li>equalsIgnoreCase()：比较两个字符串的内容，忽略大小写</li>
<li>startWith(String s)：判断调用该方法的字符串是否含有字符串s作为前缀<br>endWith(String s)：判断调用该方法的字符串是否含有字符串s作为后缀</li>
<li>subString(int start)：将该字符串从第start位开始截取到最后<br>subString(int Start, int end)：将字符串从start处截取到(end-1)处</li>
<li>toUpperCase()：返回该字符串的大写形式<br>toLowerCase()：返回该字符串的小写形式</li>
<li>trim()：去掉字符串开头与结尾的空格</li>
</ol>
</li>
</ul>
<br />
---

<ul>
<li><p>StringBuffer类（字符串变量）</p>
<ul>
<li>StringBuffer类提供一个可变的字符串序列</li>
</ul>
</li>
<li><p>StringBuffer类常用构造方法</p>
<ol>
<li>StringBuffer()：无参构造，创建一个空的StringBuffer对象，初始容量为16个字符</li>
<li>StringBuffer(String s)：构造一个拷贝字符串s的StringBuffer对象</li>
</ol>
</li>
<li><p>StringBuffer常用方法</p>
<ol>
<li>append(…)：在字符串变量尾部添加内容，内容可以为字符串常量/变量、数字等</li>
<li>insert(int offset，…)：在字符串变量的offset位置开始添加内容，内容不限</li>
<li>delete(int start, int end)：删除字符串变量从start开始至(end-1)位置的内容</li>
<li>reverse()：倒序排列字符串变量</li>
</ol>
</li>
</ul>
<h1 id="继承与多态"><a href="#继承与多态" class="headerlink" title="继承与多态"></a>继承与多态</h1><hr>
<ul>
<li>继承<ul>
<li>子类会继承父类的状态（成员变量）和行为（方法），并根据需要增加一些新的状态和行为，<span class="keyword">有利于代码的重复利用</span>（概念考点）<blockquote>
<p>注意：Java不支持多继承，一个子类只能有一个父类</p>
</blockquote>
</li>
</ul>
</li>
<li>变量的隐藏<ul>
<li>若子类重新定义了一个与从父类继承过来的变量完全相同的变量，则当子类执行父类的方法时，使用的是父类的变量，当子类执行的是自己的方法时，操作的是子类重新定义的变量</li>
<li>方法的重写（@Override）<ul>
<li>子类可以创建一个与父类完全相同（返回值、参数、方法名完全相同）的方法，覆盖父类的方法<blockquote>
<p>注意：子类的实例默认调用子类重写后的方法，若要调用父来的方法，使用super</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<br />
---

<ul>
<li><p>多态</p>
<ul>
<li>多态指程序中同一个符号早不同情况下有不同的解释的现象</li>
<li>多态的三种体现：<ol>
<li>方法的重写(@Override)</li>
<li>方法的重载(不同参数的同名方法)</li>
<li>引用</li>
</ol>
</li>
</ul>
</li>
<li><p>引用</p>
<ul>
<li>子类对象可以视为父类对象（向上转型），如：  <pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class Employee &#123;

&#125;

public class Manager extends Employee &#123;

&#125;
&#x2F;&#x2F; 则：
Employee e &#x3D; new Manager(); &#x2F;&#x2F; 为合法使用方式
</code></pre></li>
</ul>
</li>
</ul>
<h1 id="高级类特性"><a href="#高级类特性" class="headerlink" title="高级类特性"></a>高级类特性</h1><ul>
<li>final关键字：<ol>
<li>用于修饰类：表示该类不能被继承</li>
<li>用于修饰方法：表示该方法不能被重写</li>
<li>用于修饰变量：表示常量</li>
</ol>
</li>
</ul>
<hr>
<ul>
<li>枚举类型：<ul>
<li>是一个特殊的类，一组常量的集合，可以视为常量数组，枚举数据的序号从零开始，依次递增</li>
<li>枚举的定义格式：  <pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public enum Season &#123;
    spring,
    summer,
    autumn,
    winter;
&#125;
&#x2F;&#x2F; 枚举定义后，其值的提取方法为：
int s1 &#x3D; Season.spring;
int s2 &#x3D; Season.summer;
...</code></pre></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>抽象类（abstract）</p>
<ul>
<li>不能实例化，只能被子类继承并重写抽象方法的类</li>
<li><span class="keyword">可以有非抽象方法和抽象方法</span></li>
</ul>
</li>
<li><p>抽象方法（abstract）</p>
<ul>
<li>抽象方法写在抽象类里</li>
<li>抽象方法只需声明，不需要方法体</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>接口</p>
<ul>
<li>Java不支持多继承，但是支持一个类实现多个接口</li>
<li>使用关键字interface来定义一个接口</li>
<li>接口可以继承父接口</li>
<li>注意：<span class="keyword">接口体中只能有常量定义和抽象方法定义</span></li>
</ul>
</li>
<li><p>接口里面的方法</p>
<ul>
<li>接口理默认都是抽象方法，因此接口里的方法不需要任何的修饰符和abstract：  <pre class="line-numbers language-java" data-language="java"><code class="language-java">void run(String name);</code></pre></li>
</ul>
</li>
<li><p>接口的实现</p>
<ul>
<li>接口必须有其实现类，使用以下格式将该类用于实现一个或多个接口：  <pre class="line-numbers language-java" data-language="java"><code class="language-java">class A implements Printable, Addable &#123;

&#125;</code></pre>
<blockquote>
<p>若父类实现了某个接口，其子类也会实现这个接口</p>
</blockquote>
</li>
</ul>
</li>
<li><p>接口可以作为数据类型使用</p>
<ul>
<li>（向上转型）定义一个接口类型的变量，则一定要某个实现了该接口的类的实例才能赋给接口变量  <pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">interface A &#123;

&#125;

class B implements A &#123;

&#125;

&#x2F;&#x2F; 则：
A a &#x3D; new B(); &#x2F;&#x2F; 为合法使用</code></pre></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>接口与abstract类的比较：<ol>
<li>两个都可以有抽象方法</li>
<li>接口理允许常量，不允许变量<br> abstract类里允许常量与变量</li>
<li>接口不允许非抽象方法<br> abstract类允许非抽象方法</li>
</ol>
</li>
</ul>
<br />
---

<ul>
<li><p>内部类</p>
<ul>
<li>一个类除了可以有成员变量和方法外，还可以有另一种成员——内部类（嵌套类），外部类成员和方法可以在内部类中使用</li>
<li>内部类中不能声明静态变量和方法</li>
<li>内部类不能与外部类同名</li>
<li>内部类可以在其他类被调用</li>
<li>修饰符可以定义为抽象的，私有的，保护的</li>
</ul>
</li>
<li><p>匿名类</p>
<ul>
<li>一般用于创建一个只用一次的类<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">new Hello() &#123;
    &#x2F;&#x2F; 匿名类类体
&#125;</code></pre></li>
<li>匿名类必然是在某个类中创建的，因此他一定是内部类，因此匿名类可以访问外部类中的成员变量和方法，不能声明静态变量和静态方法</li>
</ul>
</li>
<li><p>与接口有关的匿名类</p>
<ul>
<li>Java允许直接用接口名和类体创建一个实现接口的匿名对象，如：  <pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F; Computable是一个接口，则：
new Computable() &#123;
    &#x2F;&#x2F; 实现接口匿名类的类体
&#125;</code></pre></li>
</ul>
</li>
</ul>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><hr>
<ul>
<li>指一组有序，同数据类型的数据集合</li>
<li>数组的长度：数组中元素的个数</li>
<li>数组的下标：数组在元素中的位置<blockquote>
<p>注意：数组下标从0 开始到 长度-1</p>
</blockquote>
</li>
<li>数组的维数：数组下标的个数</li>
</ul>
<blockquote>
<p>数组是引用类型，属于一个类的实例</p>
</blockquote>
<hr>
<ul>
<li><p>数组的声明：</p>
  <pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">int[] array;</code></pre>
<blockquote>
<p>注意：声明数组不分配内存，因此在这里指定长度是不可取的</p>
</blockquote>
</li>
<li><p>数组的创建：（分配空间）</p>
  <pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">array &#x3D; new int[100];
&#x2F;&#x2F; 可以将数组的声明与创建合在一起，即：
int[] array &#x3D; new int[100];</code></pre></li>
<li><p>静态初始化：（C语言遗产，不建议使用）</p>
  <pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F; 在创建数组的同时给数组元素赋值（不用new）
int[] array &#x3D; &#123;1, 2, 3&#125;;</code></pre></li>
<li><p>动态初始化（推荐）</p>
<ul>
<li>指数组的定义与元素值的分配分开进行，如：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">int[] array &#x3D; new int[3];
array[0] &#x3D; 12;
array[1] &#x3D; 5;
array[2] &#x3D; 10;</code></pre></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>Array类常用方法<ol>
<li>arraycopy(Object src, int srcPos, Object dest, int destPos, int length)：从源数组src的srcPos处复制length个值到目标数组dest的destPos处<table>
<thead>
<tr>
<th align="center">src</th>
<th align="center">→</th>
<th align="center">dest</th>
</tr>
</thead>
<tbody><tr>
<td align="center">……</td>
<td align="center"></td>
<td align="center">……</td>
</tr>
<tr>
<td align="center">srcPos</td>
<td align="center">→</td>
<td align="center">destPos</td>
</tr>
<tr>
<td align="center">……</td>
<td align="center">→</td>
<td align="center">……</td>
</tr>
<tr>
<td align="center">srcPos + length - 1</td>
<td align="center">→</td>
<td align="center">destPos + length - 1</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ul>
<h1 id="异常和断言"><a href="#异常和断言" class="headerlink" title="异常和断言"></a>异常和断言</h1><hr>
<ul>
<li>Java中的所有错误或不正常执行都被称为异常</li>
<li>Java提供了一个Throwable类，所有异常对象都必须是Throwable类的实例或其子类的实例</li>
<li><span class="keyword">Throwable类是所有异常类的父类</span></li>
</ul>
<hr>
<ul>
<li><p>Exception类</p>
<ul>
<li>是Throwable的子类，也是所有异常类的父类</li>
</ul>
</li>
<li><p>RuntimeException类</p>
<ul>
<li>是Exception类的子类，包含了如下标越界，算数异常等异常，这类异常由系统自动捕获并抛出</li>
</ul>
</li>
<li><p>Throwable类常用方法</p>
<ol>
<li>getMessage()：返回异常原因</li>
<li>getStackTrace()：返回堆栈跟踪情况</li>
<li>printStackTrace()：打印堆栈标准错误流</li>
<li>fillStackTrace(PrintStream s)：对重新抛出异常的跟踪</li>
<li>toString()：返回简单描述</li>
</ol>
</li>
<li><p>异常处理语句</p>
  <pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">try &#123;
    &#x2F;&#x2F; 被监视的语句，一旦出现异常，在该句结束并将异常交给其后面的catch代码段处理
&#125;
catch (异常类名 异常对象名) &#123;
    &#x2F;&#x2F; 异常处理语句，该catch捕获到异常之后，下面的catch都失效，直接跳到finally
&#125;
catch (异常类名 异常对象名) &#123;
    &#x2F;&#x2F; 异常处理语句
&#125;
&#x2F;&#x2F; ...
finally &#123;
    &#x2F;&#x2F; 最终处理，执行完异常处理后都要执行finally
&#125;</code></pre></li>
<li><p>finally语句块</p>
<ul>
<li>在结束try或try…catch语句之后一定会执行fianlly语句块，<span class="keyword">即使try语句块正常执行</span>，如：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F; 即使try语句块里有return，返回前也要执行finally语句块
try &#123;
    &#x2F;&#x2F; do something
    return;
&#125;
finally &#123;
    &#x2F;&#x2F; do something
&#125;</code></pre></li>
</ul>
</li>
<li><p>自定义异常类</p>
<ul>
<li>自定义异常类必须继承Exception类</li>
<li>抛出自定义异常类：  <pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">throw new 异常类名();</code></pre></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>断言<ul>
<li>断言是程序在开发阶段用于调试程序的手段</li>
<li>JDK4.0引入新关键字assert</li>
<li>使用方法：  <pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">assert(布尔表达式);
assert(布尔表达式):&quot;表达式&quot;;</code></pre></li>
<li>当布尔表达式为假时，抛出AssertError异常，冒号后的表达式用于生成描述异常的说明</li>
</ul>
</li>
</ul>
<h1 id="输入输出流"><a href="#输入输出流" class="headerlink" title="输入输出流"></a>输入输出流</h1><br />

<ul>
<li><p><span class="keyword">Stream结尾是字节流，Reader/Writer结尾是字符流</span></p>
<br /></li>
<li><p>什么是流：<br>  流是指在输入和输出之间流动的数据序列，一般分为输入流和输出流</p>
<ul>
<li>输出流：从程序输出的数据（如：向文件或屏幕写数据</li>
<li>输入流：程序从数据源读取数据</li>
</ul>
</li>
<li><p>java.io包中的流有：</p>
<ol>
<li>字节流：以byte为处理单位的流<ul>
<li>输入实现以InputStream为父类派生的一系列类</li>
<li>输出实现以OutputStream为父类派生的一系列类</li>
</ul>
</li>
<li>字符流：以字符为处理单位的流<ul>
<li>输入实现以Reader为父类派生的一系列类</li>
<li>输出实现以Writer为父类派生的一系列类</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<ul>
<li><p>File类（文件流）</p>
<ul>
<li><p>构造方法：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F; 文件名
File(String fileName);
&#x2F;&#x2F; 路径（不给默认为当期路径） + 文件名
File(String directoryPath, String fileName);
&#x2F;&#x2F; 目录 + 该目录下文件名
File(File f, String fileNmae);</code></pre></li>
<li><p>文件的创建</p>
<ul>
<li>创建文件对象之后不代表文件在本地一定存在（若存在则可以直接对文件对象进行操作）</li>
<li>使用<code>boolean createNewFile();</code>创建新文件，创建成功则返回真，创建失败则返回假（当文件存在时创建失败）<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F; 创建一个路径在C盘text文件夹下的text.txt文件对象
File f &#x3D; new File(&quot;C:\\text&quot;, &quot;text.txt&quot;);
&#x2F;&#x2F; 在本地创建文件（返回值为布尔型）
try &#123;
    file.createNewFile();
&#125; catch (IOException e) &#123;
    e.printStackTrace();
&#125;</code></pre></li>
</ul>
</li>
<li><p>文件的删除</p>
<ul>
<li>使用<code>boolean delete();</code>进行文件删除<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">f.delete();</code></pre></li>
</ul>
</li>
<li><p>常用的对文件操作的方法</p>
<ol>
<li>String getName();<br> 获取文件名</li>
<li>boolean canRead();<br> 文件是否可读</li>
<li>boolean canWrite();<br> 文件是否可写</li>
<li>boolean exists();<br> 文件是否存在</li>
<li>long length();<br> 获取文件的长度</li>
<li>String getAbsolutePash();<br> 获取文件的绝对路径</li>
<li>String getParent();<br> 获取文件的父级目录</li>
<li>boolean isFile();<br> 判断该文件对象是否为一个文件而非目录</li>
<li>boolean isDirectory();<br> 判断该文件对象是否是一个目录</li>
<li>boolean isHidden();<br>判断文件是否为隐藏</li>
<li>long lastModified();<br>获取文件的最后修改时间</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>目录</p>
<ul>
<li><p>将File对象作为目录使用</p>
</li>
<li><p>创建目录</p>
<ul>
<li>使用<code>boolean mkdir();</code>创建一个目录，如果创建成功返回真，创建失败返回假</li>
</ul>
</li>
<li><p>列出目录下的文件</p>
<ol>
<li>String[] list();<br> 用字符串形式返回目录下的全部文件</li>
<li>String[] list(FilenameFilter obj);<br> 用字符串形式返回目录下的指定类型的所有文件名    </li>
<li>File[] listFiles();<br> 用File对象返回目录下的全部文件</li>
<li>File[] listFiles(FilenameFilter obj);<br> 用File对象返回目录下的指定类型的文件</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>随机文件流（randomAccessFile）</p>
<ul>
<li>随机文件流可以同时完成读和写文件中的任意位置的数据操作，随机文件流不继承自任意输入或输出流，他继承自Object</li>
<li>只能操作文件</li>
</ul>
  <br />

<ul>
<li><p>构造方法</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F; 在生成随机文件流对象时，除了要指定文件对象或文件名之外，还需要知名访问文件的模式（只读 r，只写 w，读写rw）
RandomAccessFile(String name, String mode);
RandomAccessFile(File file, String mode);</code></pre></li>
<li><p>随机文件流对象常用方法</p>
<ol>
<li>byte readByte();<br> 从文件中读取一个字节</li>
<li>double readDouble();<br> 从文件中读取一个双精度浮点值</li>
<li>int readInt();<br> 从文件中读取一个整型值</li>
<li>String readLine();<br> 从文件中读取一个文本行<br /></li>
<li>void write(byte b[]);<br> 写b.length个字节到文件</li>
<li>void writeDouble(double v);<br> 向文件中写入一个双精度浮点型数据</li>
<li>void writeInt(int v);<br> 向文件中写入一个整型值<br /></li>
<li>void seek(long pos);<br> 将指针调到所需位置</li>
<li>long length();<br> 返回文件长度</li>
<li>void close();<br>关闭随机流对象</li>
<li>long getFilePointer();<br>返回当前指针位置</li>
<li>void setLength(long newLength);<br>设定文件长度</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>压缩文件流（不怎么考）<ul>
<li>通常涉及三个JAVA类：<ol>
<li>ZipEntry</li>
<li>ZipInputStream</li>
<li>ZipOutputStream</li>
</ol>
</li>
<li>相关构造方法：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F; ZipEntry构造方法
ZipEntry(String name);
&#x2F;&#x2F; 用输出流对象构造压缩文件输出流
ZipOutputStream(OutputStream out);
&#x2F;&#x2F; 用输入流对象构造压缩文件输入流
ZipInputStream(InputStraem in);</code></pre></li>
<li>压缩文件输出流常用方法<ol>
<li>void setMethod(int method);<br> 设置entry压缩方法，缺省值为default</li>
<li>void putNextEntry(zipEntry newe);<br> 若当前entry存在切处于激活状态，关闭该entry，在zip文件中写入新的entry，并将数据流定位于entry数据项的起始位置，他所方法为setMethod指定的方法</li>
</ol>
</li>
<li>压缩文件输入流常用方法<ol>
<li>ZipEntry getNextEntry();<br> 返回zip文件中的下一个entry，并肩输出流定位在此entry数据项的起始位置</li>
<li>void closeEntry();<br> 关闭当前的entry，并将数据流定位于下一个entry</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>字节流（Byte）</p>
<ul>
<li><p>以byte（字节——8位）为基本处理单位的流</p>
</li>
<li><p>Java中的每一种字节流的基本功能都依赖于基类InputStream和OutputStream，他们都是抽象类</p>
</li>
<li><p>InputStream与OutputStraem的所有方法在出错的情况下都会抛出IOException异常</p>
<br /></li>
<li><p>输入流（的子类）常用方法</p>
<ol>
<li>int read();<br> 从流中读入一个字节，形成一个0~255之间的整数返回</li>
<li>int read(byte b[]);<br> 一次性读多个字节到b数组中，填满整个数组，返回实际读入的字节数</li>
<li>int read(byte b[], int off, int len);<br> 读len个数据写入数组b中从索引off开始的位置，返回取得的字节数</li>
<li>skip();<br> 跳过数据流中指定数量的字节不读，返回值表示实际跳过的字节数</li>
<li>available();<br> 返回流中可用的字节数</li>
<li>mark();<br> 在流中当前位置标记一个位置</li>
<li>reset();<br> 返回上一个标记过的位置</li>
<li>markSupport();<br> 是否支持标记和复位操作</li>
<li>close();<br> 关闭流，输入/输出流使用完之后都应该将其关闭<br /></li>
</ol>
</li>
<li><p>输出流（的子类）常用方法</p>
<ol>
<li>void write(int b);<br> 将一个整数输出到流中</li>
<li>void write(byte b[]);<br> 将字节数组输出到流中</li>
<li>void write(byte b[], int off, int len);<br> 将数组b中从索引为off的位置开始，输出长度为len的数据到流中</li>
<li>void flush();<br> 刷新输出流，将缓冲区中的数据强行送出</li>
<li>void close();<br> 关闭流</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>数据流（Data）<ul>
<li>数据流类DataInputStream和DataOutputStream除了可处理字节和字节数组外还可以实现对文件不同数据的读写，包括处理int、float、boolean等基本数据类型</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>内存的读写（ByteArray）<ul>
<li>ByteArrayInputStream和ByteArrayOutputStream分别提供<spa n class="keyword">利用字节数组对内存的读和写</span></li>
<li>相关构造方法：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">ByteArrayInputStream(byte[] buf);
ByteArrayInputStraem(byte[] buf, int offset, int length);

ByteArrayOutputStream();
ByteArrayOutputStream(int size);</code></pre></li>
<li>除了继承自父类的方法外，他自有的方法有：（不太会考）<ol>
<li>byte[] toByteArray();<br> 可以返回输出流写入到缓冲区的全部字节，存入一个新的数组</li>
<li>int size();<br> 返回缓冲区大小</li>
<li>String toString(String name);<br> 将缓冲区的内容转换成字符串</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>字符流（Reader/Writer）</p>
<ul>
<li><p>Java中处理字符流的类都是从Reader和Writer派生出来的，用于处理双字节的Unicode字符</p>
<br /></li>
<li><p>reader（的子类）常用方法</p>
<ol>
<li>int read();<br> 读取输入流的下一个字符，返回一个整数型数据，若已到文件结尾则返回-1</li>
<li>int read(char buffer[]);<br> 从流中读取buffer.length个字符到字符数组，返回实际成功读取的字符数</li>
<li>int read(char buffer[], int offset, int numChars);<br> 从流中读取numChars个字符到buffer中以索引offset开始的地方，返回实际成功读取的字符数</li>
<li>boolean markSupported();<br> 该流是否支持标记和复位</li>
<li>void mark();<br> 在输入流的当前位置设置一个标志</li>
<li>void reset();<br> 设置输入指针到上一个标志处</li>
<li>long skip(long numChars);<br> 跳过numChars个字符，并返回所跳过的字符数</li>
<li>void close();<br> 关闭输入流<br /></li>
</ol>
</li>
<li><p>Writer（的子类）常用方法</p>
<ol>
<li>void write(int ch);<br> 向输出流写单个字符</li>
<li>void write(char buffer[]);<br> 向输出流写一个字符数组</li>
<li>void write(char buffer[], int offset, int numChars);<br> 向输出流写从buffer[offset]开始的numChars个字符</li>
<li>void write(String str);<br> 向输出流写一个字符串</li>
<li>void write(String str, int offset, int numChars);<br> 向输出流写一个字符串中以offset为起点的numChars个字符</li>
<li>void flush();<br> 刷新输出缓冲</li>
<li>void close();<br> 关闭输出流</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>转换流（字节流 → 字符流）<ul>
<li>转换流是建立在字节流之上的，转换流可以将一个字节流按照某种编码规范转换成字符流</li>
<li>相关构造方法：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F; 使用当前平台的默认编码规范，将字节输入流转换为一个字符输入流
InputStreamReader(InputStream in);
&#x2F;&#x2F; 使用当指定的编码规范，将字节输入流转换为一个字符输入流
InputStreamReader(InputStream in, String enc);

&#x2F;&#x2F; 例子：
InputStreamReader isr &#x3D; new InputStreamReader(System.in, &quot;ISO8859_1&quot;);

&#x2F;&#x2F; 使用当前平台的默认编码规范，将字节输入流转换为一个字符输出流
OutputStreamReader(OutputStream out);
&#x2F;&#x2F; 使用当指定的编码规范，将字节输入流转换为一个字符输出流
OutputStreamReader(OutputStream out, String enc);</code></pre></li>
<li>转换输入流常用方法<ol>
<li>String getEncoding();<br> 获得当前字符流所用的编码方式</li>
<li>void close();<br> 关闭输入流</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>文件字符流（FileReader/FileWriter）<ul>
<li>FileWriter对象的创建不依赖于文件是否存在，若文件不存在，则FileWriter会在打开输出文件之前创建它，若打开只读文件，则抛出IO异常</li>
<li>相关构造方法：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">FileReader(String fileName);
FileReader(File file);

FileWriter(String fileNmae);
&#x2F;&#x2F; append：是否可追加，不追加则覆盖
FileWriter(String fileName, boolean append);
FileWriter(File file);</code></pre></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>字符缓冲流（BufferedReader/BufferedWriter）</p>
<ul>
<li><p>用于提高输入输出的速度</p>
</li>
<li><p>相关构造函数：</p>
<pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">&#x2F;&#x2F; 创建一个默认缓冲区长度的缓冲字符输入流
BufferedReader(Reader in);
&#x2F;&#x2F; 创建一个指定缓冲区长度的缓冲字符输入流
BufferedReader(Reader in, int bufSize);

&#x2F;&#x2F; 创建一个默认缓冲区长度的缓冲字符输出流
BufferedWriter(Writer out);
&#x2F;&#x2F; 创建一个指定缓冲区长度的缓冲字符输出流
BufferedWriter(Writer out, int bufSize);</code></pre></li>
<li><p>缓冲输入流常用方法：</p>
<ol>
<li>String readLine();<br> 读取一个文本行，以换行’\n’或回车’\r’表示一行结束</li>
</ol>
</li>
<li><p>缓冲输出流常用方法：</p>
<ol>
<li>write(String s);</li>
<li>write(String s, int off, int len);<br> 将字符串或企一部分写到输出流中</li>
</ol>
</li>
<li><p>实际编程中的例子：</p>
<pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">&#x2F;&#x2F; 使用字符缓冲流读取文件中的一行
FileReader fileReader &#x3D; new FileReader(&quot;Student.txt&quot;);
BufferedReader bufferedReader &#x3D; new BufferedReader(fileReader);

String s &#x3D; bufferedReader.readLine();

&#x2F;&#x2F; 输出流同理
FileWriter fileWriter &#x3D; new FileWriter(&quot;Hello.txt&quot;);
BufferedWriter bufferedWriter &#x3D; new BufferedWriter(fileWriter);</code></pre></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>Scanner类<ul>
<li>构造方法<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">Scanner reader &#x3D; new Scanner(System.in);</code></pre></li>
<li>Scanner类的常用方法<ol>
<li>int nextInt();<br> 读入下一个分隔符前的字符串并转化为Int</li>
<li>String nextLine();</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>PrintWriter类<ul>
<li>打印流的构造方法：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">PrintWriter(Writer out);
PrintWriter(Writer out, boolean autoFlush);</code></pre></li>
<li>打印流的常用方法<ol>
<li>void flush();<br> 刷新打印流</li>
<li>void close();<br> 关闭打印流</li>
<li>void println();<br> 向输出流写入字符（格式化输出）</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>对象流（经常考）（对象 → 字节流）</p>
<ul>
<li><p>相关构造方法：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">ObjectInputStream(InputStream in);
ObjectOutputStream(OutputStream out);</code></pre></li>
<li><p>对象的持续性</p>
<ul>
<li>指能将对象的状态记录以便将来再生的能力</li>
</ul>
</li>
<li><p>对象的可串行化</p>
<ul>
<li>指对象通过写出描述自己的状态的数值来记录自己的过程</li>
<li>串行化的主要任务是写出对象实例变量的数值</li>
<li>所有基本类型的变量都是可串行化的，若变量是另一个对象的引用，则引用的对象也要可串行化</li>
<li><span class="keyword">只有可串行化的对象才能通过对象流进行传输，只有实现Serializable接口的类才能被串行化</span><br /></li>
</ul>
</li>
<li><p>例子：使用对象流向文件中写入对象/读取对象</p>
<blockquote>
<p>现有一个类Student需要存入文件</p>
</blockquote>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">import java.io.Serializable;
&#x2F;&#x2F; 实现Serializable接口的类为可串行类
public class Student implements Serializable &#123;
    int id;
    String name;
    int age;
    String fromClass;

    public Student(int id, int age, String name, String fromClass) &#123;
        this.id &#x3D; id;
        this.age &#x3D; age;
        this.name &#x3D; name;
        this.fromClass &#x3D; fromClass;
    &#125;

    public void PrintValue() &#123;
        System.out.println(this.id + &quot;,&quot; + this.age + &quot;,&quot; + this.name + &quot;,&quot; + this.fromClass);
    &#125;
&#125;</code></pre>
<blockquote>
<p>实现向文件中写入对象/读出对象的类</p>
</blockquote>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">import java.io.*;

&#x2F;&#x2F; 实现类的对象的传输
public class ObjectWrite &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F; 两个可串行化的，需要被写入文件的实例
        Student student1 &#x3D; new Student(200501, 16, &quot;Ming&quot;, &quot;Compute Science&quot;);
        Student student2 &#x3D; new Student(200502, 17, &quot;Zhang Bi&quot;, &quot;Chinese&quot;);

        try &#123;
            &#x2F;&#x2F; 新建文件输出流
            FileOutputStream fileOutputStream &#x3D; new FileOutputStream(&quot;student.dat&quot;);
            &#x2F;&#x2F; 将文件输出流实例作为参数新建对象输出流
            ObjectOutputStream objectOutputStream &#x3D; new ObjectOutputStream(fileOutputStream);
            &#x2F;&#x2F; 向对象输出流中写对象
            objectOutputStream.writeObject(student1);
            objectOutputStream.writeObject(student2);
            &#x2F;&#x2F; 关闭
            objectOutputStream.close();
            fileOutputStream.close();

            &#x2F;&#x2F; 读入过程
            FileInputStream fileInputStream &#x3D; new FileInputStream(&quot;student.dat&quot;);
            ObjectInputStream objectInputStream &#x3D; new ObjectInputStream(fileInputStream);

            &#x2F;&#x2F; 注意：readObject方法读出默认类型为Object，需要强转为接收对象的类型
            Student stu01 &#x3D; (Student)objectInputStream.readObject();
            stu01.PrintValue();
            Student stu02 &#x3D; (Student)objectInputStream.readObject();
            stu02.PrintValue();

            objectInputStream.close();
            fileInputStream.close();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;</code></pre></li>
</ul>
</li>
</ul>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><ul>
<li><p>Java线程模型</p>
<ol>
<li>虚拟CPU：封装在Thread类中，控制线程运行</li>
<li>程序代码：传递给Thread类，由Thread类控制顺序执行</li>
<li>数据：指线程代码执行过程中需要处理的数据，传递给Thread类</li>
</ol>
</li>
<li><p>两种构造方法：</p>
<ol>
<li>继承Thread</li>
<li>实现Runnable</li>
</ol>
</li>
<li><p>线程的优先级</p>
<ul>
<li>线程的调度是抢先式的，一个具有更高优先级的线程进入可执行状态后，则该高优先级线程会被理科调度执行</li>
<li>线程的优先级可以用数字表示，范围是1~10</li>
<li>Thread类还有三个关于优先级的常量：<ol>
<li>MIN_PRIORITY = 1</li>
<li>NORM_PRIORITY = 5</li>
<li>MAX_PRIORITY = 10</li>
</ol>
</li>
<li>对于一个新线程，他会继承创建它的父线程的优先级</li>
<li>一般情况下，线程具有普通优先级（5级）</li>
</ul>
  <br />

<ul>
<li>优先级的设置：使用<code>setPriority();</code>设置优先级</li>
</ul>
</li>
<li><p>线程的控制</p>
<ol>
<li>sleep();<br> 线程可以在它的run()方法中调用sleep()方法，使自己放弃处理器资源，休眠一段时间</li>
<li>yield();<br> 将执行的权力交给其他优先级相同的线程，自己到可运行线程队列最后等待</li>
<li>join();<br> 使当前正在执行的线程等待，调用该方法的线程插队</li>
<li>join(long millis);<br> 使当前线程等待调用该方法的线程结束或当前线程等待millis毫秒后重新进入可执行状态</li>
<li>join(long millis, int nanos);<br> 有限时间插队的毫秒+纳秒模式</li>
<li>interrupt();<br> 用于唤醒休眠的线程</li>
<li>currentThread();<br> 返回当前正在使用CPU资源的线程</li>
<li>isAlive();<br> 可以用于判断线程是否已被启动且未被终止<br> true：可运行的 或 运行过且在等待的<br> false：新创建的 或 已消亡的</li>
</ol>
</li>
<li><p>线程同步</p>
<ol>
<li>wait();<br> 使当前线程释放锁，并等待</li>
<li>notify();/notifyAll();<br> 唤醒等待序列中的线程，使他们可以拥有锁</li>
</ol>
</li>
</ul>
<hr>
<ul>
<li><p>线程的5个状态</p>
<ol>
<li>新建：当一个线程对象被new出，此时该对象只能执行start()或stop()</li>
<li>就绪：处于可运行但未被调度的状态</li>
<li>运行：线程占有CPU资源<ul>
<li>运行中的线程会发生下面的三种状态变迁：<ol>
<li>→ 终止：线程正常结束或被应用程序终止</li>
<li>→ 就绪：线程执行yield()礼让方法</li>
<li>→ 阻塞：<ul>
<li>线程调用sleep()，休眠时间过后进入就绪</li>
<li>线程调用join(),使其他线程插队，插队线程运行完毕或超过设定时间时进入就绪</li>
<li>线程调用wait()，被notify()或notifyAll()唤醒时进入就绪</li>
<li>正在请求锁而未获得时，获得锁时进入就绪</li>
<li>线程中有输入输出操作时进入阻塞，输入输出完成后进入就绪</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li>阻塞：线程等待某个条件满足，当条件满足时，线程回到就绪</li>
<li>死亡：<ol>
<li>自然撤销：线程运行结束正常退出</li>
<li>强行终止：使用stop()强行终止（过期方法不建议使用）<br><img src="https://s4.ax1x.com/2022/02/13/HBs57V.png" alt="HBs57V.png"><br /></li>
</ol>
</li>
</ol>
</li>
<li><p>Thread类其他方法（不怎么考）</p>
<ol>
<li>void setName(String name);<br> 改变某个线程的名称</li>
<li>String getName();<br> 返回该线程的名称</li>
<li>int activeCount();<br> 返回当前线程组中活动的线程数</li>
<li>ThreadGroup getThreadGroup();<br> 返回该线程所属的线程组，若该线程已终止返回null</li>
<li>void setDaemon(boolean on);<br> 标记该线程为守护线程会用户线程</li>
<li>boolean isDaemon();<br> 是否为守护线程</li>
<li>String toString();<br> 返回该线程的字符串表现形式，包括线程名，优先级和线程组</li>
<li>int enumerate(Thread[] tarray);<br> 将当前线程的线程组及其子组中的每一个活动线程复制到指定数组中</li>
<li>void CheckAccess();<br> 判断当期运行线程是否有权限修改该线程</li>
</ol>
</li>
</ul>
<hr>
<ul>
<li><p>与线程相关的其他类</p>
<ol>
<li>java.lang.Thread</li>
<li>java.lang.Runnable</li>
<li>java.lang.Object</li>
<li>java.lang.ThreadGroup</li>
<li>Java.lang.ThreadDeath</li>
</ol>
</li>
<li><p>线程组（ThreadGroup）</p>
<ul>
<li>Java中每个线程都属于某个线程组，线程组可以使一组线程作为一个对象进行同一处理，例如可以用一个方法统一调用、启动或挂起组内所有线程</li>
</ul>
</li>
</ul>
<hr>
<h1 id="awt图形界面"><a href="#awt图形界面" class="headerlink" title="awt图形界面"></a>awt图形界面</h1><ul>
<li><p>窗口（Frame类）</p>
<ul>
<li>新建一个窗口：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class FrameTest &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F; 初始化一个窗口，设置窗口标题
        Frame frame &#x3D; new Frame(&quot;MyFrame&quot;);
        &#x2F;&#x2F; 设置窗口可见（默认不可见
        frame.setVisible(true);
        &#x2F;&#x2F; 设置窗口默认大小
        frame.setSize(200,300);
    &#125;
&#125;</code></pre></li>
</ul>
</li>
<li><p>面板（Panel类）</p>
<ul>
<li>面板是一种透明的容器，无标题无边框，它不能作为最外层容器单独存在，必须作为组件放在其他容器中，然后再把其他组件放到面板中</li>
<li>一个面板享有自己的面板管理器，为了实现复杂布局，可以创建多个面板并定义他们的布局管理器</li>
</ul>
</li>
<li><p>布局管理器</p>
<ul>
<li>Java提供布局管理器来管理组件在容器中的布局，而不直接设置组建的位置和大小，每个容器都要一个布局管理器，容器中的组件的定位都由他来决定，标准的布局管理器有：<ol>
<li>FlowLayout</li>
<li>BorderLayout</li>
<li>GridLayout</li>
<li>CardLayout</li>
<li>GridBagLayout</li>
</ol>
</li>
<li>注意：在使用布局管理器设置组件的大小和位置时，用户无法再设置组件的这些属性（组件的大小和位置被布局管理器接管</li>
<li>组件的默认布局管理器：</li>
</ul>
<table>
<thead>
<tr>
<th>组件</th>
<th>布局管理器</th>
</tr>
</thead>
<tbody><tr>
<td>Panel</td>
<td>FlowLayout</td>
</tr>
<tr>
<td>Applet</td>
<td>FlowLayout</td>
</tr>
<tr>
<td>Window</td>
<td>BorderLayout</td>
</tr>
<tr>
<td>Dialog</td>
<td>BorderLayout</td>
</tr>
<tr>
<td>Frame</td>
<td>BorderLayout</td>
</tr>
</tbody></table>
</li>
</ul>
<hr>
<ul>
<li><p>Flowlayout（流布局</p>
<ul>
<li>将一个不是FlowLayout布局的容器设置为FlowLayout布局：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">setLayout(new FlowLayout());</code></pre></li>
<li>将组件一排一排依次放置，并使用组件的最佳尺寸显示组件，当容器被重新设置大小后（被手动拖放），布局会随之改变，各组件的大小不变，但相对位置发生变化（看看例子的图</li>
<li>使用<code>add(组件名);</code>在FlowLayout容器里添加组件，组件将按顺序排列在容器中</li>
</ul>
  <br />

<ul>
<li>Flowlayout例子：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class FlowLayoutTest extends Frame &#123;
    &#x2F;&#x2F; 无参构造
    public FlowLayoutTest() throws HeadlessException &#123;

    &#125;

    &#x2F;&#x2F; 带标题构造

    public FlowLayoutTest(String title) throws HeadlessException &#123;
        super(title);
        &#x2F;&#x2F; 设置大小
        setSize(300, 100);
        &#x2F;&#x2F; 设置布局管理器
        setLayout(new FlowLayout());
        &#x2F;&#x2F; 设置可见
        setVisible(true);
        &#x2F;&#x2F; 添加三个按钮
        add(new Button(&quot;Button 1&quot;));
        add(new Button(&quot;Button 2&quot;));
        add(new Button(&quot;Button 3&quot;));
    &#125;
&#125;

class Main &#123;
    public static void main(String[] args) &#123;
        FlowLayoutTest flowLayoutTest &#x3D; new FlowLayoutTest(&quot;FlowLayout Example&quot;);
    &#125;
&#125;</code></pre>
<img src="https://s4.ax1x.com/2022/02/15/Hc6CR0.png" alt="Hc6CR0.png"><br><img src="https://s4.ax1x.com/2022/02/15/Hc69Gq.png" alt="Hc69Gq.png"></li>
</ul>
</li>
</ul>
<br />

<ul>
<li><p>BorderLayout（打麻将分布</p>
<ul>
<li>BorderLayout包含五个区域，并且只能放五个组件：<ol>
<li>North</li>
<li>South</li>
<li>East</li>
<li>West</li>
<li>Center<br>当然容器尺寸变化时，各组件的相对位置不变，但中间部分的组件尺寸会发生变化，南北组件高度不变，东西组件宽度不变</li>
</ol>
</li>
<li>往BorderLayout里面添加组件的两种表示方法：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F; 若没有指定位置则默认放center
add(&quot;West&quot;, new Butten(&quot;West&quot;));
add(new Butten(&quot;South&quot;), BorderLayout.SOUTH);</code></pre></li>
<li>注意：若一个地方放多个组件，则会显示最后一个放置上去的组件<blockquote>
<p>分布在北部和南部的组件横向扩展占据整个容器的长度<br>分布在东部和西部的组件扩展至占据容器剩余部分的全部宽度<br>最后的部分将分配给中间的组件<br>注意：若某个区域没有组件，则其他组件可以占据他的空间</p>
</blockquote>
</li>
</ul>
  <br />

<ul>
<li>BorderLayout例子：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class BorderLayoutTest extends Frame &#123;
    &#x2F;&#x2F; 无参构造
    public BorderLayoutTest() throws HeadlessException &#123;

    &#125;

    &#x2F;&#x2F; 带标题构造
    public BorderLayoutTest(String title) throws HeadlessException &#123;
        super(title);
        &#x2F;&#x2F; 设置大小
        setSize(300, 300);
        &#x2F;&#x2F; 设置布局管理器
        setLayout(new BorderLayout());
        &#x2F;&#x2F; 设置可见
        setVisible(true);
        &#x2F;&#x2F; 添加按钮
        add(&quot;East&quot;, new Button(&quot;East&quot;));
        add(new Button(&quot;South&quot;), BorderLayout.SOUTH);
        add(&quot;West&quot;, new Button(&quot;West&quot;));
        add(new Button(&quot;North&quot;), BorderLayout.NORTH);
        add(new Button(&quot;Center&quot;));
    &#125;
&#125;

class Main &#123;
    public static void main(String[] args) &#123;
        BorderLayoutTest borderLayoutTest &#x3D; new BorderLayoutTest(&quot;BorderLayout Example&quot;);
    &#125;
&#125;</code></pre>
<img src="https://s4.ax1x.com/2022/02/15/Hc63LD.png" alt="Hc63LD.png"></li>
</ul>
</li>
</ul>
<br />

<ul>
<li>GridLayout<ul>
<li>使容器中的组件呈网格状分布，容器中各组件的高度宽度相同，当容器的尺寸发生变化时，各组件的相对位置不变，但各自的尺寸会发生变化，各组件的排列方式为：从上到下，从左到右</li>
<li>每个网格只能加一个组件</li>
<li>GridLayout构造方法：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F; 生成一个rows行，cols列的管理器
public GridLayout(int rows, int cols);</code></pre>
<blockquote>
<p>注意：rows或cols可以有一个为0</p>
</blockquote>
<ol>
<li>若rows为0，表示限制每行放置cols个组件，行数不定</li>
<li>若cols为0，表示限制总行数为rows，每行的组件不定</li>
</ol>
</li>
<li>GridLayout例子：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class GridLayoutTest extends Frame &#123;
    &#x2F;&#x2F; 无参构造
    public GridLayoutTest() throws HeadlessException &#123;

    &#125;

    &#x2F;&#x2F; 带标题构造
    public GridLayoutTest(String title) throws HeadlessException &#123;
        super(title);
        &#x2F;&#x2F; 设置大小
        setSize(300, 300);
        &#x2F;&#x2F; 设置布局管理器
        setLayout(new GridLayout(0, 2));
        &#x2F;&#x2F; 设置可见
        setVisible(true);
        &#x2F;&#x2F; 添加按钮
        add(new Button(&quot;Button 1&quot;));
        add(new Button(&quot;Button 2&quot;));
        add(new Button(&quot;Button 3&quot;));
        add(new Button(&quot;Button 4&quot;));
        add(new Button(&quot;Button 5&quot;));
        add(new Button(&quot;Button 6&quot;));
    &#125;
&#125;

class Main &#123;
    public static void main(String[] args) &#123;
        GridLayoutTest borderLayoutTest &#x3D; new GridLayoutTest(&quot;GridLayout Example&quot;);
    &#125;
&#125;</code></pre>
<img src="https://s4.ax1x.com/2022/02/15/Hc6RWq.png" alt="Hc6RWq.png"></li>
</ul>
</li>
</ul>
<br />

<ul>
<li>CardLayout（叠叠乐<ul>
<li>CardLayout可以容纳多个组件，但实际上同一时刻容器只能选择一个组件来显示，就像堆叠的扑克牌一样一次只能有一张在上面，被显示的组件将占据整个容器空间</li>
<li>通常在使用CardLayout布局时，调用容器方法add()加入组件时，会同时为组件分配一个名字：<code>add(组件名, 组件对象);</code>，再调用CardLayout的方法<code>show(容器名, 组件名);</code>来显示组件</li>
<li>一些其他方法：<ol>
<li>first(容器名);<br> 显示第一个组件</li>
<li>last(容器名);<br> 显示最后一个组件</li>
<li>previous(容器名);<br> 显示前一个组件</li>
<li>next(容器名);<br> 显示后一个组件</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>容器的嵌套</p>
<ul>
<li>使用Panel实现容器的嵌套</li>
</ul>
</li>
<li><p>写一个容器嵌套：<br><img src="https://s4.ax1x.com/2022/02/16/HfOPr6.png" alt="HfOPr6.png"></p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class PanelTest extends Frame &#123;
    public PanelTest(String title) throws HeadlessException &#123;
        super(title);

        Panel NorthPanel &#x3D; new Panel();
        Panel SouthPanel &#x3D; new Panel();

        setLayout(new BorderLayout());
        setSize(360, 300);
        setVisible(true);

        add(NorthPanel, BorderLayout.NORTH);
        NorthPanel.setLayout(new FlowLayout());
        NorthPanel.setBackground(Color.GRAY);
        NorthPanel.add(new Button(&quot;North&quot;));
        &#x2F;&#x2F; 使用Label将造成中文乱码
        NorthPanel.add(new JLabel(&quot;我在第一个Panel里&quot;));

        add(SouthPanel, BorderLayout.SOUTH);
        SouthPanel.setLayout(new FlowLayout());
        SouthPanel.setBackground(Color.red);
        SouthPanel.add(new Button(&quot;South&quot;));
        SouthPanel.add(new TextField(&quot;我在第二个Panel里&quot;));

        add(new Button(&quot;West&quot;), BorderLayout.WEST);
        add(new TextArea(&quot;我不在Panel里&quot;), BorderLayout.CENTER);
    &#125;
&#125;

class Main &#123;
    public static void main(String[] args) &#123;
        PanelTest panelTest &#x3D; new PanelTest(&quot;容器嵌套&quot;);
    &#125;
&#125;</code></pre></li>
</ul>
<hr>
<ul>
<li><p>AWT事件处理模型</p>
<ul>
<li>事件：发生在用户界面上的用户交互行为而产生的一种效果</li>
<li>事件源：产生事件的对象</li>
<li>事件处理：接收事件对象的信息并对其进行处理的方法</li>
</ul>
</li>
<li><p>要使组件能响应动作并且作出处理还需要：</p>
<ol>
<li>通知JVM该类需要监督和处理一个动作事件（按钮需要被监控</li>
<li>激活按钮，使其产生一个事件（用户单击按钮</li>
<li>实现一个方法来说明如何处理按钮产生的事件<pre><code> Java提供一个ActionListener接口将GUI构建产生的事件与一个特定的事件响应方法联系起来，使之能够决定怎样响应某些事件
</code></pre>
</li>
</ol>
</li>
<li><p>ActionListener接口</p>
<ul>
<li>ActionListener接口是java.awt.event包中的接口，它的父接口是Eventlistener</li>
<li><span class="keyword">任何实现了ActionListener的类表示它是一个用于事件处理的类（即动作监听器），该类的实例应作为参数传入组件的addActionListener中以便监听器可以监听到组件</span></li>
</ul>
</li>
</ul>
<br />

<ul>
<li><p>退出按钮例子：</p>
<ul>
<li><p>首先写一个没有动作相应的按钮：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class EventTest extends Frame &#123;

    private Button Quit &#x3D; new Button(&quot;Quit&quot;);

    public EventTest(String title) throws HeadlessException &#123;
        super(title);

        setLayout(new FlowLayout());
        setSize(200, 100);
        setVisible(true);
        add(Quit);
    &#125;
&#125;

class Main &#123;
    public static void main(String[] args) &#123;
        EventTest eventTest &#x3D; new EventTest(&quot;事件处理&quot;);
    &#125;
&#125;</code></pre></li>
<li><p>然后使用组件中的方法加入动作监听器</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class EventTest extends Frame &#123;

    private Button Quit &#x3D; new Button(&quot;Quit&quot;);

    public EventTest(String title) throws HeadlessException &#123;
        super(title);

        setLayout(new FlowLayout());
        setSize(200, 100);
        setVisible(true);
        add(Quit);
        Quit.addActionListener(new ActionHandler());
    &#125;
&#125;

class ActionHandler implements ActionListener &#123;

    @Override
    public void actionPerformed(ActionEvent e) &#123;
        System.out.println(&quot;要退出了&quot; + e);
        System.exit(0);
    &#125;
&#125;

class Main &#123;
    public static void main(String[] args) &#123;
        EventTest eventTest &#x3D; new EventTest(&quot;事件处理&quot;);
    &#125;
&#125;</code></pre></li>
<li><p>当然如果这个监听器只使用一次，可以使用Lambda表达式简化：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">Quit.addActionListener((e) -&gt; &#123;
    System.out.println(&quot;要退出了&quot; + e);
    System.exit(0);
&#125;);</code></pre>
<p><img src="https://s4.ax1x.com/2022/02/16/HhKxxA.png" alt="HhKxxA.png"></p>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>事件类</p>
<ul>
<li>事件是可视化构件或用户接口构件产生的信息，Java通过使用特殊的方法能对它做出反应</li>
<li>每个事件源可以产生多个特定类型的事件，所有事件都放在包java.awt.event中，这些事件都从java.util.EventObject继承而来<br /></li>
</ul>
</li>
<li><p>EventObject</p>
<ul>
<li>所有事件的父类</li>
<li>他有两个主要方法：<ol>
<li>getSource();<br> 获取一个特定的事件源</li>
<li>toString();<br> 返回事件对象名的字符串</li>
</ol>
</li>
</ul>
</li>
<li><p>event包中常用的事件类，他们分为两类：</p>
<ol>
<li>低级事件<br> 表示低级输入或在屏幕上的可视构件窗口系统事件<ol>
<li>ComponentEvent:组件事件——组件尺寸变化</li>
<li>ContainerEvent:容器事件——组件增加/移动</li>
<li>WindowEvent:窗口事件——关闭窗口/窗口闭合</li>
<li>FocusEvent:焦点事件——焦点的获得/丢失</li>
<li>KeyEvent:键盘事件——键按下/释放</li>
<li>MouseEvent:鼠标事件——鼠标单击/移动</li>
</ol>
</li>
<li>高级事件（语义事件）<br> 包括接口构件产生的用户定义的信息<ol>
<li>ActionEvent:动作事件——按钮按下/TextField中按下回车</li>
<li>AdjustmentEvent:调节事件——在滚动条上移动滑块以调节数值</li>
<li>ItemEvent:项目事件——选择/不选择项目</li>
<li>TextEvent:文本事件——文本对象改变</li>
</ol>
</li>
</ol>
</li>
</ul>
<hr>
<ul>
<li><p>事件和对其对应接口</p>
<ul>
<li><p>ActionEvent事件</p>
<ul>
<li>触发时机：<ol>
<li>单击按钮</li>
<li>双击列表框中的选项</li>
<li><span class="keyword">选择菜单项</span></li>
<li>文本框按下回车</li>
</ol>
</li>
<li>事件监听接口：ActionListener</li>
<li>接口方法：actionPerformed(ActionEvent e);</li>
<li>组件注册该事件方法：addActionListener(实现了接口的类的实例);<br /></li>
</ul>
</li>
<li><p>WindowEvent事件</p>
<ul>
<li>触发时机：窗口打开/关闭/大小调整、点击右上角的隐藏/最大化/最小化/关闭按钮</li>
<li>事件监听接口：WindowListener</li>
<li>接口方法：<ol>
<li>windowActived(WindowEvent e);<br> 激活窗口</li>
<li>windowClosed(WindowEvent e);<br> 调用dispose方法关闭窗口后（若要实现点击红叉关闭窗口，实现这个方法即可）</li>
<li>windowClosing(WindowEvent e);<br> 用窗口关闭框关闭窗口</li>
<li>windowDeactivated(WindowEvent e);<br> 本窗口成为非活动窗口</li>
<li>windowDeconified(WindowEvent e);<br> 从最小化恢复</li>
<li>windowIconified(WindowEvent e);<br> 窗口变为最小化</li>
<li>windowOpened(WindowEvent e);<br> 窗口第一次打开</li>
</ol>
</li>
<li>接口适配器：WindowAdapter<br>  适配器用于只实现虚需要实现的方法，而不需要的方法不用管<ul>
<li>只有有多个方法的监听接口才有适配器类</li>
</ul>
</li>
<li>组件注册该事件方法：addWindowListener();<br /></li>
</ul>
</li>
<li><p>AdjustmentEvent事件</p>
<ul>
<li>触发时机：操作滚动条改变滑块位置</li>
<li>事件监听接口：AdjustmentListener</li>
<li>接口方法：adjustmentValueChanged(AdjustmentEvent e);</li>
<li>组件注册该事件方法：addAdjustmentListener();<br /></li>
</ul>
</li>
<li><p>ComponentEvent事件</p>
<ul>
<li>触发时机：组件移动，改变大小/可见性</li>
<li>事件监听接口：ComponentListener</li>
<li>接口方法：<ol>
<li>componentHidden(ComponentEvent e);<br> 组件隐藏</li>
<li>conponentMoved(ComponentEvent e);<br> 组件移动</li>
<li>componentResized(ComponentEvent e);<br> 组件大小改变</li>
<li>componentShown(ComponentEvent e);<br> 组件变为可见</li>
</ol>
</li>
<li>接口适配器：ComponentAdapter</li>
<li>组建注册该事件的方法：addComponentListener();<br /></li>
</ul>
</li>
<li><p>ContainerEvent事件</p>
<ul>
<li>触发时机：当容器增加或删除组件</li>
<li>事件监听接口：ContainerListener</li>
<li>接口方法：<ol>
<li>conponentAdded(ContainerEvent e);<br> 组件增加</li>
<li>conponentRemoved(ContainerEvent e);<br> 组件减少</li>
</ol>
</li>
<li>接口适配器：ContainerAdapter</li>
<li>容器注册该事件的方法：addContainerListener();<br /></li>
</ul>
</li>
<li><p>FocusEvent事件</p>
<ul>
<li>触发时机：组件获得焦点/失焦</li>
<li>事件监听接口：FocusListener</li>
<li>接口方法：<ol>
<li>focusGained(FocusEvent e);<br> 组件获得焦点</li>
<li>focusLost(FocusEvent e);<br> 组件失焦</li>
</ol>
</li>
<li>接口适配器：FocusAdapter</li>
<li>组件注册该事件的方法：addFocusListener();<br /></li>
</ul>
</li>
<li><p>ItemEvent事件</p>
<ul>
<li>触发时机：改变列表框中的选中项、改变复选框选中状态、改变下拉列表框选中项</li>
<li>时间监听接口：ItemListener</li>
<li>接口方法：itemStateChanged(ItemEvent e);</li>
<li>组件注册该事件的方法：addItemListener();<br /></li>
</ul>
</li>
<li><p>TextEvent事件</p>
<ul>
<li>触发时机：输入字符到文本框或文本区域</li>
<li>事件监听接口：TextListener</li>
<li>接口方法：textValueChanged(TextEvent e);</li>
<li>组件注册该事件的方法：addTextListener();<br /></li>
</ul>
</li>
<li><p>KeyEvent事件（键盘事件）</p>
<ul>
<li>触发时机：<ol>
<li>击完键（按下然后释放整个过程结束）</li>
<li>按下键</li>
<li>释放键</li>
</ol>
</li>
<li>事件监听接口：KeyListener</li>
<li>接口方法：<ol>
<li>keyPressed(KeyEvent e);<br> 键被按下</li>
<li>keyReleased(KeyEvent e);<br> 键被释放</li>
<li>keyTyped(KeyEvent e);<br> 键被击完</li>
</ol>
</li>
<li>KeyEvent方法：<ol>
<li>char getKeyChar();<br> 返回键盘输入的字符</li>
<li>int getKeyCode();<br> 返回键盘码</li>
</ol>
</li>
<li>事件监听适配器（抽象类）：KeyAdapter</li>
<li>组件注册该事件的方法：addKeyListener();<br /></li>
</ul>
</li>
<li><p>MouseEvent事件</p>
<ol>
<li>鼠标事件：鼠标键按下/抬起、鼠标单击、鼠标光标进入/离开一个组件</li>
<li>鼠标移动事件：鼠标移动、鼠标拖动</li>
</ol>
</li>
<li><p>事件监听接口：</p>
<ol>
<li>MouseListener<br> 对应监听第一类鼠标事件</li>
</ol>
<ul>
<li>方法<ol>
<li>mouseClicked(MouseEvent e);<br> 单击鼠标</li>
<li>mouseEntered(MouseEvent e);<br> 鼠标光标进入一个组件</li>
<li>mouseExited(MouseEvent e);<br> 鼠标光标离开一个组件</li>
<li>mousePressed(MouseEvent e);<br> 鼠标按下</li>
<li>mouseReleased(MouseEvent e);<br> 鼠标释放</li>
</ol>
</li>
<li>事件监听适配器（抽象类）：MouseAdapter</li>
<li>组件注册该事件的方法：addMouseListener();<br /></li>
</ul>
<ol start="2">
<li>MouseMotionListener<br> 对应监听第二类鼠标事件</li>
</ol>
<ul>
<li>方法<ol>
<li>mouseMoved(MouseEvent e);<br> 鼠标移动</li>
<li>mouseDragged(MouseEvent e);<br> 鼠标拖动</li>
</ol>
</li>
<li>事件监听适配器：MouseMotionAdapter</li>
<li>组件注册该事件的方法：addMouseMotionListener();</li>
</ul>
</li>
<li><p>MouseEvent方法</p>
<ol>
<li>int getClickCount();<br> 单击返回1 双击返回2</li>
<li>Point getPoint();<br> 取鼠标光标坐标</li>
<li>int getX();</li>
<li>int getY();<br> 取鼠标光标位置</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>适配器类</p>
<ul>
<li>当一个监听器接口中有多个方法时，他就会有适配器类</li>
<li>适配器类就是实现了接口的类，只是其方法都为空方法，通常作为监听器的父类使用</li>
<li><span class="keyword">因此我们可以用过继承适配器类，并重写我们需要的方法，就不会使我们自己写的类出现很多空方法</span></li>
</ul>
  <br />

<ul>
<li>使用适配器类实现窗口关闭：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class WindowCloseTest extends Frame &#123;
    public WindowCloseTest(String title) throws HeadlessException &#123;
        super(title);
        setSize(200,200);
        setVisible(true);
        addWindowListener(new EventListener());
    &#125;
&#125;

class EventListener extends WindowAdapter &#123;
    @Override
    public void windowClosing(WindowEvent e) &#123;
        System.exit(0);
    &#125;
&#125;

class Main &#123;
    public static void main(String[] args) &#123;
        WindowCloseTest windowCloseTest &#x3D; new WindowCloseTest(&quot;WindowCloseTest&quot;);
    &#125;
&#125;</code></pre></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>AWT组件库</p>
<ol>
<li><p>按钮（Button）</p>
</li>
<li><p>复选框（CheckBox）</p>
<ul>
<li>复选框可以处于 开（true）/关（false） 状态，当其状态改变时，可以产生ItemEvent事件</li>
</ul>
</li>
<li><p>复选框组（CheckBoxGroup）</p>
<ul>
<li>复选框组类用于集合复选框按钮，<span class="keyword">一个复选框组内只能有一个复选框为true</span>，当有true的复选框时，强制同组其他复选框为false，<span class="keyword">实现了复选框的单选功能</span></li>
</ul>
</li>
<li><p>下拉式菜单（Choice）</p>
<ul>
<li>表示一个弹出式选择菜单，当前的选择显示为下拉式菜单的标题</li>
</ul>
</li>
<li><p>画布（Canvas）</p>
<ul>
<li>画布表示屏幕上的一个空白矩形区域，应用程序在该区域内绘图，或者可以从该区域捕获用户的输入事件</li>
<li>应用程序必须为Canvas类创建子类，以获得有用的功能。必须重写paint方法，以便在Canvas上执行自定义图形</li>
<li>画布例子：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">    public class CanvasTest extends Frame &#123;
    DrawCanvas drawCanvas &#x3D; new DrawCanvas();

    public CanvasTest(String title) throws HeadlessException &#123;
        super(title);

        setSize(300, 200);
        setVisible(true);

        add(new DrawCanvas());
    &#125;
&#125;

class DrawCanvas extends Canvas &#123;
    @Override
    public void paint(Graphics g) &#123;
        setBackground(Color.YELLOW);
        for (int i &#x3D; 12; i &lt; getSize().height; i +&#x3D; 12) &#123;
            g.drawString(&quot;y location&quot; + i, 10, i);
        &#125;
    &#125;
&#125;

class Main &#123;
    public static void main(String[] args) &#123;
        new CanvasTest(&quot;CanvasTest&quot;);
    &#125;
&#125;</code></pre></li>
</ul>
</li>
<li><p>单行文本输入区（TextField）</p>
<ul>
<li>对一行文本进行编辑的组件，可以用于接收用户输入或显示可编辑的文本输出，可以设置为允许编辑或只读</li>
<li>在该组件下按下会车可以触发ActionEvent</li>
</ul>
</li>
<li><p>文本输入区（TextArea）</p>
<ul>
<li>指显示文本的多行区域，可以将其设置为允许编辑或只读</li>
</ul>
</li>
<li><p>列表（List）</p>
<ul>
<li>该组件为用户提供一个可滚动的文本项列表</li>
<li>可以设置组件为单项或多项选择</li>
</ul>
</li>
<li><p>框架（Frame）</p>
<ul>
<li>是一个带有标题和边框并可以重制大小的顶层窗口</li>
<li>会产生WindowEvent事件（实现窗口隐藏/关闭等）</li>
<li><span class="keyword">注意：选择菜单产生ActionEvent</span></li>
</ul>
</li>
<li><p>对话框（Dialog）</p>
<ul>
<li>是Window类的子类，与一般窗口的区别在于它依赖于其他窗口</li>
</ul>
</li>
<li><p>文件对话框（Fileddialog）</p>
<ul>
<li>显示一个对话框窗口，用户可以从中选择文件</li>
<li>当该对话框被显示时，他将阻塞其余应用程序，直到用户选择一个文件</li>
</ul>
</li>
<li><p>菜单容器（MenuBar）（菜单条）</p>
<ul>
<li>只能被添加到Frame中（<code>使用setMenuBar()</code>）,作为添加菜单的容器</li>
</ul>
</li>
<li><p>菜单（Menu）（菜单项）</p>
<ul>
<li>只能被添加到菜单容器（MenuBar）中</li>
<li>作为菜单项的容器，显示并控制其中的菜单项</li>
</ul>
</li>
<li><p>菜单项（MenuItem）（菜单子项）</p>
<ul>
<li>通常被添加到Menu中。操作的动作可以用ActionListener监听其事件</li>
<li>菜单例子：<ul>
<li>在菜单栏中有两个菜单File和Edit</li>
<li>File菜单包含New、Open和Exit</li>
<li>Edit菜单包含Cut、Copy和Paste</li>
<li>除Exit功能外其他功能被关闭<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class MenuText extends Frame &#123;
    &#x2F;&#x2F; 创建菜单子项
    MenuItem fileNew &#x3D; new MenuItem(&quot;New&quot;);
    MenuItem fileOpen &#x3D; new MenuItem(&quot;Open&quot;);
    MenuItem fileExit &#x3D; new MenuItem(&quot;Exit&quot;);
    MenuItem editCut &#x3D; new MenuItem(&quot;Cut&quot;);
    MenuItem editCopy &#x3D; new MenuItem(&quot;Copy&quot;);
    MenuItem editPaste &#x3D; new MenuItem(&quot;Paste&quot;);

    &#x2F;&#x2F; 创建一个文本区域
    TextArea T &#x3D; new TextArea();

    public MenuText(String title) throws HeadlessException &#123;
        super(title);
        setSize(300,200);
        setVisible(true);
        add(T);

        &#x2F;&#x2F; 创建菜单条
        MenuBar menuBar &#x3D; new MenuBar();

        &#x2F;&#x2F; 创建菜单选项
        Menu file &#x3D; new Menu(&quot;file&quot;);
        &#x2F;&#x2F; 添加子项，设置某些选项为不可用
        file.add(fileNew);
        fileNew.setEnabled(false);
        file.add(fileOpen);
        fileOpen.setEnabled(false);
        &#x2F;&#x2F; 添加一条横线
        file.addSeparator();
        file.add(fileExit);
        fileExit.setEnabled(true);
        fileExit.addActionListener(e -&gt; &#123;
            &#x2F;&#x2F; 若事件来源为fileExit，则关闭窗口
            if (e.getSource() &#x3D;&#x3D; fileExit) &#123;
                System.exit(0);
            &#125;
        &#125;);

        Menu Edit &#x3D; new Menu(&quot;Edit&quot;);
        Edit.add(editCut);
        editCut.setEnabled(false);
        Edit.add(editCopy);
        editCopy.setEnabled(false);
        Edit.add(editPaste);
        editPaste.setEnabled(false);

        &#x2F;&#x2F; 添加菜单选项到菜单条
        menuBar.add(file);
        menuBar.add(Edit);
        &#x2F;&#x2F; 添加菜单条到窗口
        setMenuBar(menuBar);

    &#125;
&#125;

class Main &#123;
    public static void main(String[] args) &#123;
        new MenuText(&quot;MenuText&quot;);
    &#125;
&#125;</code></pre>
<br /></li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>组件颜色设置<ol>
<li>可以使用java.awt.Color类提供的颜色常数</li>
<li>可以使用构造方法<code>Color(int r, int g, int b);</code>自定义颜色<br /></li>
</ol>
<ul>
<li>组件中常用的颜色设置：<ol>
<li>setForeground(Color c);<br> 设置前景色</li>
<li>setbackground(Color c);<br> 设置背景色</li>
</ol>
</li>
</ul>
</li>
<li>组件字体设置<ul>
<li>java.awt.Font类提供了字体的操作</li>
<li>构造一个Font对象：  <pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">Font myFont &#x3D; new Font(String name, int style, int size);</code></pre>
<ol>
<li>name：逻辑字体名（如宋体等</li>
<li>style：可选Font.PLAIN（标准）、Font.BOLD（加粗）、Font.ITALIC（斜体）</li>
<li>size：字体大小<br /></li>
</ol>
</li>
<li>然后通过<code>setFont(Font f);</code>方法应用该字体到组件</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="swing图形界面"><a href="#swing图形界面" class="headerlink" title="swing图形界面"></a>swing图形界面</h1><ul>
<li><p>javax.swing是awt的一个拓展，并且优于awt</p>
</li>
<li><p>swing大部分组件名都是awt组件名前加一个J（如JFrame</p>
<br /></li>
<li><p>swing有四个最重要的类：</p>
<ol>
<li>JApplet</li>
<li>JFrame</li>
<li>JDialog</li>
<li>JComponent<blockquote>
<p>这四个都是<span class="keyword">重组件</span>，即有同位体的组件，又称顶层容器</p>
</blockquote>
<ul>
<li>同位体：同位体即每个操作系统对于该组件有着不同的表示界面，这个界面即为这个组件的同位体</li>
</ul>
</li>
</ol>
</li>
<li><p><span class="keyword">轻组件必须在重组件中</span></p>
</li>
<li><p>swing的组件从功能上分为：</p>
<ol>
<li>顶层容器：JFrame、JApplet、JDalog、JWindow</li>
<li>中间容器：JPanel、JScrollPane、JSplitPane、JToolBar</li>
<li>特殊容器：JInternalFrame、JLayeredPane、JRootPane</li>
<li>基本控件：（交互组件）JButton、JConboBox、JList、JMenu、JSlider、JTextField</li>
<li>不可编辑的信息显示：JLabel、JProgressBar、JToolTip</li>
<li>可编辑的信息显示：JColorChooser、JFileChosser、JTable、JTextArea<br /></li>
</ol>
</li>
<li><p>javax.swing.event包中定义了事件和事件监听器类</p>
</li>
<li><p>javax.swing.table包中包括了表格组件的支持类</p>
</li>
</ul>
<hr>
<ul>
<li><p>使用swing的基本规则</p>
<ul>
<li>swing组件不能直接添加到顶层容器中，它必须添加到一个与swing顶层容器相关联的内容面板上（content pane）<blockquote>
<p>内容面板是顶层容器包含的一个普通容器</p>
</blockquote>
</li>
<li>尽量避免使用非swing组件</li>
</ul>
  <br />

<ul>
<li>对于JFrame顶层容器而言，添加组件有两种方式：<ol>
<li>使用<code>getContentPanel();</code>方法获得JFrame的内容面饭，再对其加入组件，如：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">myFrame.getContentPanel().add(new JButton);</code></pre></li>
<li>建立一个JPanel或JDesktopPane之类的中间容器，使用<code>setContentPanel();</code>把该容器设置为该顶层容器的内容面板，如：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F; 创建中间容器
JPanel contentPane &#x3D; new JPanel();
&#x2F;&#x2F; ...（把组件添加到JPanel中）
&#x2F;&#x2F; 把中间容器设置为内容面板
myFrame.setContentPanel(contentPane);</code></pre></li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>各种容器面板</p>
<ul>
<li>根面板<ul>
<li>根面板由：<ol>
<li>玻璃面板（GlassPane）<blockquote>
<p>玻璃面板完全透明，默认不可见，未接收鼠标事件和在所有组件上绘图提供方便</p>
</blockquote>
</li>
<li>内容面板（ContentPane）</li>
<li>可选的菜单条（JMenuBar）<br>组成</li>
</ol>
</li>
<li>根面板提供的方法：<ol>
<li>Container getContentPane();<br> 获得内容面板</li>
<li>setContentPane(Container c);<br> 设置内容面板</li>
<li>JMenuBar getMenuBar();<br> 获得菜单条</li>
<li>setMenuBar(JMenuBar jMenuBar);<br> 设置菜单条</li>
<li>JLayeredPane getLayeredPane();<br> 获得分层面板</li>
<li>setLayeredPane(JLayeredPane jLayeredPane);<br> 设置分层面板</li>
<li>Component getGlassPane();<br> 获得玻璃面板</li>
<li>setGlassPanel(Component component);<br> 设置玻璃面板</li>
</ol>
</li>
</ul>
</li>
<li>分层面板<ul>
<li>swing提供两种分层面板：<ol>
<li>JLayeredPane</li>
<li>JDesktopPane（是上一个的子类）</li>
</ol>
</li>
<li>分层面板专门为容纳内部框架而设置</li>
</ul>
</li>
<li>面板（JPanel）<ul>
<li>用法和Panel相同，通常用于容器的嵌套</li>
</ul>
</li>
<li>滚动窗口（JScrollPane）<ul>
<li>JScrollPane是带滚动条的面板，主要通过移动JViewport（视口）来实现</li>
</ul>
</li>
<li>分隔板（JSplitPane）<ul>
<li>分隔板用于分隔两个组件，这两个组件可以按照水平方法或垂直方法分隔</li>
</ul>
</li>
<li>选项板（JTablePane）<ul>
<li>提供一组可供用户选择的带有标签或图标的选项，每个选项下面都可以显示一个组件</li>
</ul>
</li>
<li>工具栏（JToolBar）<ul>
<li>用于显示常用工具空间的容器，其位置通常处于菜单条或标题栏下，但也可以改变位置</li>
<li>用户可以把工具栏拖出，形成一个独立的工具控件窗</li>
</ul>
</li>
<li>内部框架（JInternealFrame）<ul>
<li>内部框架就如同一个窗口在另一个窗口内部，使用时必须遵循以下规则：<ol>
<li>必须把内部框架添加到一个容器中（通常为JDesktopPane），否则不显示</li>
<li>不必使用show()或setVisible()方法，内部框架爱随所在容器一起显示</li>
<li>必须用setSize();或pack()或setBounds()方法设置框架的尺寸，否则尺寸为0，框架不能显示</li>
<li>可以用setLocation()或setBounds()方法设置内部框架在容器中的位置，缺省值为(0,0)即容器左上角</li>
<li>内部框架中添加组件要添加在它的内容面板上</li>
<li>在内部框架中建立对话框，不能使用JDialog这样的顶层容器，必须使用JOptionPane或JInternalFrame</li>
<li>内部框架不能监听窗口事件，但其有一个自己的内部框架事件（JInternalFrameEvent）处理内部框架窗口操作<br /></li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>各种组件</p>
<ul>
<li>按钮（JButton）<ul>
<li>swing的按钮可以显示标签或图像</li>
<li>构造方法：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F; 按钮上显示图标
JButton(Icon icon);
&#x2F;&#x2F; 按钮上显示字符
JButton(String text);
&#x2F;&#x2F; 按钮上显示图标和字符
JBuuton(String text, Icon icon);</code></pre></li>
</ul>
</li>
<li>复选框（JCheckBox）</li>
<li>单选框（JRadioButton）<ul>
<li>单选框的功能与awt中的复选框组类似，只能有一个被选择</li>
</ul>
</li>
<li>选择框（JComboBox）<ul>
<li>每次只能选择其中的一项，但是可编辑每项的内容，而且每项的内容可以是任意类，不局限于String</li>
</ul>
</li>
<li>文件选择器（JFileChooser）</li>
<li>标签（JLabel）<ul>
<li>swing的标签可以带图形</li>
</ul>
</li>
<li>列表（JList）<ul>
<li>使用与数量较多的选项显示，选项可以由任意类型对象构成，支持单选和多选</li>
</ul>
</li>
<li>进程条（JProgressBar）<ul>
<li>提供一个直观的图形表示从无到满</li>
</ul>
</li>
<li>滑动条（JSlider）<ul>
<li>使用户可以通过一个滑块的来回移动输入数据</li>
</ul>
</li>
<li>菜单（JMenu）<ul>
<li>swing的菜单项可以同时显示图标和文字</li>
<li>可以通过<code>setMenuBar();</code>将菜单放置到容器的任意位置</li>
</ul>
</li>
<li>表格（JTable）<ul>
<li>把数据以二维表格的形式显示出来</li>
</ul>
</li>
<li>树（JTree）<ul>
<li>显示一个层次关系分明的一组数据，类似于资源管理器的左半部的目录索引</li>
</ul>
</li>
<li>对话框（JOptionPane）<ul>
<li>swing提供了JOptionPane来实现Windows平台下的MessageBox功能，利用该类中的各个static方法来生成各种标准对话框，以实现显示出信息、提出问题、警告、用户输入参数等功能</li>
<li>对话框的种类有：<ol>
<li>ConfirmDialog<br> 确认对话框，提出问题，然后由用户自己来确认是与否</li>
<li>InputDialog<br> 提示输入文本</li>
<li>MessageDialog<br> 提示信息</li>
<li>OptionDialog<br> 组合其他三种对话框类型</li>
</ol>
</li>
<li>这四种对话框分别可以使用方法showXXXDialog()来显示</li>
<li>showXXXDialog方法的几个常用共有参数：<ol>
<li>Component：只是对话框的父窗口对象，一般为当前窗口，也可以为null采用缺省值Frame作为父窗口，此时对话框被设置在屏幕的正中</li>
<li>message：指定要在对话框内提示的描述性文字</li>
<li>title：标题文字串</li>
<li>messageType：对话框样式，可以取以下值：<ul>
<li>ERROR_MASSAGE：错误信息，叉图标</li>
<li>INFORMATION_MESSAGE：信息，叹号对话图标</li>
<li>WARNING_MESSAGE：警告信息，叹号三角图标</li>
<li>QUESTION_MESSAGE：问题信息，问号对话图标</li>
<li>PLAIN_MESSAGE：无格式信息，无图标</li>
</ul>
</li>
<li>Icon：对话框要显示的图标</li>
<li>optinType：指定在对话框底部要显示的按钮</li>
<li>intialSelectionValue：输入值中的初始值<br /></li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>布局管理器</p>
<ul>
<li>因为swing不能直接在顶层容器里加组件，只能在内容面板加，因此布局管理器也只针对内容面板</li>
</ul>
</li>
<li><p>事件处理</p>
<ul>
<li>swing的事件处理沿用awt的java.awt.event，同时也有自己的javax.swing.event</li>
</ul>
</li>
</ul>
<hr>
<h1 id="Applet应用"><a href="#Applet应用" class="headerlink" title="Applet应用"></a>Applet应用</h1><ul>
<li><p>Applet是在浏览器中运行的程序，必须要创建HTML文件载入Applet程序</p>
</li>
<li><p>每个Applet必须是通过继承Applet类来实现的</p>
<br /></li>
<li><p>Applet生命周期</p>
<ul>
<li>Applet生命周期是指从Applet下载到浏览器，到用户退出浏览器终止Applet运行的过程</li>
<li>Applet生命周期包括：<ol>
<li>初始化 init()<blockquote>
<p>装载Applet时自动调用，只执行一次，用于完成一些初始化操作</p>
</blockquote>
</li>
<li>开始运行 start()<blockquote>
<p>初始化后或重新进入页面时调用，是Applet的主体</p>
</blockquote>
</li>
<li>停止运行 stop()<blockquote>
<p>离开Applet所在页面时自动调用，用于停止消耗系统资源</p>
</blockquote>
</li>
<li>撤销清理 destroy()<blockquote>
<p>浏览器关闭时自动调用，用于清理Applet所使用的所有资源</p>
</blockquote>
</li>
</ol>
</li>
<li>当Applet被浏览器调用的时候，上面四个方法自动执行</li>
</ul>
</li>
<li><p>Applet是一个面板容器，且是java.awt.Panel子类，默认使用FlowLayout流布局，可以在Applet中设置并操作AWT组件</p>
</li>
<li><p>JApplet是swing的一种顶层容器，可以在JApplet中添加组件并操作</p>
</li>
</ul>
<br />

<ul>
<li><p>Applet主要显示方法：</p>
<ol>
<li>paint(Graphics g);<br> 实例g由浏览器生成，它包含了Applet的图形上下文信息，相当于Applet中的画笔</li>
<li>update(Graphics g);<br> 首先清除背景，再调用paint()方法完成Applet的具体绘制</li>
<li>repaint();<br> 调用update()方法实现对Applet的更新</li>
</ol>
</li>
<li><p>HTML标记方法</p>
<blockquote>
<p>获取HTML文件中关于Applet的信息，如包含Applet的HTML文件的URL地址、通过HTML标记传给Applet的参数等</p>
</blockquote>
<ol>
<li>URL getDocumentBase();<br> 获取并返回包含Applet文档对象的URL</li>
<li>URL getCodeBase();<br> 获取并返回Applet类的URL</li>
<li>String getParamenter(String name);<br> 获取并返回在HTML文件的&lt;PARAM&gt;标记中传给Applet的参数</li>
</ol>
</li>
<li><p>Applet的编写</p>
<ul>
<li>基于awt的Applet<ol>
<li>导包<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">import java.applet.*;
import java.awt.*;</code></pre></li>
<li>声明一个类继承自Applet类<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class MyApplet extends Applet &#123;

&#125;</code></pre></li>
<li>重写init()、start()、stop()、destroy()等方法</li>
</ol>
</li>
<li>基于swing的Applet<ol>
<li>导包<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">import javax.swing.*;</code></pre></li>
<li>创建一个类继承自JApplet<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class AppletName extends JApplet &#123;

&#125;</code></pre></li>
<li>重写init()、start()、paint()等方法<br /></li>
</ol>
</li>
</ul>
</li>
<li><p>Applet的嵌入</p>
<ul>
<li>必须使用特殊的HTML标记&lt;applet&gt;，以实现Applet或JApplet的嵌入运行，如：<pre class="line-numbers language-HTML" data-language="HTML"><code class="language-HTML">&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Hello World&lt;&#x2F;title&gt;
    &lt;&#x2F;head&gt;
    &lt;applet code&#x3D;&quot;HelloApplet.class&quot; width&#x3D;300 height&#x3D;300&gt;

    &lt;&#x2F;applet&gt;
&lt;&#x2F;html&gt;</code></pre></li>
<li>Applet标签的属性：<ul>
<li>必须含有的属性</li>
</ul>
<ol>
<li>code = appletFile<br> 指明需要运行的applet类文件名</li>
<li>width = pixels<br> applet组件占页面的宽度</li>
<li>height = pixels<br> applet组件占页面的高度<br /></li>
</ol>
<ul>
<li>可选的属性</li>
</ul>
<ol>
<li>codebase = codebaseURL<br> 指明Applet类文件所在的URL基址，getCodeBase()方法可以获取该属性。若这个属性没有指明，则Applet类文件必须与包含它的HTML页面在同一个地方，此时getCodeBase()方法返回值与getDocumentBase()的返回值相同</li>
<li>ALT = alternateText<br> 若浏览器支持Applet但不能运行它，就显示alternateText信息，若没给则忽略</li>
<li>name = appletInstanceName<br> 指明Applet类运行时的实例名，使同处于一个页面的不同Applet之间能互相通信getAppletContext()方法可以得到同一个页面的其他Applet类</li>
<li>align = alignment<br> 指定Applet组件在浏览器中的对齐方式</li>
<li>vspace = pixels hspace = pixels<br> Applet在浏览器中显示时上下/左右预留的高度和宽度<br /></li>
</ol>
</li>
</ul>
</li>
<li><p>利用标记向Applet中传递参数</p>
  <pre class="line-numbers language-HTML" data-language="HTML"><code class="language-HTML">&lt;param name&#x3D;appletParameter value&#x3D;value&gt;
&lt;!-- name：指定参数名 --&gt;
&lt;!-- value：指定传入参数的值 --&gt;</code></pre>
<ul>
<li>&lt;param&gt;标签可以使Applet使用getParameter()方法从HTML页面中获取所需的参数<br /></li>
<li>例子：<pre class="line-numbers language-HTML" data-language="HTML"><code class="language-HTML">&lt;!-- HTML中 --&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Applet Test&lt;&#x2F;title&gt;
    &lt;&#x2F;head&gt;
    &lt;applet code&#x3D;&quot;Appletpara.class&quot; width&#x3D;300 height&#x3D;300&gt;
        &lt;param name&#x3D;&quot;num01&quot; value&#x3D;&quot;11&quot;&gt;
        &lt;param name&#x3D;&quot;num02&quot; value&#x3D;&quot;22&quot;&gt;
    &lt;&#x2F;applet&gt;
&lt;&#x2F;html&gt;</code></pre>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F; Java中
public class Appletpara extends Applet &#123;
    String s1, s2;
    public void init() &#123;
        s1 &#x3D; getParameter(&quot;num01&quot;);
        s2 &#x3D; getParameter(&quot;num02&quot;);
    &#125;
&#125;</code></pre></li>
</ul>
</li>
</ul>
<hr>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><ul>
<li>集合是用于存放数据的盒子，集合类有以下特点：<ol>
<li>集合类中只容纳对象名</li>
<li>集合类中容纳的元素都是Object类型，一旦把一个对象放入集合类中，它的类信息将丢失</li>
<li>集合类大小可变</li>
</ol>
</li>
<li>变量、数组与集合<ol>
<li>变量：只能存放一个数据</li>
<li>数组：数组大小固定不变，可以存放多个数据但数据是同一类型</li>
<li>集合：集合大小可以动态增长，可以存放多个不同类型数据</li>
</ol>
</li>
<li>Java集合结构由两颗接口树构成：<ol>
<li>第一棵树根节点为Conllection接口，它定义了所有几何的基本操作，如添加、删除、遍历等。</li>
<li>第二棵树根节点为Map接口，与哈希表相似</li>
</ol>
</li>
</ul>
<br />

<ul>
<li>Java主要有三个类型的集合：<ol>
<li>集（Set）：集里的对象不按照任何特定的方式排列，按索引值来操作数据，不能有重复数据</li>
<li>列表（List）：序列中的对象以线性方式存储，按索引值来操作数据，可以有重复元素</li>
<li>映射（Map）：映射的每一项为“名称——值”对，名称不可以重复，值可重复，一个名称对应一个值</li>
</ol>
</li>
<li>简单集合类<ol>
<li>Vector：实现动态数组，其大小可以根据需要增大或缩小，以适应创建Vector后进行添加或移除的操作</li>
<li>ArrayList：实现了List接口，List接口实现大小可变的数组，ArrayList大致等同于Vector类，除了此类是不同步的<blockquote>
<p>注意：从集合中取出对象时要强制转换为对象原来的数据类型，否则取出的为Object</p>
</blockquote>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">List stuList &#x3D; new ArrayList();
stuList.add(new Student(&quot;张三&quot;, &quot;20030502&quot;));
stuList.add(new Student(&quot;李四&quot;, &quot;20161106&quot;));
Student s1 &#x3D; (Student)stuList.get(0);</code></pre></li>
</ol>
</li>
</ul>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><ul>
<li><p>为了使存入集合后数据的类型不变，取出时不需要类型转换，使用泛型机制</p>
</li>
<li><p>使用泛型改写上面的例子：</p>
  <pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">List&lt;Student&gt; stuList &#x3D; new ArrayList&lt;Student&gt;();
stuList.add(new Student(&quot;张三&quot;, &quot;20030502&quot;));
stuList.add(new Student(&quot;李四&quot;, &quot;20161106&quot;));
Student s1 &#x3D; stuList.get(0);</code></pre>
<br /></li>
<li><p>泛型类</p>
<ul>
<li>带有参数化类型的类<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class 类名&lt;T&gt; &#123;

&#125;</code></pre></li>
</ul>
</li>
<li><p>泛型接口</p>
  <pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">interface 类名&lt;T&gt; &#123;

&#125;</code></pre></li>
<li><p>泛型方法</p>
  <pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public &lt;T&gt; 返回值 getName(T x) &#123;

&#125;</code></pre></li>
</ul>
<h1 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h1><p><img src="https://s4.ax1x.com/2022/02/23/bP1LYd.png" alt="bP1LYd.png"><br><img src="https://s4.ax1x.com/2022/02/23/bP1qFH.png" alt="bP1qFH.png"></p>
<ul>
<li><p>一些关于树的概念：</p>
<ul>
<li>根节点：没有父节点的节点（最上面那个</li>
<li>父节点：每个节点的前件（上面那个）为该节点的父节点</li>
<li>子节点：每个节点的后件（下面那个）为该节点的子节点</li>
<li>叶子结点：没有后件的节点为叶子结点</li>
<li>度：一个节点拥有的后件为度，所有节点的度取最大值为树的度</li>
<li>深度：定义根节点为第一层，往下依次递增，树的最大层数为深度<br /></li>
</ul>
</li>
<li><p>二叉树的定义：</p>
<ul>
<li>可以为空，空二叉树无节点，非空二叉树有且只有一个根节点</li>
<li>每个节点最多有两棵子树，二叉树中不存在度大于2的节点</li>
<li>二叉树的子树有左右之分，次序不能颠倒</li>
</ul>
</li>
<li><p>二叉树的遍历</p>
<ul>
<li>前序遍历：根节点出发，遍历全部左边节点，从尾部开始遇到分支就访问右分支<blockquote>
<p>ABCDFEGHIJ<br><img src="https://s4.ax1x.com/2022/02/23/bPJRHK.jpg" alt="bPJRHK.jpg"></p>
</blockquote>
</li>
<li>中序遍历：左父右，然后返回到上一级的左父右<blockquote>
<p>DCFBEAGHIJ<br><img src="https://s4.ax1x.com/2022/02/23/bPJ2B6.jpg" alt="bPJ2B6.jpg"></p>
</blockquote>
</li>
<li>后序遍历：先左后右再父<blockquote>
<p>DFCEBAJHIGA<br><img src="https://s4.ax1x.com/2022/02/23/bPJgnx.jpg" alt="bPJgnx.jpg"></p>
</blockquote>
</li>
</ul>
</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/11/07/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" rel="prev" title="Java网络编程">
                  <i class="fa fa-chevron-left"></i> Java网络编程
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/02/22/Java%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84/" rel="next" title="Java注解与反射">
                  Java注解与反射 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Loliconkelvin</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdn.jsdelivr.net/npm/ribbon.js@1.0.2/dist/ribbon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.24.1/components/prism-core.min.js" integrity="sha256-dz05jjFU9qYuMvQQlE6iWDtNAnEsmu6uMb1vWhKdkEM=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.24.1/plugins/autoloader/prism-autoloader.min.js" integrity="sha256-sttoa+EIAvFFfeeIkmPn8ypyOOb6no2sZ2NbxtBXgqU=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.24.1/plugins/line-numbers/prism-line-numbers.min.js" integrity="sha256-K837BwIyiXo5k/9fCYgqUyA14bN4/Ve9P2SIT0KmZD0=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
