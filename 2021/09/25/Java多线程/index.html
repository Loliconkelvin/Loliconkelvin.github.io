<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"loliconkelvin.github.io","root":"/","images":"/images","scheme":"Pisces","version":"8.7.1","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":true,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content=".red {     color: red; }   Java多线程">
<meta property="og:type" content="article">
<meta property="og:title" content="Java多线程">
<meta property="og:url" content="https://loliconkelvin.github.io/2021/09/25/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="萝莉控的小窝">
<meta property="og:description" content=".red {     color: red; }   Java多线程">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://z3.ax1x.com/2021/09/28/4fgqPS.png">
<meta property="article:published_time" content="2021-09-25T01:44:45.000Z">
<meta property="article:modified_time" content="2021-10-08T15:13:41.193Z">
<meta property="article:author" content="Loliconkelvin">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://z3.ax1x.com/2021/09/28/4fgqPS.png">


<link rel="canonical" href="https://loliconkelvin.github.io/2021/09/25/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://loliconkelvin.github.io/2021/09/25/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/","path":"2021/09/25/Java多线程/","title":"Java多线程"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Java多线程 | 萝莉控的小窝</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">萝莉控的小窝</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">多线程的一些概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%89%E7%A7%8D%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="nav-number">2.</span> <span class="nav-text">线程三种创建方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BFThread%E7%B1%BB%EF%BC%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%EF%BC%89"><span class="nav-number">2.1.</span> <span class="nav-text">继承Thread类（不建议使用）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E7%BD%91%E5%9B%BE%E4%B8%8B%E8%BD%BD"><span class="nav-number">2.1.1.</span> <span class="nav-text">应用——网图下载</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3%EF%BC%88%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%EF%BC%89"><span class="nav-number">2.2.</span> <span class="nav-text">实现Runnable接口（建议使用）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%EF%BC%88%E7%BA%BF%E7%A8%8B%E5%90%8D%E5%9C%A8%E8%BF%99%E9%87%8C%EF%BC%89%E4%B8%8E%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="nav-number">2.3.</span> <span class="nav-text">并发（线程名在这里）与并发问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E9%BE%9F%E5%85%94%E8%B5%9B%E8%B7%91"><span class="nav-number">2.3.1.</span> <span class="nav-text">应用——龟兔赛跑</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3%EF%BC%88%E4%BA%86%E8%A7%A3%E5%8D%B3%E5%8F%AF-%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89"><span class="nav-number">2.4.</span> <span class="nav-text">实现Callable接口（了解即可 线程池）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%88Lamda%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%8C%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E5%9C%A8%E8%BF%99%E9%87%8C%EF%BC%89"><span class="nav-number">2.5.</span> <span class="nav-text">静态代理（Lamda表达式，函数式接口在这里）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.5.1.</span> <span class="nav-text">函数式接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Lamda%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E7%AE%80%E5%8C%96%EF%BC%89"><span class="nav-number">2.5.2.</span> <span class="nav-text">Lamda表达式（匿名内部类的简化）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%AE%80%E5%8C%96"><span class="nav-number">2.5.3.</span> <span class="nav-text">Lambda表达式的简化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E4%BE%8B%E5%AD%90%E2%80%94%E2%80%94%E7%94%B5%E5%BD%B1%E4%B8%8E%E5%B9%BF%E5%91%8A"><span class="nav-number">2.5.4.</span> <span class="nav-text">静态代理例子——电影与广告</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E4%BE%8B%E5%AD%90%E2%80%94%E2%80%94%E7%BB%93%E5%A9%9A%E8%80%85%E4%B8%8E%E5%A9%9A%E5%BA%86%E5%85%AC%E5%8F%B8%EF%BC%88%E8%BF%99%E4%B8%AA%E4%BE%8B%E5%AD%90%E6%9B%B4%E7%9B%B4%E8%A7%82%EF%BC%89"><span class="nav-number">2.5.5.</span> <span class="nav-text">静态代理例子——结婚者与婚庆公司（这个例子更直观）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.5.6.</span> <span class="nav-text">静态代理与多线程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="nav-number">3.</span> <span class="nav-text">线程状态</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Loliconkelvin"
      src="/uploads/avatar.png">
  <p class="site-author-name" itemprop="name">Loliconkelvin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Loliconkelvin" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Loliconkelvin" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:loliconkelvin@gmail.com" title="E-Mail → mailto:loliconkelvin@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



          </div>
        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://loliconkelvin.github.io/2021/09/25/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Loliconkelvin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萝莉控的小窝">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java多线程
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-25 09:44:45" itemprop="dateCreated datePublished" datetime="2021-09-25T09:44:45+08:00">2021-09-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-08 23:13:41" itemprop="dateModified" datetime="2021-10-08T23:13:41+08:00">2021-10-08</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <style>
.red {
    color: red;
}
</style>

<p>Java多线程</p>
<span id="more"></span>

<h2 id="多线程的一些概念"><a href="#多线程的一些概念" class="headerlink" title="多线程的一些概念"></a>多线程的一些概念</h2><ul>
<li>一条线程就是一条独立的执行路径</li>
<li>在程序运行时，即使没有创建自己的线程，后台也会有多个线程，比如主线程和gc线程（垃圾回收）</li>
<li>main()称为主线程，为系统的入口</li>
<li>在一个进程中，若开辟了多线程，线程的先后运行由调度器安排，不能人为干预</li>
<li>多线程对同一份资源进行操作时，会存在资源抢夺问题，需要加入并发机制（边消费边取钱）</li>
<li>多线程会带来额外的开销（如CPU调度时间），可以用并发控制开销</li>
<li>每个线程在自己的工作内存交互，内存控制不当会导致数据不一致</li>
</ul>
<h2 id="线程三种创建方式"><a href="#线程三种创建方式" class="headerlink" title="线程三种创建方式"></a>线程三种创建方式</h2><h3 id="继承Thread类（不建议使用）"><a href="#继承Thread类（不建议使用）" class="headerlink" title="继承Thread类（不建议使用）"></a>继承Thread类（不建议使用）</h3><ul>
<li><p>创建步骤：</p>
<ol>
<li>创建一个类 并且 继承Thread类</li>
<li>重写 <code>run()</code> 方法 （这里就是写你这条线程要执行的东西）</li>
<li>创建线程：回到主线程，new一个刚刚创建的类的对象</li>
<li>开启线程：调用该类的 <code>start()</code> 方法<br> （若调用run方法，则是单线程，就跟平时调用方法一样，走完run()再回到主线）</li>
<li>当 <code>run()</code> 方法执行完之后，线程就会自动死亡<br /></li>
</ol>
</li>
<li><p>线程开启不一定立即执行，而是由CPU调度与主线程交替并行</p>
</li>
</ul>
<h4 id="应用——网图下载"><a href="#应用——网图下载" class="headerlink" title="应用——网图下载"></a>应用——网图下载</h4><ol>
<li><p>事前准备</p>
<ol>
<li>下载 <code>commons-io</code> 工具包（jar）</li>
<li>在项目文件夹下新增lib文件夹，把下载的工具包扔进去</li>
<li>将其增加为项目的库函数<blockquote>
<p>右键工具包 -&gt; Add as library -&gt; OK</p>
<br /></blockquote>
</li>
</ol>
</li>
<li><p>写多线程类</p>
<ol>
<li>写一个类 并 继承Thread类</li>
<li>重写 <code>run()</code> 方法,使用 commons-io 工具包下的 FileUtils 类 中的 <code>copyURLToFile</code> 方法实现网图下载</li>
<li>发现该方法要传入两个参数：<ol>
<li>URL类型的形参，new一个<ul>
<li>URL类型的构造需要传入一个String，在方法外面创建一个，作为构造多线程类所需要的形参</li>
</ul>
</li>
<li>File类型的形参，new一个<ul>
<li>File类型的构造需要传入一个String，同上</li>
</ul>
</li>
</ol>
<ul>
<li>这里可以在方法外面new，也可以在形参这里new匿名对象</li>
</ul>
</li>
<li>发现该方法还用Throws甩了一个异常，用try-catch包围（Alt + Enter自动纠错大法好）,并处理异常</li>
<li>写该多线程类的构造方法<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.company.demo;

import org.apache.commons.io.FileUtils;

import java.io.File;
import java.io.IOException;
import java.net.URL;

public class DownloadThread extends Thread &#123;
    private final String url;
    private final String fileName;

    public DownloadThread(String url, String fileName) &#123;
        this.url &#x3D; url;
        this.fileName &#x3D; fileName;
    &#125;

    @Override
    public void run() &#123;
        try &#123;
            FileUtils.copyURLToFile(new URL(url), new File(fileName));
            System.out.println(fileName + &quot;文件已下载&quot;);
        &#125; catch (IOException e) &#123;
            System.out.println(&quot;IO流错误，来自run&quot;);
            e.printStackTrace();
        &#125;
    &#125;
&#125;</code></pre>
<br /></li>
</ol>
</li>
<li><p>写主函数</p>
<ol>
<li>在主函数里new一个或多个多线程类，根据其构造方法传入对应参数</li>
<li>分别使用 <code>对象名.start();</code> 启动一个或多个线程<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.company.demo;

public class Main &#123;
    public static void main(String[] args) &#123;
        DownloadThread thread1 &#x3D; new DownloadThread(&quot;https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20190829105807206.png&quot;, &quot;1.jpg&quot;);
        DownloadThread thread2 &#x3D; new DownloadThread(&quot;https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20190829105807206.png&quot;, &quot;2.jpg&quot;);
        thread1.start();
        thread2.start();
    &#125;
&#125;</code></pre></li>
</ol>
</li>
</ol>
<h3 id="实现Runnable接口（建议使用）"><a href="#实现Runnable接口（建议使用）" class="headerlink" title="实现Runnable接口（建议使用）"></a>实现Runnable接口（建议使用）</h3><ul>
<li><p>创建步骤：</p>
<ol>
<li>写一个类 并 实现Runnable接口</li>
<li>马上重写 <code>run()</code></li>
<li>回到主函数，new一个刚刚写的类</li>
<li><span class="red">接下来的步骤与继承Thread类的不同：</span><ul>
<li>new一个Thread类，并把刚刚new的多线程类的对象作为形参丢进去，<span class="red">用new出来的Thread对象调用 <code>start()</code> 方法</span><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">TestThread testThread &#x3D; new TestThread();

&#x2F;&#x2F; 创建线程对象，通过线程对象开启线程 代理
new Thread(testThread).start();</code></pre></li>
</ul>
</li>
</ol>
</li>
<li><p>好处：避免单继承的局限性，接口可以多继承，可以实现一个多线程对象被多个线程调用（详见下一标题）</p>
</li>
</ul>
<h3 id="并发（线程名在这里）与并发问题"><a href="#并发（线程名在这里）与并发问题" class="headerlink" title="并发（线程名在这里）与并发问题"></a>并发（线程名在这里）与并发问题</h3><ul>
<li>并发是指多线程操作一个对象，他们共享对象里的变量</li>
</ul>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.company.demo;

public class TrainTickets implements Runnable&#123;
    private int ticketsNumber &#x3D; 10;

    @Override
    public void run() &#123;
        while (true) &#123;

            if (ticketsNumber &#x3D;&#x3D; 0) &#123;
                break;
            &#125;

            &#x2F;&#x2F; 模拟延时
            try &#123;
                Thread.sleep(200);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;

            System.out.println(Thread.currentThread().getName() + &quot;拿到了&quot; + ticketsNumber-- + &quot;号票&quot;);
        &#125;
    &#125;
&#125;</code></pre>

<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">TrainTickets trainTickets &#x3D; new TrainTickets();
&#x2F;&#x2F; 可以使用第二个参数给线程命名
new Thread(trainTickets, &quot;1&quot;).start();
new Thread(trainTickets, &quot;2&quot;).start();
new Thread(trainTickets, &quot;3&quot;).start();

&#x2F;*
其中一次输出：
2拿到了10号票
1拿到了9号票
3拿到了9号票
3拿到了6号票
1拿到了7号票
2拿到了8号票
1拿到了4号票
2拿到了3号票
3拿到了5号票
3拿到了2号票
1拿到了1号票
2拿到了2号票
*&#x2F;</code></pre>

<ul>
<li>可以看到有重复的票，这就是不安全的线程，即并发问题</li>
</ul>
<h4 id="应用——龟兔赛跑"><a href="#应用——龟兔赛跑" class="headerlink" title="应用——龟兔赛跑"></a>应用——龟兔赛跑</h4><ol>
<li><p>程序规划</p>
<ol>
<li>需要一条赛道</li>
<li>每次跑需要判断比赛是否结束，结束了就不用跑了</li>
<li>如果有胜利者，打印出胜利者</li>
<li>龟和兔一起跑，为双线程</li>
<li>（扩展）模拟兔子睡觉<br /></li>
</ol>
</li>
<li><p>程序实现</p>
<ol>
<li><p>需要赛道</p>
<ul>
<li>我们可以直接在类里把赛道长度写死，也可以使用传入参数至构造函数的方法在主函数定义赛道</li>
</ul>
<ol>
<li>首先创建一个类实现Runnable接口，重写run()方法，（如需自定义赛道）写有参构造<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.company.demo;

public class Race implements Runnable &#123;
    private int length;

    &#x2F;&#x2F; 定义赛道长度
    public Race(int length) &#123;
        this.length &#x3D; length;
    &#125;

    @Override
    public void run() &#123;
    &#125;
&#125;</code></pre></li>
<li>开始跑，写一个for记录步数，当步数的范围是 0~赛道长度 （可以等于）<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">for (int step &#x3D; 0; step &lt;&#x3D; length; step++) &#123;
    System.out.println(Thread.currentThread().getName() + &quot;跑了&quot; + step + &quot;步&quot;);
&#125;</code></pre>
<br /></li>
</ol>
</li>
<li><p>写一个方法，判断是否已有选手完赛，若没有，判断自身是否完赛</p>
<ul>
<li>注意是下图逻辑，就不要想else if了<br><img src="https://z3.ax1x.com/2021/09/28/4fgqPS.png" alt="4fgqPS.png"></li>
</ul>
<ol>
<li>写方法以判断是否有胜者<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private static String winner;

private boolean gameOver(int step) &#123;
    &#x2F;&#x2F; 有胜者了
    if (winner !&#x3D; null) &#123;
        return true;
        &#x2F;&#x2F;还没有胜者，判断当前选手是否跑完
    &#125; else &#123;
        if (step &gt;&#x3D; length) &#123;
            winner &#x3D; Thread.currentThread().getName();
            System.out.println(&quot;winner is &quot; + winner);
            return true;
            &#x2F;&#x2F; 还没有胜者，当前选手没跑完，返回假
        &#125; else &#123;
            return false;
        &#125;
    &#125;
&#125;</code></pre></li>
<li>选手每跑一步执行该方法判断一下（在输出步数下面加）<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F; 比赛结束就不用跑了
if (gameOver(step))&#123;
    break;
&#125;</code></pre></li>
</ol>
</li>
<li><p>在主函数启动线程</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.company.demo;

public class Main &#123;
    public static void main(String[] args) &#123;
        Race race &#x3D; new Race(100);

        new Thread(race, &quot;兔子&quot;).start();
        new Thread(race, &quot;乌龟&quot;).start();
    &#125;
&#125;</code></pre>
<br /></li>
</ol>
</li>
<li><p>模拟兔子睡觉</p>
</li>
</ol>
<ul>
<li><p>这里会提一下sleep线程休眠，后面还会详细讲到</p>
</li>
<li><p>这里还会有如何让特定的线程休眠</p>
</li>
<li><p>如何让特定的线程休眠：</p>
<ol>
<li>首先线程一定要有名字</li>
<li>CPU执行什么线程有它自己决定，说明同一时间只能执行一个线程，因此只需要通过判断一下线程名得知目前执行的线程是否是要休眠的线程即可,然后就可以让当前线程睡觉<ul>
<li>使用 <code>equals()</code> 方法对比</li>
</ul>
</li>
<li>注意线程休眠函数会甩个异常出来<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F; 模拟兔子睡觉
if (Thread.currentThread().getName().equals(&quot;兔子&quot;) &amp;&amp; (step % 10 &#x3D;&#x3D; 0)) &#123;
    try &#123;
        Thread.sleep(10);
    &#125; catch (InterruptedException e) &#123;
        e.printStackTrace();
    &#125;
&#125;</code></pre></li>
</ol>
</li>
</ul>
<h3 id="实现Callable接口（了解即可-线程池）"><a href="#实现Callable接口（了解即可-线程池）" class="headerlink" title="实现Callable接口（了解即可 线程池）"></a>实现Callable接口（了解即可 线程池）</h3><ul>
<li>好处：<ol>
<li>可以拥有返回值</li>
<li>可以抛出异常</li>
</ol>
</li>
<li>坏处：<ol>
<li>代码复杂</li>
</ol>
</li>
</ul>
<ol>
<li><p>写一个类 并 实现 Callable接口</p>
<ul>
<li><span class="red">注意：Callable接口需要一个返回值，在Callable后面跟一个&lt;&gt;</span></li>
<li><span class="red">该返回值是一个类，不是基本数据类型（注意区分Boolean和boolean）</span></li>
</ul>
 <pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.company.demo;

import java.util.concurrent.Callable;

public class CallableTest implements Callable&lt;Boolean&gt; &#123;

    @Override
    public Boolean call() throws Exception &#123;
        &#x2F;&#x2F; write code here
        return true;
    &#125;
&#125;</code></pre>
<br /></li>
<li><p>在主函数开启线程</p>
<ol>
<li>创建线程</li>
<li>创建线程池</li>
<li>把线程扔进线程池</li>
<li>接收线程执行结果</li>
<li>关闭线程池<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.company.demo;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class Main &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F; 创建线程
        CallableTest callable01 &#x3D; new CallableTest();
        CallableTest callable02 &#x3D; new CallableTest();

        &#x2F;&#x2F; 创建一个可以存放两个线程的线程池
        ExecutorService server &#x3D; Executors.newFixedThreadPool(2);

        &#x2F;&#x2F; 把线程扔（提交）进线程池
        Future&lt;Boolean&gt; r1 &#x3D; server.submit(callable01);
        Future&lt;Boolean&gt; r2 &#x3D; server.submit(callable02);

        &#x2F;&#x2F; 获取线程执行结果，注意接收异常
        try &#123;
            boolean rs1 &#x3D; r1.get();
            boolean rs2 &#x3D; r2.get();
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125; catch (ExecutionException e) &#123;
            e.printStackTrace();
        &#125;

        &#x2F;&#x2F; 关闭线程池
        server.shutdownNow();
    &#125;
&#125;</code></pre></li>
</ol>
</li>
</ol>
<h3 id="静态代理（Lamda表达式，函数式接口在这里）"><a href="#静态代理（Lamda表达式，函数式接口在这里）" class="headerlink" title="静态代理（Lamda表达式，函数式接口在这里）"></a>静态代理（Lamda表达式，函数式接口在这里）</h3><h4 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h4><ul>
<li><p>如果一个接口只包含一个抽象方法，那他就是函数式接口</p>
<br /></li>
<li><p>对于函数式接口，我们可以通过lamda表达式创建该接口的对象</p>
</li>
</ul>
<h4 id="Lamda表达式（匿名内部类的简化）"><a href="#Lamda表达式（匿名内部类的简化）" class="headerlink" title="Lamda表达式（匿名内部类的简化）"></a>Lamda表达式（匿名内部类的简化）</h4><ul>
<li><p><span class="red">用于简化创建函数式接口的对象，解决类只用一次的问题</span></p>
</li>
<li><p>可以写成匿名内部类的就可以写成Lambda表达式，格式为：</p>
  <pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F; 形参可选
(形参) -&gt; &#123;返回值&#125;

(形参) -&gt; &#123;语句;&#125;

&#x2F;&#x2F; 当只有一条语句时
(形参) -&gt; 语句;</code></pre></li>
<li><p>因为Lambda表达式的本质就是匿名内部类，因此他需要一个对象来接收，或者直接在一个以对象为形参的方法中被调用</p>
  <pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F; 接口
public interface ILove &#123;
    void printLove(String name);
&#125;

&#x2F;&#x2F; Main方法
public class Main &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F; 使用Lambda表达式实现接口
        &#x2F;&#x2F; 这里的形参可以不使用String name声明格式
        ILove iLove &#x3D; (name) -&gt; System.out.println(&quot;I love &quot; + name);
        &#x2F;&#x2F; 调用方法
        iLove.printLove(&quot;婉儿&quot;);
    &#125;
&#125;</code></pre></li>
</ul>
<h4 id="Lambda表达式的简化"><a href="#Lambda表达式的简化" class="headerlink" title="Lambda表达式的简化"></a>Lambda表达式的简化</h4><ul>
<li>当形参只有一个时，小括号可以去掉</li>
<li>当语句只有一条时，大括号可以去掉</li>
<li>形参的参数类型可以省略，当多个形参的情况下，要省略参数类型，就将全部形参的参数类型都省略</li>
</ul>
<h4 id="静态代理例子——电影与广告"><a href="#静态代理例子——电影与广告" class="headerlink" title="静态代理例子——电影与广告"></a>静态代理例子——电影与广告</h4><ul>
<li>电影院播放电影总是在电影前后播放一些广告，但是电影原原本的功能就是播放电影，他希望自己专注于电影的播放，则我们可以通过代理实现广告的播放 ——代理：对对象的功能进行拓展，完成一些对象不能完成的功能</li>
</ul>
<ol>
<li><p>需要一个播放器，抽象方法：播放</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public interface MoviePlayer &#123;
    void play();
&#125;</code></pre></li>
<li><p>对于电影这个类本身，他的实例是需要被播放的，因此它需要继承接口</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class Movie implements MoviePlayer&#123;
    @Override
    public void play() &#123;
        System.out.println(&quot;正在播放电影&quot;);
    &#125;
&#125;</code></pre></li>
<li><p>有请代理商</p>
<ol>
<li>他的广告也是需要被播放的，因此它也需要继承接口，并且他重写的方法可以加一些自己所需要的功能（方法）</li>
<li>名曰代理，因此他还需要顺便播放一下电影<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class Proxy implements MoviePlayer&#123;

    private Movie movie;

    public Proxy() &#123;
    &#125;

    public Proxy(Movie movie) &#123;
        this.movie &#x3D; movie;
    &#125;

    @Override
    public void play() &#123;
        advertisement();
        movie.play();
        advertisement();
    &#125;

    private void advertisement() &#123;
        System.out.println(&quot;正在播放广告&quot;);
    &#125;
&#125;</code></pre></li>
</ol>
</li>
<li><p>在Main方法里面创建电影实例，创建代理商实例，把电影实例丢给代理商，并由代理商执行play方法</p>
</li>
</ol>
<h4 id="静态代理例子——结婚者与婚庆公司（这个例子更直观）"><a href="#静态代理例子——结婚者与婚庆公司（这个例子更直观）" class="headerlink" title="静态代理例子——结婚者与婚庆公司（这个例子更直观）"></a>静态代理例子——结婚者与婚庆公司（这个例子更直观）</h4><ol>
<li><p>接口</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public interface Merry &#123;
    void getMerry();
&#125;</code></pre></li>
<li><p>本体</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class MerryPeople implements Merry&#123;
    @Override
    public void getMerry() &#123;
        System.out.println(&quot;婚礼开始了&quot;);
    &#125;
&#125;</code></pre></li>
<li><p>代理</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class MerryProxy implements Merry&#123;
    private MerryPeople people;

    public MerryProxy(MerryPeople people) &#123;
        this.people &#x3D; people;
    &#125;

    @Override
    public void getMerry() &#123;
        beforeMerry();
        people.getMerry();
        afterMerry();
    &#125;

    private void beforeMerry() &#123;
        System.out.println(&quot;婚礼之前，收定金，布置现场&quot;);
    &#125;

    private void afterMerry() &#123;
        System.out.println(&quot;婚礼之后，收尾款&quot;);
    &#125;
&#125;</code></pre></li>
<li><p>Main方法</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class Main &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F; 新建要结婚的对象（只有一个？）
        MerryPeople you &#x3D; new MerryPeople();
        &#x2F;&#x2F; 把对象扔给婚庆公司
        MerryProxy merryProxy &#x3D; new MerryProxy(you);
        &#x2F;&#x2F; 婚庆公司干活
        merryProxy.getMerry();
    &#125;
&#125;</code></pre></li>
</ol>
<h4 id="静态代理与多线程"><a href="#静态代理与多线程" class="headerlink" title="静态代理与多线程"></a>静态代理与多线程</h4><ul>
<li>在实现Runnable接口方法中，需要创建一个类实现Runnable接口并重写方法，然后创建该类的实例，将实例丢给Thread后由Thread执行start，这就是一个代理：Thread类代理了我们创建的类</li>
</ul>
<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/09/20/IDEA%E5%85%B3%E4%BA%8E%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E7%9A%84%E8%AE%BE%E5%AE%9A/" rel="prev" title="IDEA关于代码格式的设定">
                  <i class="fa fa-chevron-left"></i> IDEA关于代码格式的设定
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Loliconkelvin</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdn.jsdelivr.net/npm/ribbon.js@1.0.2/dist/ribbon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.24.1/components/prism-core.min.js" integrity="sha256-dz05jjFU9qYuMvQQlE6iWDtNAnEsmu6uMb1vWhKdkEM=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.24.1/plugins/autoloader/prism-autoloader.min.js" integrity="sha256-sttoa+EIAvFFfeeIkmPn8ypyOOb6no2sZ2NbxtBXgqU=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.24.1/plugins/line-numbers/prism-line-numbers.min.js" integrity="sha256-K837BwIyiXo5k/9fCYgqUyA14bN4/Ve9P2SIT0KmZD0=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
