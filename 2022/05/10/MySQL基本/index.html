<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"loliconkelvin.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.12.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":true,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content=".red {         color: red;     }     .bold {         font-weight: bold;     }   MySQL基本">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL基本">
<meta property="og:url" content="https://loliconkelvin.github.io/2022/05/10/MySQL%E5%9F%BA%E6%9C%AC/index.html">
<meta property="og:site_name" content="萝莉控的小窝">
<meta property="og:description" content=".red {         color: red;     }     .bold {         font-weight: bold;     }   MySQL基本">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/10/ON1DoR.md.jpg">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/Os1aPU.md.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/OsY4b9.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/OySRA0.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/OyigYt.md.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/Oyi2fP.md.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/OykhZQ.png">
<meta property="og:image" content="https://bkimg.cdn.bcebos.com/pic/8c1001e93901213f5a0febf15fe736d12f2e95db?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U4MA==,g_7,xp_5,yp_5/format,f_auto">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/OyMwlj.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/OyMy7V.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/OyMhc9.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/OyMvjA.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/OyQeun.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/OyQbbq.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/OyGEmd.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/23/XSlOpQ.md.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/23/XShq1S.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/23/X9MJBt.md.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/27/Xemf91.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/06/07/XD9Wlt.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/06/12/X2QJtU.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/06/17/XqAk4I.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/06/17/XqmA6x.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/06/17/XqnGG9.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/06/17/Xq2sYT.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/06/17/XqR8BR.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/06/17/XqTcpq.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/06/17/XqOZfH.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/06/17/XqOb3d.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/06/17/XqjawV.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/06/17/Xqvt9e.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/06/17/XqxtaV.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/06/16/X7QrKP.md.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/06/16/X71ATU.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/06/16/X71jnx.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/06/16/X7YIfS.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/06/16/X7w3Jx.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/06/16/X7DwTJ.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/06/16/X7DO0g.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/06/16/X7rRg0.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/06/16/X7ywTg.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/06/16/X7691I.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/06/16/X72n9H.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/06/16/X7RlRJ.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/06/16/X7W4AK.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/06/16/X7hkxH.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/06/16/XH73jO.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/06/16/XHOWct.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/06/16/XHjVRs.png">
<meta property="article:published_time" content="2022-05-10T01:42:26.000Z">
<meta property="article:modified_time" content="2022-06-19T02:42:54.995Z">
<meta property="article:author" content="Loliconkelvin">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s1.ax1x.com/2022/05/10/ON1DoR.md.jpg">


<link rel="canonical" href="https://loliconkelvin.github.io/2022/05/10/MySQL%E5%9F%BA%E6%9C%AC/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://loliconkelvin.github.io/2022/05/10/MySQL%E5%9F%BA%E6%9C%AC/","path":"2022/05/10/MySQL基本/","title":"MySQL基本"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>MySQL基本 | 萝莉控的小窝</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">萝莉控的小窝</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">一些概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%A7%84%E5%88%99"><span class="nav-number">2.</span> <span class="nav-text">关系型数据库的设计规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%85%B3%E7%B3%BB"><span class="nav-number">3.</span> <span class="nav-text">表之间的联系关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E5%91%BD%E4%BB%A4%E8%A1%8C%EF%BC%89%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E9%9D%9E%E6%8C%87%E4%BB%A4%E7%BB%86%E5%88%99%EF%BC%89"><span class="nav-number">4.</span> <span class="nav-text">（命令行）数据库基本操作（非指令细则）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7"><span class="nav-number">5.</span> <span class="nav-text">数据库图形管理工具</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E8%AF%AD%E8%A8%80%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">6.</span> <span class="nav-text">MySQL语言的分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99%E4%B8%8E%E6%A0%BC%E5%BC%8F%E8%A7%84%E8%8C%83"><span class="nav-number">7.</span> <span class="nav-text">SQL使用规则与格式规范</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL%E6%B3%A8%E9%87%8A"><span class="nav-number">8.</span> <span class="nav-text">SQL注释</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL%E5%9F%BA%E6%9C%AC%E6%9F%A5%E8%AF%A2%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="nav-number">9.</span> <span class="nav-text">SQL基本查询（重要）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL%E8%BF%87%E6%BB%A4%E6%9D%A1%E4%BB%B6%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">10.</span> <span class="nav-text">SQL过滤条件与运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL%E6%8E%92%E5%BA%8F%EF%BC%88ORDER-BY%EF%BC%89"><span class="nav-number">11.</span> <span class="nav-text">SQL排序（ORDER BY）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL%E5%88%86%E9%A1%B5%EF%BC%88LIMIT-OFFSET%EF%BC%89"><span class="nav-number">12.</span> <span class="nav-text">SQL分页（LIMIT OFFSET）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%EF%BC%88SQL92%EF%BC%89"><span class="nav-number">13.</span> <span class="nav-text">SQL多表查询（SQL92）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%EF%BC%88SQL99%EF%BC%89"><span class="nav-number">14.</span> <span class="nav-text">SQL多表查询（SQL99）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%EF%BC%88UNION-ALL%EF%BC%89"><span class="nav-number">15.</span> <span class="nav-text">SQL联合查询结果（UNION ALL）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E5%AE%9E%E7%8E%B07%E7%A7%8DJOIN%E6%9F%A5%E8%AF%A2%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="nav-number">16.</span> <span class="nav-text">MySQL实现7种JOIN查询（重要）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL99%E6%96%B0%E7%89%B9%E6%80%A7-%E8%87%AA%E7%84%B6%E8%BF%9E%E6%8E%A5%EF%BC%88NATURAL-JOIN%EF%BC%89"><span class="nav-number">17.</span> <span class="nav-text">SQL99新特性-自然连接（NATURAL JOIN）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL99%E6%96%B0%E7%89%B9%E6%80%A7-%E6%8C%87%E5%AE%9A%E7%AD%89%E5%80%BC%E8%BF%9E%E6%8E%A5%E5%AD%97%E6%AE%B5%EF%BC%88USING%EF%BC%89"><span class="nav-number">18.</span> <span class="nav-text">SQL99新特性-指定等值连接字段（USING）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E6%97%B6%E9%97%B4"><span class="nav-number">19.</span> <span class="nav-text">MySQL单行函数——基本、字符串、时间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%87%BD%E6%95%B0"><span class="nav-number">20.</span> <span class="nav-text">MySQL单行函数——流程控制函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86"><span class="nav-number">21.</span> <span class="nav-text">MySQL单行函数——加密与解密</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94MySQL%E5%BD%93%E5%89%8D%E4%BF%A1%E6%81%AF%E5%87%BD%E6%95%B0"><span class="nav-number">22.</span> <span class="nav-text">MySQL单行函数——MySQL当前信息函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94%E5%85%B6%E5%AE%83%E5%87%BD%E6%95%B0"><span class="nav-number">23.</span> <span class="nav-text">MySQL单行函数——其它函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%EF%BC%88%E5%A4%9A%E8%A1%8C%E5%87%BD%E6%95%B0%EF%BC%89"><span class="nav-number">24.</span> <span class="nav-text">MySQL聚合函数（多行函数）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E5%88%86%E7%BB%84%E4%B8%8E%E6%B1%87%E6%80%BB%EF%BC%88GROUP-BY-WITH-ROLLUP%EF%BC%89"><span class="nav-number">25.</span> <span class="nav-text">MySQL分组与汇总（GROUP BY WITH ROLLUP）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E5%88%86%E7%BB%84%E7%AD%9B%E9%80%89%EF%BC%88HAVING%EF%BC%89"><span class="nav-number">26.</span> <span class="nav-text">MySQL分组筛选（HAVING）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E5%AE%8C%E6%95%B4%E7%9A%84SELECT%E8%AF%AD%E5%8F%A5"><span class="nav-number">27.</span> <span class="nav-text">一个基本完整的SELECT语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-number">28.</span> <span class="nav-text">SQL语句的执行顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E5%AD%90%E6%9F%A5%E8%AF%A2%E2%80%94%E2%80%94%E5%8D%95%E8%A1%8C%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="nav-number">29.</span> <span class="nav-text">MySQL子查询——单行子查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E5%AD%90%E6%9F%A5%E8%AF%A2%E2%80%94%E2%80%94%E5%A4%9A%E8%A1%8C%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="nav-number">30.</span> <span class="nav-text">MySQL子查询——多行子查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E5%AD%90%E6%9F%A5%E8%AF%A2%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC"><span class="nav-number">31.</span> <span class="nav-text">相关子查询——基本</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E5%AD%90%E6%9F%A5%E8%AF%A2%E2%80%94%E2%80%94-NOT-EXISTS"><span class="nav-number">32.</span> <span class="nav-text">相关子查询——(NOT) EXISTS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E7%AE%A1%E7%90%86"><span class="nav-number">33.</span> <span class="nav-text">数据库的创建和管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E7%AE%A1%E7%90%86"><span class="nav-number">34.</span> <span class="nav-text">表的创建与管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9D%E8%AF%86%E4%BA%8B%E5%8A%A1%E2%80%94%E2%80%94%E6%8F%90%E4%BA%A4%E4%B8%8E%E5%9B%9E%E6%BB%9A"><span class="nav-number">35.</span> <span class="nav-text">初识事务——提交与回滚</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9"><span class="nav-number">36.</span> <span class="nav-text">数据的增删改</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">37.</span> <span class="nav-text">MySQL数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E7%BA%A6%E6%9D%9F%EF%BC%88CONSTRAINT%EF%BC%89"><span class="nav-number">38.</span> <span class="nav-text">MySQL约束（CONSTRAINT）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%B9%E8%B1%A1"><span class="nav-number">39.</span> <span class="nav-text">数据库对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E8%A7%86%E5%9B%BE%EF%BC%88VIEW%EF%BC%89"><span class="nav-number">40.</span> <span class="nav-text">MySQL视图（VIEW）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%EF%BC%88PROCEDURE%EF%BC%89"><span class="nav-number">41.</span> <span class="nav-text">MySQL存储过程（PROCEDURE）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0%EF%BC%88FUNCTION%EF%BC%89"><span class="nav-number">42.</span> <span class="nav-text">MySQL存储函数（FUNCTION）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7%E7%9A%84%E6%9F%A5%E7%9C%8B%E3%80%81%E4%BF%AE%E6%94%B9%E3%80%81%E5%88%A0%E9%99%A4"><span class="nav-number">43.</span> <span class="nav-text">存储过程与存储函数属性的查看、修改、删除</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E5%8F%98%E9%87%8F"><span class="nav-number">44.</span> <span class="nav-text">MySQL变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MyQSL%E5%AE%9A%E4%B9%89%E6%9D%A1%E4%BB%B6%E4%B8%8E%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%EF%BC%88%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%89"><span class="nav-number">45.</span> <span class="nav-text">MyQSL定义条件与处理程序（异常处理）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-number">46.</span> <span class="nav-text">MySQL流程控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E6%B8%B8%E6%A0%87%EF%BC%88CURSOR%EF%BC%89"><span class="nav-number">47.</span> <span class="nav-text">MySQL游标（CURSOR）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E8%A7%A6%E5%8F%91%E5%99%A8%EF%BC%88TRIGGER%EF%BC%89"><span class="nav-number">48.</span> <span class="nav-text">MySQL触发器（TRIGGER）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL8-0%E6%96%B0%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="nav-number">49.</span> <span class="nav-text">MySQL8.0新特性——窗口函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL8-0%E6%96%B0%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94%E5%85%AC%E7%94%A8%E8%A1%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">50.</span> <span class="nav-text">MySQL8.0新特性——公用表表达式</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Loliconkelvin"
      src="/uploads/avatar.png">
  <p class="site-author-name" itemprop="name">Loliconkelvin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">48</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Loliconkelvin" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Loliconkelvin" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:Loliconkelvin@gmail.com" title="E-Mail → mailto:Loliconkelvin@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://loliconkelvin.github.io/2022/05/10/MySQL%E5%9F%BA%E6%9C%AC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Loliconkelvin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萝莉控的小窝">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="MySQL基本 | 萝莉控的小窝">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MySQL基本
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-10 09:42:26" itemprop="dateCreated datePublished" datetime="2022-05-10T09:42:26+08:00">2022-05-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-06-19 10:42:54" itemprop="dateModified" datetime="2022-06-19T10:42:54+08:00">2022-06-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <style>
    .red {
        color: red;
    }
    .bold {
        font-weight: bold;
    }
</style>

<p>MySQL基本</p>
<span id="more"></span>

<h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><hr>
<p><strong>为什么需要数据库</strong></p>
<p>数据库可以使存入的数据持久化，数据库存储数据量大</p>
<hr>
<p><strong>数据库与数据管理系统</strong></p>
<p><span class="red bold">数据库（DB）：</span>指存储数据的仓库，其本质是文件系统，它保存一系列有组织的数据</p>
<p><span class="red bold">数据库管理系统（DBMS）：</span>是一种操作和管理数据库的软件，用于建立、使用和维护数据库，用户可以通过数据库管理系统访问数据库中表内的数据（MySQL是一种数据库管理系统）</p>
<p><span class="red bold">结构化查询语言（SQL）</span>：专门用于与数据库管理系统通信的语言，指定数据库管理系统对数据库的操作</p>
<hr>
<p><strong>关系型数据库与非关系型数据库</strong></p>
<p><span class="red bold">关系型数据库（RDBMS）：</span>指数据库将复杂的数据结构归结为简单的二元关系（即表格）的形式</p>
<ul>
<li>关系型数据库以 <code>行（row）</code> 和 <code>列（column）</code> 的形式存储数据，这些行和列组合被称为 <code>表</code>，一个表就组成一个数据库</li>
<li>表与表之间的数据记录有关系，现实中的各种实体和实体之间的联系均使用 <code>关系模型</code> 来表示</li>
<li>关系型数据库就是建立在 <code>关系模型</code> 基础上的数据库</li>
</ul>
<blockquote>
<p>优势：</p>
<ol>
<li><p>复杂查询： 可以使用SQL语句在一个表和多个表之间做复杂的数据查询</p>
</li>
<li><p>事务支持：当多个事务同时访问数据时，数据安全有保证</p>
</li>
</ol>
</blockquote>
<p><span class="red bold">非关系型数据库：</span>基于键值对存储数据，性能比关系型数据库高，非关系型数据库又分为以下几种：</p>
<ul>
<li><span class="red bold">键值型数据库：</span>基于像map一样的键值对存储数据，查找速度快，缺点是无法像关系型数据库一样使用条件过滤（如 WHERE）.键值型数据库常用于内存缓存。Radis是最流行的键值型数据库</li>
<li><span class="red bold">文档型数据库：</span>可以存放和获取文档，常见于XML、JSON格式文档，它是将键值型数据库的值变成了文档。MongoDB是最流行的文档型数据库</li>
<li><span class="red bold">搜索引擎数据库：</span>尽管关系型数据库采用了索引提升检索效率，关系型数据库对于全文索引的效率还是很低。搜索引擎数据库是应用于搜索引擎领域的数据存储形式。由于搜索引擎会爬取大量数据，并以特定格式存储，这样在检索的时候才能保证性能最优。核心原理：“倒排索引”。</li>
<li><span class="red bold">列式数据库：</span>Oracle、MySQL和SQL server采用的都是<span class="red">行式存储</span>列式数据库是将数据按照列存储到数据库中，这样做可以大幅度降低IO，适用于分布文件系统，但功能有限 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%88%97%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/4884515?fr=aladdin">（列式数据库（百科））</a></li>
<li><span class="red bold">图形数据库：</span>利用图片存储实体之间的关系，以节点和边来实现</li>
</ul>
<h2 id="关系型数据库的设计规则"><a href="#关系型数据库的设计规则" class="headerlink" title="关系型数据库的设计规则"></a>关系型数据库的设计规则</h2><ul>
<li>关系型数据库的典型数结构就是数据表，这些表的组成都是结构化的</li>
<li>将数据放到表中，再将表放到库中</li>
<li>一个数据库中可以有多个表，每个表都有一个名字，用来标识自己，<code>表名具有唯一性</code></li>
<li>表即有一些特性，这些特性定义了数据在表中如何存储，类似Java中“类”的设计</li>
</ul>
<hr>
<p><strong>表、记录、字段与ORM思想</strong></p>
<table>
<thead>
<tr>
<th align="center">表、记录、字段</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="https://s1.ax1x.com/2022/05/10/ON1DoR.md.jpg" alt="ON1DoR.md.jpg"></td>
</tr>
</tbody></table>
<p><span class="red bold">E-R（entity-relationship）模型：</span>即实体-联系模型，其中的三个主要概念是：<code>实体集</code>、<code>属性</code>、<code>联系集</code></p>
<p><span class="red bold">ORM思想：</span>Object Relational Mapping, 即对象关系映射思想，指数据库中的元素与Java中的一些元素一一对应</p>
<p><span class="red bold">表：</span>上图就是一张表，表是数据的集合，对应于Java中的类</p>
<p><span class="red bold">记录：</span>表中的一行即为一个记录，对应Java中的对象（实例）</p>
<p><span class="red bold">字段：</span>表中的任意一列的名称即为字段，字段规定这一列应该填什么，对应Java中的属性</p>
<table>
<thead>
<tr>
<th align="center">数据库</th>
<th align="center">Java</th>
</tr>
</thead>
<tbody><tr>
<td align="center">表</td>
<td align="center">类</td>
</tr>
<tr>
<td align="center">记录</td>
<td align="center">对象（实例）</td>
</tr>
<tr>
<td align="center">字段</td>
<td align="center">属性</td>
</tr>
</tbody></table>
<h2 id="表之间的联系关系"><a href="#表之间的联系关系" class="headerlink" title="表之间的联系关系"></a>表之间的联系关系</h2><hr>
<p><strong>一对一联系</strong></p>
<p>用得并不多，因为一对一关系可以做成一张表，但将一张表拆分也有优点，下面会说。</p>
<p><span class="red bold">一对一联系：</span>指一张表中的一行信息对应另一张表中的一行信息，如：</p>
<table>
<thead>
<tr>
<th align="center">学号</th>
<th align="center">姓名</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1581156</td>
<td align="center">张三</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">学号</th>
<th align="center">邮箱</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1581156</td>
<td align="center">xxx</td>
</tr>
</tbody></table>
<ul>
<li>一张表拆成多张表：当一张表中的字段很多时，查询该表一行数据中的某一两个字段会造成大量冗余，因为其他字段的数据我不需要。</li>
<li>把一些经常要查询的字段做成一张表，不怎么需要查询的字段做成另外一张表，就可以减少查询冗余</li>
<li>缺点是当查询的字段同时涉及两个表时，多表查询的SQL语句会复杂</li>
</ul>
<p><span class="red bold">一对一建表规则：</span></p>
<ul>
<li>外键唯一：主表的主键和从表的外键（唯一）形成主外键关系。外键唯一</li>
<li>外键是主键：主表的主键和从表的主键形成主外键关系</li>
</ul>
<hr>
<p><strong>一对多联系</strong></p>
<p><span class="red bold">一对多联系：</span>指一张表中的一行信息对应另一张表中的多行信息，常见于“用户表与订单表”、“分类表与商品表”</p>
<p><span class="red bold">一对多建表规则：</span></p>
<ul>
<li>在从表（多方）创建一个字段，字段作为外键指向主表</li>
</ul>
<hr>
<p><strong>多对多联系</strong></p>
<p><span class="red bold">多对多联系：</span>多对多联系必须在两张表之间创建第三张表，称 <code>联系表</code>，多对多联系实际上是由两个一对多联系组成，而多对多的联系往往在联系表中体现出来，如：</p>
<ul>
<li>学生与课程：一位学生可以选择多门课程。一门课程可以被多个学生选择，此时应该建立：“学生信息表”、“课程信息表”和“选课信息表”（联系表）</li>
</ul>
<hr>
<p><strong>自我联系</strong></p>
<p><span class="red bold">自我联系：</span>指一张表中的一行或多行信息会与另一行或多行信息相关联，通常用于一些归属的情况，如：学生信息表中班长字段，多个学生对应一个班长，同时班长也是一个学生</p>
<h2 id="（命令行）数据库基本操作（非指令细则）"><a href="#（命令行）数据库基本操作（非指令细则）" class="headerlink" title="（命令行）数据库基本操作（非指令细则）"></a>（命令行）数据库基本操作（非指令细则）</h2><hr>
<p><strong>启动数据库</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">net start MySQL服务名</code></pre>

<hr>
<p><strong>登录数据库</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql -u 用户名 -h 主机地址 -P 端口号 -p密码</code></pre>

<ul>
<li>主机地址和端口号用于远程访问数据库</li>
<li>端口号也适用于访问本机中占用不同端口号的mysql（一台机装有多个mysql）</li>
</ul>
<hr>
<p><strong>显示现有数据库</strong></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">show databases;</code></pre>

<p><span class="red bold">自带数据库：</span></p>
<p>MySQL自带四个数据库，其中有一个不显示在文件中</p>
<ul>
<li><code>information_schema</code>：保存数据库服务器的系统信息（字段名、表名、存储权限）</li>
<li><code>mysql</code>：MySQL运行时所需系统信息（输出文件夹、当前使用的字符集）</li>
<li><code>performance_schema</code>：存储当前MySQL性能指标</li>
<li><code>sys</code>：存储当前MySQL性能指标</li>
</ul>
<hr>
<p><strong>创建数据库</strong></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">create database 数据库名;</code></pre>

<hr>
<p><strong>导入数据库</strong></p>
<p>向MySQL导入一个备份数据库文件，<span class="red">该命令仅限于命令行使用</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">source 文件的绝对路径;</code></pre>

<hr>
<p><strong>删除一个数据库</strong></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">drop 数据库名;</code></pre>

<hr>
<p><strong>连接数据库</strong></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">use 数据库名;</code></pre>

<hr>
<p><strong>显示当前数据库中的表</strong></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">show tables;</code></pre>

<hr>
<p><strong>创建一个表</strong></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">create table 表名(字段名 字段类型, 字段名 字段类型);</code></pre>

<hr>
<p><strong>筛选全部操作</strong></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT * FROM 表名;</code></pre>

<hr>
<p><strong>插入一条记录</strong></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">insert into 表名 values(值, 值);</code></pre>

<p><span class="red bold">版本差异：</span></p>
<ul>
<li>在5.7版本中，数据库默认字符集为latin1，导致输入字符串的列不能输入中文</li>
<li>在8.0版本中，数据库默认字符集为utf8mb4</li>
</ul>
<p><span class="red bold">5.7版本修复方法：</span></p>
<p>配置my.ini，做如下修改：</p>
<pre class="line-numbers language-ini" data-language="ini"><code class="language-ini">[mysql] # 在其下面增加一句
...
default-charactor-set&#x3D;utf8 #默认字符集

[mysqld] # 在其下面增加
...
character-set-server&#x3D;utf8
collation-server&#x3D;utf8_general_ci</code></pre>

<h2 id="数据库图形管理工具"><a href="#数据库图形管理工具" class="headerlink" title="数据库图形管理工具"></a>数据库图形管理工具</h2><p>这里不对图形化管理工具做说明，只说一个错误</p>
<hr>
<p><strong>图形化管理工具连接SQL失败</strong></p>
<pre class="line-numbers language-none"><code class="language-none">Plugin caching_sha2_password could not be loaded</code></pre>

<p>由于8.0mysql增加了通过sha算法的加密规则，某些软件不支持这样的规则，解决方案：</p>
<ul>
<li>将图形化管理工具升级为最新版或专业版</li>
<li>将mysql的加密方式更改为原始加密方式，下面是方法：</li>
</ul>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">&#x2F;* 依次执行以下三条指令 *&#x2F;
use mysql;

ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;123456&#39;;

FLUSH PRIVILEGES;</code></pre>

<h2 id="MySQL语言的分类"><a href="#MySQL语言的分类" class="headerlink" title="MySQL语言的分类"></a>MySQL语言的分类</h2><p>SQL语句在功能上主要分为以下3类</p>
<p><span class="red bold">DDL（数据定义[define]语言）：</span>定义了不用的数据库、表、视图、索引等数据库对象，还可以用于创建、删除、修改数据库和数据表结构</p>
<ul>
<li>主要包括<code>CREATE</code>、<code>DROP</code>、<code>ALTER</code>等</li>
</ul>
<p><span class="red bold">DML（数据操作[manipulation]语言）（重要 ）：</span>用于添加、删除、更新和查询<span class="red">数据库记录</span>，并检查数据完整性</p>
<ul>
<li>主要包括<code>INSERT</code>、<code>DELETE</code>、<code>SELECT</code>等</li>
</ul>
<p><span class="red bold">DCL（数据控制[control]语言）：</span>主要用于定义数据库、表、字段、用户的访问权限和安全级别</p>
<ul>
<li>主要的语句关键字包括<code>GRANT</code>、<code>REVOKE</code>、<code>COMMIT</code>、<code>ROLLBACK</code>、<code>SAVEPOINT</code>等</li>
</ul>
<h2 id="SQL使用规则与格式规范"><a href="#SQL使用规则与格式规范" class="headerlink" title="SQL使用规则与格式规范"></a>SQL使用规则与格式规范</h2><hr>
<p><strong>语句规则</strong></p>
<ul>
<li>SQL语句可以写在一行或多行。为提高可读性，各子句进行分行，必要时缩进</li>
<li>每条命令以“;”或“\g”或“\G”结束（<span class="red">注意：</span>“\G”和“\g”在控制台使用，不要在图形化管理系统使用）</li>
<li>关键字不能被缩写和被分行</li>
<li>关于标点符号：<ul>
<li>所有的括号和引号必须成对</li>
<li>必须使用英文状态下的半角输入方式</li>
<li>字符串和日期类型数据使用<span class="red">单引号</span>括住</li>
<li>列的别名，使用<span class="red">双引号</span>括住，并且不建议省略 <code>AS</code> 关键字</li>
</ul>
</li>
</ul>
<hr>
<p><strong>命名规则</strong></p>
<p><span class="red">表的命名规则详见表的创建与管理-&gt;表的命名规则</span></p>
<p><span class="red">字段的命名规则详见表的创建与管理-&gt;字段的命名规则</span></p>
<hr>
<p><strong>语句规范</strong></p>
<ul>
<li><p>关于大小写：</p>
<ul>
<li>由于windows本身不对大小写作区分（即视A.txt和a.txt为同名文件），所以<span class="red">在windows环境下MySQL大小写不敏感</span></li>
<li>同理由于linux严格区分大小写，<span class="red">在linux环境下MySQL大小写敏感</span>，但也分情况：<ul>
<li>数据库名、表名、表的别名、变量名严格区分</li>
<li>关键字、函数名、字段名、字段的别名不区分</li>
</ul>
</li>
</ul>
</li>
<li><p>大小写书写规范：</p>
<ul>
<li>关键字、函数名、绑定变量为<span class="red">大写</span></li>
<li>数据库名、表名、表别名、字段名、字段别名等为<span class="red">小写</span></li>
</ul>
</li>
</ul>
<h2 id="SQL注释"><a href="#SQL注释" class="headerlink" title="SQL注释"></a>SQL注释</h2><hr>
<p><strong>单行注释（通用）</strong></p>
<p>这种单行注释是数据库关系统通用的方式</p>
<p><span class="red">注意：</span>使用“–”作为单行注释时，“–”后面必须跟一个空格</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 这是一行注释</code></pre>

<hr>
<p><strong>单行注释（特有）</strong></p>
<p>这种单行注释是MySQL通用的方式</p>
<p><span class="red">注意：</span>使用“#”作为单行注释时，后面不需要跟空格</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL"># 这也是一行注释</code></pre>

<hr>
<p><strong>多行注释</strong></p>
<p><span class="red">注意：</span>多行注释不可嵌套</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">&#x2F;*
这是
多行
注释
*&#x2F;</code></pre>

<h2 id="SQL基本查询（重要）"><a href="#SQL基本查询（重要）" class="headerlink" title="SQL基本查询（重要）"></a>SQL基本查询（重要）</h2><hr>
<p><strong>基本SQL查询语句</strong></p>
<p>字段可以是单纯的字段名，也可以规定一些运算（见列的别名例子）</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 其中，若字段中写 * ，则表示所有字段
SELECT 字段1（列）, 字段2, ... FROM 表名;</code></pre>

<p><span class="red bold">结果集：</span>使用查询语句查询出来的结果称为结果集</p>
<hr>
<p><strong>列的别名（字段的别名）</strong></p>
<p><span class="red">意义：</span>指给选择的列再起一个另外的名称，该语句可以穿插在各种语句中，可以使用中文</p>
<p><span class="red bold">规范：</span></p>
<ul>
<li>不建议常略AS（alias）</li>
<li>字段的别名使用 双引号 引起</li>
<li><span class="red">表的别名不要使用双引号和单引号，若有特殊字符，使用着重号引起</span></li>
</ul>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 格式
字段（列）名 AS &quot;别名&quot;;

-- 可穿插在语句中
SELECT book_name AS &quot;bname&quot; FROM book;

-- 可用于一些需要运算的场景
SELECT price AS &quot;价格&quot;, price * 12 AS &quot;十二倍价格&quot; FROM book;</code></pre>

<hr>
<p><strong>取去除重复行（DISTINCT）</strong></p>
<p><span class="red">意义：</span>用于筛选出一列中有哪几种数据（如：在学生表中查询一共有几门课程，一门课程可以被很多学生选择，如果将该列全部查询出来就会有很多重复数据）</p>
<p><span class="red bold">格式：</span>在 <code>SELECT</code> 后加上 <code>DISTINCT</code> 关键字</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 若后面指定了多个字段。则当这几个字段都相同时才视为重复行
SELECT DISTINCT &#96;name&#96;, pwd FROM &#96;user&#96;;</code></pre>

<hr>
<p><strong>空值参与运算</strong></p>
<p><span class="red bold">空值：</span>即为NULL，需要注意的是空值并不等同于 数字0 或 空字符串’’</p>
<ul>
<li><span class="red">NULL值参与任何运算，结果都会为NULL</span></li>
</ul>
<p><span class="red bold">解决方法：</span>涉及单行函数 <code>IFNULL(字段, 替换值)</code>，若当前行的该字段为NULL，则该函数会将其替换为后面的值</p>
<hr>
<p><strong>着重号</strong></p>
<p>若出现字段名和表名与SQL的保留字（或称关键字）、函数名重名，则需要将字段名和表名使用 着重号 引起。着重号是数字键1左边那个点“&#96;” </p>
<ul>
<li><span class="red">注意：</span>若别名带有空格，在排序或其他场景再被引用时，应该使用<span class="red">着重号</span>将别名引起</li>
</ul>
<hr>
<p><strong>查询常数</strong></p>
<p><span class="red bold">常数：</span>也就是不变的数，放到数据库里面的意思就是每一行都是这个数，用于结果集里加上一列或多列常数</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 在查询出的结果的每一行都在前面加上一列字符串，内容为“学生”
SELECT &#39;学生&#39;, &#96;name&#96;, &#96;age&#96; FROM student;</code></pre>

<hr>
<p><strong>查询表结构</strong></p>
<p>用于查询该表中字段的详细信息（如该字段的类型，是否允许空值等）</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">DESCRIBE 表名;

-- 缩写也行
DESC 表名;</code></pre>

<h2 id="SQL过滤条件与运算符"><a href="#SQL过滤条件与运算符" class="headerlink" title="SQL过滤条件与运算符"></a>SQL过滤条件与运算符</h2><hr>
<p><strong>过滤</strong></p>
<p>要在表中过滤出满足某个条件的数据集，使用以下方法：</p>
<p><span class="red bold">注意：</span></p>
<ul>
<li>在筛选条件中的字符串（如 <code>name</code> &#x3D; ‘Jeb’ 中的jeb）是区分大小写的（在MySQL中）</li>
<li>WHERE语句 必须在 FROM语句 之后</li>
<li><span class="red">字段的别名不能在过滤条件中出现（详见SQL语句的执行顺序）</span></li>
</ul>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT * FROM student
-- 筛选条件
WHERE 条件（如：&#96;name&#96; &#x3D; &#39;张三&#39;）;</code></pre>

<hr>
<p><strong>运算符</strong></p>
<p><span class="red bold">算术运算符：</span></p>
<table>
<thead>
<tr>
<th align="center">算术运算符</th>
<th align="center">第二种表示方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">-</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">*</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">&#x2F;（带4位小数）</td>
<td align="center">div（整除）</td>
</tr>
<tr>
<td align="center">%</td>
<td align="center">mod</td>
</tr>
</tbody></table>
<p><span class="red">注意：</span></p>
<ul>
<li>在SQL中，加号“+”只有相加的功能，没有连接的功能，因此 100 + ‘1’ 会将’1’转换为数值，其结果为101，而不是Java中的”1001”</li>
<li>并且，若该值不能转换为数值，则视为0，因此 100 + ‘A’ 的结果是100。’A’ + ‘B’ 的结果也为 0。若要实现字符串拼接，涉及单行函数 <code>CONCAT()</code></li>
<li>并且*2，上面已经说过NULL参与任何运算结果都是NULL，因此 100 + NULL 结果为NULL</li>
</ul>
<p><span class="red">结果的类型转换：</span></p>
<ul>
<li>加减乘：整型与整型计算-&gt;整型；浮点型与任何类型计算-&gt;浮点型</li>
<li>除：当分母为0时，结果为NULL</li>
<li>取模：取模的结果的正负与运算符左边的数一致</li>
</ul>
<p><span class="red bold">比较运算符——符号：</span></p>
<p>比较运算符用于对表达式左边的操作数和表达式右边的操作数进行比较，结果为真返回1，结果为假返回0，其他情况返回NULL</p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">含义（只写出新的）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&#x3D;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">&lt;&#x3D;&gt;</td>
<td align="center">安全等于运算符</td>
</tr>
<tr>
<td align="center">!&#x3D;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">&lt;&gt;</td>
<td align="center">这个也是不等于运算符</td>
</tr>
<tr>
<td align="center">&lt;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">&lt;&#x3D;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">&gt;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">&gt;&#x3D;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p><span class="red">安全等于：</span>安全等于专门用于解决“&#x3D;”无法对比NULL值的问题。</p>
<ul>
<li>在没有NULL参与运算时，“&#x3D;”与“&lt;&#x3D;&gt;”的效果一样</li>
<li>在有NULL参与运算时：<ul>
<li>“&#x3D;”会返回NULL</li>
<li>“&lt;&#x3D;&gt;”会对比两边是否都为NULL，是则返回1，否则返回0（因此：NULL &lt;&#x3D;&gt; NULL 的结果为1）</li>
</ul>
</li>
</ul>
<p><span class="red">注意：</span></p>
<ul>
<li>对于字符串与数值，SQL同样是会尝试把它转换成数值再进行比较，若转换不成功则视字符串为0</li>
<li>对于字符串与字符串比较，那就是比较他们的ASCII码了，<span class="red">并且与长度无关</span>（如 ‘BC’ &gt; ‘BBC’ 的结果为 1）</li>
<li>有NULL参与的运算，结果都为NULL<span class="red">（有个例外：安全等于）</span>（特别注意不要尝试使用 <code>WHERE 字段 = NULL</code> 的方法查询出字段为NULL的行，因为只有比较结果为1的行才会被过滤出来，结果为NULL的会被舍弃）</li>
</ul>
<p><span class="red bold">比较运算符——关键字</span></p>
<table>
<thead>
<tr>
<th align="center">关键字</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">字段名 IS NULL</td>
<td align="center">为空关键字</td>
</tr>
<tr>
<td align="center">字段名 IS NOT NULL</td>
<td align="center">非空关键字</td>
</tr>
<tr>
<td align="center">LEAST(…)</td>
<td align="center">取最小函数</td>
</tr>
<tr>
<td align="center">GREATEST(…)</td>
<td align="center">取最大函数</td>
</tr>
<tr>
<td align="center">字段名 BETWEEN 下限 AND 上限</td>
<td align="center">取区间关键字（包含边界）</td>
</tr>
<tr>
<td align="center">ISNULL(字段名)</td>
<td align="center">为空函数</td>
</tr>
<tr>
<td align="center">字段名 IN()</td>
<td align="center">取离散值函数</td>
</tr>
<tr>
<td align="center">字段名 NOT IN()</td>
<td align="center">取非离散值函数</td>
</tr>
<tr>
<td align="center">LIKE</td>
<td align="center">模糊查询关键字（需要使用通配符，详见下面通配符）</td>
</tr>
<tr>
<td align="center">REGEXP</td>
<td align="center">正则表达式匹配关键字（需要使用正则表达式）</td>
</tr>
<tr>
<td align="center">RLIKE</td>
<td align="center">正则表达式模糊关键字（需要使用正则表达式）</td>
</tr>
</tbody></table>
<p><code>LEAST(...)</code>：（<code>GREATEST(...)</code>同理）</p>
<ul>
<li>对于常数比较，写成：<code>LEAST(值1, 值2, ...)</code></li>
<li>对于字段之间的比较，写成：<code>LEAST(字段名1, 字段名2)</code></li>
</ul>
<p><code>IN(值1, 值2, ...)</code>：</p>
<ul>
<li>用于筛选出指定字段的值为括号内的值的行</li>
<li>括号内的值是 或 的关系</li>
</ul>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT last_name FROM employees WHERE last_name LIKE &#39;%a%&#39; AND last_name LIKE &#39;%e%&#39;;</code></pre>

<p><span class="red bold">逻辑运算符：</span></p>
<table>
<thead>
<tr>
<th align="center">逻辑运算符</th>
<th align="center">第二种写法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">!</td>
<td align="center">NOT</td>
</tr>
<tr>
<td align="center">&amp;&amp;</td>
<td align="center">AND</td>
</tr>
<tr>
<td align="center">||</td>
<td align="center">OR</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">XOR</td>
</tr>
</tbody></table>
<p><span class="red">注意：</span></p>
<ul>
<li><code>AND</code> 和 <code>OR</code> 可以一起使用，<code>AND</code> 的优先级比 <code>OR</code> 高</li>
<li><code>NOT</code> 加在任意完整语句前会有非&#x2F;取反的效果  <pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">id NOT BETWEEN </code></pre></li>
<li>任何双目运算符如 <code>AND</code>、<code>OR</code> 和 <code>XOR</code> 及其符号表示，它们左右的表达式必须是完整的  <pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 错误写法
id &#x3D; 10 OR 20;

-- 正确写法
id &#x3D; 10 OR id &#x3D; 20;</code></pre></li>
</ul>
<p><span class="red bold">位运算符：</span></p>
<p>位运算符使用频率不高，位运算符有：<code>&amp;</code> <code>|</code> <code>~</code> <code>^</code> <code>&lt;&lt;</code> <code>&gt;&gt;</code></p>
<hr>
<p><strong>通配符</strong></p>
<p>通配符用于与 <code>LIKE</code> 一起使用以模糊查询</p>
<table>
<thead>
<tr>
<th align="center">通配符</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">%</td>
<td align="center">代表多个不确定字符</td>
</tr>
<tr>
<td align="center">_</td>
<td align="center">代表一个不确定字符</td>
</tr>
</tbody></table>
<hr>
<p><strong>转义符与指定转义符</strong></p>
<p>若在查询条件中有字符与通配符冲突，则需要使用转义字符</p>
<p>通常转义字符为“\”</p>
<p><span class="red bold">指定转义字符：</span><br>在通配符语句后加上以下语句可以指定该语句使用的转义字符：</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 指定转义字符
ESCAPE &#39;$&#39;;

-- 查询名字中带有下划线的人名，并指定$为转义字符
SELECT &#96;name&#96; FROM employees WHERE &#96;name&#96; LIKE &#39;$_&#39; ESCAPE &#39;$&#39;;</code></pre>

<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT &#96;name&#96;, 工资 FROM employees WHERE 工资 NOT BETWEEN 5000 AND 12000;

SELECT &#96;name&#96; 部门号 FROM employees WHERE 部门 &#x3D; 20 OR &#96;部门&#96; &#x3D; 50;

SELECT &#96;name&#96; job_id FROM employees WHERE 管理者 IS  NULL; -- &lt;&#x3D;&gt; NULL

SELECT 工资, 奖金级别 FROM employees WHERE 奖金 IS NOT NULL;

SELECT &#96;name&#96; FROM employees WHERE &#96;name&#96; LIKE &#39;__a%&#39;;

SELECT &#96;name&#96; FROM employees WHERE &#96;name&#96; LIKE &#39;%a%&#39; OR &#96;name&#96; LIKE &#39;%k%&#39;;

SELECT first_name FROM employees WHERE first_name REGEXP &#39;e$&#39;; -- LIKE &#39;%e&#39;

SELECT 姓名, 工种 FROM employees WHERE 部门编号 BETWEEN 80 AND 100;

SELECT 姓名, 工资, 管理者ID FROM employees WHERE manager_id IN (100,101,110);</code></pre>

<h2 id="SQL排序（ORDER-BY）"><a href="#SQL排序（ORDER-BY）" class="headerlink" title="SQL排序（ORDER BY）"></a>SQL排序（ORDER BY）</h2><hr>
<p><strong>一级排序</strong></p>
<p><span class="red bold">注意：</span></p>
<ul>
<li>若不显式指定排序，结果集将按照数据加入到数据库的时间先后顺序进行排序</li>
<li>排序必须在过滤之后（若存在过滤）</li>
<li><span class="red">字段的别名可以在排序中使用</span></li>
<li>虽然字段的别名在Navicat中不会提示，但别名在排序语句中<span class="red">不需要加任何引号</span>，字段的别名应该避免空格</li>
</ul>
<p><span class="red bold">排序：</span>通过 <code>ORDER BY 字段名</code> 指定通过某字段的默认字典进行 <span class="red">升序（默认）</span> 排序</p>
<p><span class="red bold">指定排序顺序：</span>通过在字段名后添加升序（ascend）或降序（descend）关键字，指定排序顺序</p>
<table>
<thead>
<tr>
<th align="center">关键字</th>
<th align="center">排序方式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ASC</td>
<td align="center">升序（默认）</td>
</tr>
<tr>
<td align="center">DESC</td>
<td align="center">降序</td>
</tr>
</tbody></table>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 别名在排序
SELECT &#96;name&#96;, salary * 12 AS &quot;annual_salary&quot;
FROM employees 
WHERE manager_id IN (100,101,110)
ORDER BY annual_salary DESC;</code></pre>

<hr>
<p><strong>多级排序</strong></p>
<p>当一级排序中某些行的指定字段出现相同时，默认还是按照数据插入到数据库的时间先后进行排序，若想指定此时的排序，需要在一级排序的语句后再加一条（或多条）规则：</p>
<p><span class="red">注意：</span>不加排序规则，默认升序，建议写明规则</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 先按照ten_type降序，ten_type相同，则按照id降序
SELECT id
, typeId * 10 AS &quot;ten_type&quot; FROM book 
ORDER BY ten_type DESC, id DESC;</code></pre>

<h2 id="SQL分页（LIMIT-OFFSET）"><a href="#SQL分页（LIMIT-OFFSET）" class="headerlink" title="SQL分页（LIMIT OFFSET）"></a>SQL分页（LIMIT OFFSET）</h2><p>通常用户不需要一次性浏览太多的记录，因此实际上分页不必不可少的，使用 <code>LIMIT 偏移量, 每页数据量</code> 进行分页</p>
<p><span class="red bold">注意：</span></p>
<ul>
<li><code>LIMIT</code> 必须在排序之后</li>
<li><code>LIMIT</code> 还有取前x条数据的功能，<code>LIMIT 0, x</code> 可以写成 <code>LIMIT x</code></li>
<li><code>LIMIT</code> 关键字不适用于SQL server、DB2、Oracle</li>
</ul>
<p><span class="red bold">公式：</span>当每页显示size条记录，此时显示第page页时，语句为：</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">LIMIT (page - 1) * size, size;</code></pre>

<hr>
<p><strong>MySQL8.0新排序关键字</strong></p>
<p>加入 <code>OFFSET</code> 关键字，现在排序语句可以写成：</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">LIMIT 每页数据量 OFFSET 偏移量</code></pre>

<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT salary FROM employees
ORDER BY salary DESC
LIMIT 1;</code></pre>

<h2 id="SQL多表查询（SQL92）"><a href="#SQL多表查询（SQL92）" class="headerlink" title="SQL多表查询（SQL92）"></a>SQL多表查询（SQL92）</h2><table>
<thead>
<tr>
<th align="center">多表查询</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="https://s1.ax1x.com/2022/05/13/Os1aPU.md.png" alt="Os1aPU.md.png"></td>
</tr>
</tbody></table>
<hr>
<p><strong>为什么需要多表查询</strong></p>
<p>下面四点根据这个网址的内容总结：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_57001006/article/details/123391618">为什么要使用多表查询</a></p>
<ul>
<li>减少数据冗余——原因1</li>
<li>减少IO（将数据加载到内存的次数）——原因2</li>
<li>减少维护难度</li>
<li>减少同步查询冲突——原因4</li>
</ul>
<hr>
<p><strong>多表查询——笛卡尔积错误</strong></p>
<p><span class="red bold">笛卡尔积错误：</span></p>
<p>使用以下方法可以实现多表查询，但结果不对：</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT employee_id, department_name
FROM employees, departments;</code></pre>

<p><span class="red bold">注意：</span>这种方式会将一个表中的<span class="red">每一行都分别与另一个表的每一行</span>合并，这种合并方式称为两个表的笛卡尔积连接（CROSS JOIN），上面的代码还可以写成下面这样：</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 两表的指定两个字段做笛卡尔积连接
SELECT employee_id, department_name
FROM employees CROSS JOIN departments;</code></pre>

<p><span class="red bold">笛卡尔积错误的产生条件：</span></p>
<ul>
<li>缺少连接条件</li>
<li>连接条件无效</li>
</ul>
<table>
<thead>
<tr>
<th align="center">笛卡尔积错误</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="https://s1.ax1x.com/2022/05/13/OsY4b9.png" alt="OsY4b9.png"></td>
</tr>
</tbody></table>
<blockquote>
<p>显然这种请示我们想要的，那么该如何正确地进行多表查询呢？</p>
</blockquote>
<hr>
<p><strong>基本多表查询的正确打开方式</strong></p>
<p>上面写到，我们使用了错误的两表连接方式，因此我们只需要指定正确的连接方式即可</p>
<p><span class="red bold">连接条件：</span></p>
<p>连接条件其实也是过滤条件的一种，因此用的是 <code>WHERE</code>，如：</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 连接条件为employees表中的外键要与departments表中的主键的值相同

-- 如无特殊符号，关键字冲突，着重号可以不加
SELECT employee_id, department_name
FROM employees, departments
WHERE employees.&#96;department_id&#96; &#x3D; departments.&#96;department_id&#96;</code></pre>

<p><span class="red">注意：</span>若有n个表需要连接，则至少存在n-1个连接条件</p>
<hr>
<p><strong>多表查询注意事项</strong></p>
<p><span class="red bold">模棱两可的字段：</span></p>
<p>指当在使用了多表查询时，查询的字段正好存在于多个表中时，该字段成为模棱两可的字段，<span class="red">数据库不知道去哪个表中查这个字段</span></p>
<ul>
<li>因此在多表查询时，建议给所有的字段都指定表</li>
</ul>
<p><span class="red bold">表的别名：</span></p>
<p>当然，给所有字段名指定表，在需要查询的字段多时，代码的可读性就会变差，此时可以使用表的别名降低代码长度，<span class="red">需要注意的是在指定了表的别名之后，不允许再使用表的原名</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT emp.employee_id, dept.department_name, dept.department_id
FROM employees AS emp, departments AS dept
WHERE emp.&#96;department_id&#96; &#x3D; dept.&#96;department_id&#96;;</code></pre>

<hr>
<p><strong>多表查询的分类</strong></p>
<p><span class="red bold">从连接条件上：</span>等值连接 非等值连接</p>
<ul>
<li>非等值连接就是所有涉及比较的连接，通常另一张表中会有一些阈值</li>
</ul>
<p><span class="red bold">从连接的字段之间的关系上：</span>自连接 非自连接</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 自连接例子：查询员工的管理人（管理人也算员工）

-- 在自连接时，最好把一张表复制一份看成是两张表之间的连接（取个不同的别名）会很好理解
SELECT emp.employee_id, emp.last_name, mgr.manager_id, mgr.last_name
FROM employees emp, employees mgr
WHERE emp.manager_id &#x3D; mgr.employee_id;</code></pre>

<p><span class="red bold">从获取的结果上：</span>内连接 外连接</p>
<hr>
<p><strong>内连接 与 外连接</strong></p>
<p>在连接的时候我们要指定连接条件，连接条件中左边的表称为左表，右边的表称为右表</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 假设前面的语句是多表查询
-- 则在下面的例子中a表为左表，b表为右表

WHERE a.name &#x3D; b.name;

WHERE a.age BETWEEN b.lower_limit AND b.upper_limit</code></pre>

<p>并且只有满足连接条件的记录才会被选出，如下图所示：</p>
<p><img src="https://s1.ax1x.com/2022/05/13/OySRA0.png" alt="OySRA0.png"></p>
<p><span class="red bold">内连接：</span>如上图，内连接指查询到的结果只有左表与右表匹配连接条件的记录</p>
<p><span class="red bold">外连接：</span>外连接对立于内连接，就是指查到的结果不止左表与右表的匹配条件记录</p>
<ul>
<li>还包括了左表中不与连接条件匹配的记录，则称<span class="red">左外连接</span></li>
<li>还包括了右表中不与连接条件匹配的记录，则称<span class="red">右外连接</span></li>
<li>还包括了左表和右表中不与连接条件匹配的记录，则称<span class="red">满外连接</span></li>
</ul>
<p><span class="red">注意：</span>SQL92和SQL99语法分别有两种方式实现外连接</p>
<hr>
<p><strong>SQL92语法实现外连接</strong></p>
<p><span class="red">注意：</span>MySQL不支持SQL92中外连接写法（Oracle支持）</p>
<p>SQL92的语法为“谁数据少，就给谁加点数据”</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 这是个左外连接，它给右表增加了数据，完善了左表的链接匹配
SELECT employee_id, department_name
FROM employees e, departments database
WHERE e.department_id &#x3D; d.department_id(+);</code></pre>

<table>
<thead>
<tr>
<th align="center">左外连接</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="https://s1.ax1x.com/2022/05/13/OyigYt.md.png" alt="OyigYt.md.png"></td>
</tr>
<tr>
<td align="center">右外连接</td>
</tr>
<tr>
<td align="center"><img src="https://s1.ax1x.com/2022/05/13/Oyi2fP.md.png" alt="Oyi2fP.md.png"></td>
</tr>
</tbody></table>
<h2 id="SQL多表查询（SQL99）"><a href="#SQL多表查询（SQL99）" class="headerlink" title="SQL多表查询（SQL99）"></a>SQL多表查询（SQL99）</h2><hr>
<p><strong>SQL99语法实现内连接</strong></p>
<p><span class="red bold">规范和建议：</span></p>
<ul>
<li>超过三个表连接的情况，禁止使用 <code>JOIN</code></li>
<li>尽量使用左外连接</li>
<li>一张表加入时使用了左外连接，后面加入的表也要使用左外连接</li>
</ul>
<p>使用 <code>JOIN 表名 ON 连接条件</code> 实现内连接，<br>或 <code>INNER JOIN 表名 ON 连接条件</code> 如下：</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 两张表连接
SELECT last_name, department_name
FROM employees e JOIN departments d
ON e.department_id &#x3D; d.department_id;</code></pre>

<p>这个就可以看成是一种合体（？）departments表要连接到employees表，并且声明一个条件，因此多表连接就是：每个要连接的表都对应一对 <code>JOIN ... ON ...</code>，如下：</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 多表连接
SELECT last_name, department_name
FROM employees e 
JOIN departments d ON e.department_id &#x3D; d.department_id
JOIN locations l ON d.location_id &#x3D; l.location_id;</code></pre>

<p><span class="red">另一种有趣的理解：</span>一个表要加入（JOIN）到原表的团队中，他需要有一个联系人（指与原表有某种联系，对应 ON + 连接条件）</p>
<p><img src="https://s1.ax1x.com/2022/05/13/OykhZQ.png" alt="OykhZQ.png"></p>
<hr>
<p><strong>SQL99语法实现外连接</strong></p>
<p>左外连接就是 <code>LEFT OUTER JOIN</code> 或 <code>LEFT JOIN</code></p>
<p>右外连接就是 <code>RIGHT OUTER JOIN</code> 或 <code>RIGHT JOIN</code></p>
<p>满外连接肯定就是 <code>FULL OUTER JOIN</code> 或 <code>FULL JOIN</code> 啦，戳啦，MySQL又不支持嘛，焯！</p>
<p><span class="red">注意：</span>Oracle支持上面六条（包括省略了 <code>OUTER</code> 的）连接语句</p>
<h2 id="SQL联合查询结果（UNION-ALL）"><a href="#SQL联合查询结果（UNION-ALL）" class="headerlink" title="SQL联合查询结果（UNION ALL）"></a>SQL联合查询结果（UNION ALL）</h2><p><span class="red bold">联合查询结果：</span>使用 <code>UNION ALL</code> 将该关键字两边的查询结果取并集</p>
<p><span class="red bold">联合查询结果并去重：</span>使用 <code>UNION</code> 将该关键字两边的查询结果取并集<span class="red">并且去除重复记录</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT * FROM employees WHERE email LIKE &#39;%a%&#39;
UNION
SELECT * FROM employees WHERE department_id &gt; 90;</code></pre>

<p><span class="red">注意：</span>因为 <code>UNION</code> 需要进行去重，因此其效率会比 <code>UNION ALL</code> 要慢，能用 <code>UNION ALL</code> 的地方不会使用 <code>UNION</code>，通常会在定下过滤条件时避免两个结果有重复</p>
<h2 id="MySQL实现7种JOIN查询（重要）"><a href="#MySQL实现7种JOIN查询（重要）" class="headerlink" title="MySQL实现7种JOIN查询（重要）"></a>MySQL实现7种JOIN查询（重要）</h2><p><img src="https://bkimg.cdn.bcebos.com/pic/8c1001e93901213f5a0febf15fe736d12f2e95db?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U4MA==,g_7,xp_5,yp_5/format,f_auto" alt="SQL joins"></p>
<hr>
<p><strong>中图实现</strong></p>
<p><img src="https://s1.ax1x.com/2022/05/13/OyMwlj.png" alt="OyMwlj.png"></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 内连接
SELECT employee_id, department_id
FROM employees e
JOIN departments d ON e.department_id &#x3D; d.department_id;</code></pre>

<hr>
<p><strong>左上图实现</strong></p>
<p><img src="https://s1.ax1x.com/2022/05/13/OyMy7V.png" alt="OyMy7V.png"></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 左外连接
SELECT employee_id, department_id
FROM employees e
LEFT JOIN departments d ON e.department_id &#x3D; d.department_id;</code></pre>

<hr>
<p><strong>右上图实现</strong></p>
<p><img src="https://s1.ax1x.com/2022/05/13/OyMhc9.png" alt="OyMhc9.png"></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 右外连接
SELECT employee_id, department_id
FROM employees e
RIGHT JOIN departments d ON e.department_id &#x3D; d.department_id;</code></pre>

<hr>
<p><strong>左下图实现</strong></p>
<p><img src="https://s1.ax1x.com/2022/05/13/OyMvjA.png" alt="OyMvjA.png"></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 左外连接并去除满足条件的
SELECT employee_id, department_id
FROM employees e
LEFT JOIN departments d ON e.department_id &#x3D; d.department_id
WHERE NOT d.department_id IS NULL;</code></pre>

<hr>
<p><strong>右下图实现</strong></p>
<p><img src="https://s1.ax1x.com/2022/05/13/OyQeun.png" alt="OyQeun.png"></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 右外连接并去除满足匹配条件
SELECT employee_id, department_id
FROM employees e
RIGHT JOIN departments d ON e.department_id &#x3D; d.department_id
WHERE NOT e.department_id IS NULL;</code></pre>

<hr>
<p><strong>满外连接实现</strong></p>
<p><img src="https://s1.ax1x.com/2022/05/13/OyQbbq.png" alt="OyQbbq.png"></p>
<p>对啦，就是：</p>
<ol>
<li>左上 + 右下</li>
<li>右上 + 左下</li>
</ol>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT employee_id, department_id
FROM employees e
RIGHT JOIN departments d ON e.department_id &#x3D; d.department_id

UNION ALL

SELECT employee_id, department_id
FROM employees e
RIGHT JOIN departments d ON e.department_id &#x3D; d.department_id
WHERE e.department_id IS NULL;</code></pre>

<hr>
<p><strong>满外连接并去除满足匹配条件</strong></p>
<p><img src="https://s1.ax1x.com/2022/05/13/OyGEmd.png" alt="OyGEmd.png"></p>
<p>然后这个就是 左下 + 右下 啦</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 满外连接并去除满足匹配条件

SELECT employee_id, department_id
FROM employees e
RIGHT JOIN departments d ON e.department_id &#x3D; d.department_id
WHERE e.department_id IS NULL

UNION ALL

SELECT employee_id, department_id
FROM employees e
LEFT JOIN departments d ON e.department_id &#x3D; d.department_id
WHERE d.department_id IS NULL;</code></pre>

<h2 id="SQL99新特性-自然连接（NATURAL-JOIN）"><a href="#SQL99新特性-自然连接（NATURAL-JOIN）" class="headerlink" title="SQL99新特性-自然连接（NATURAL JOIN）"></a>SQL99新特性-自然连接（NATURAL JOIN）</h2><p>使用 <code>NATURAL JOIN</code>，则SQL将自动寻找两个表中的相同字段作为连接条件进行连接，从而可以不写连接条件</p>
<p><span class="red">注意：</span>因为这是自动的，因此有几个相同的字段就会使用几个连接条件，在某些时候效率还是不如 <code>JOIN ON</code>，因此不建议使用</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT employee_id, department_id
FROM employees e
NATURAL JOIN departments d</code></pre>

<h2 id="SQL99新特性-指定等值连接字段（USING）"><a href="#SQL99新特性-指定等值连接字段（USING）" class="headerlink" title="SQL99新特性-指定等值连接字段（USING）"></a>SQL99新特性-指定等值连接字段（USING）</h2><p><span class="red">注意：</span><code>USING</code> 不适用于自连接</p>
<p>若两个表中存在相同的字段时，使用 <code>USING (字段名)</code> 指定等值连接字段</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT employee_id, department_id
FROM employees e
LEFT JOIN departments d USING (department_id);</code></pre>

<h2 id="MySQL单行函数——基本、字符串、时间"><a href="#MySQL单行函数——基本、字符串、时间" class="headerlink" title="MySQL单行函数——基本、字符串、时间"></a>MySQL单行函数——基本、字符串、时间</h2><p>不同DBMS之间的函数差异很大，大部分DBMS都有自己特定的函数，因此在使用不同DBMS时需要注意，这里写的是<span class="red">MySQL用函数</span></p>
<p><span class="red bold">单行函数：</span>单行函数指的是该函数仅作用于一行（或一个）数据，<span class="red">一行（或一个）数据返回一个值</span>，并且当参数指定为一个字段名时，MySQL会将该函数循环作用于每一行的该字段，并不是指这个函数占一行</p>
<hr>
<p><strong>数值函数——基本函数</strong></p>
<p><span class="red bold">注意：</span>（包括所有数值函数）这些函数只用在字符串就太可惜了，这里的参数可以传入字段名，这是当然的</p>
<table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ABS(x)</td>
<td align="center">取绝对值</td>
</tr>
<tr>
<td align="center">SIGN(x)</td>
<td align="center">符号函数</td>
</tr>
<tr>
<td align="center">PI()</td>
<td align="center">π</td>
</tr>
<tr>
<td align="center">CEIL(x)</td>
<td align="center">天花板函数，将传入的值向上取整</td>
</tr>
<tr>
<td align="center">CEILING(x)</td>
<td align="center">同上</td>
</tr>
<tr>
<td align="center">FLOOR(x)</td>
<td align="center">地板函数，将传入的值向下取整</td>
</tr>
<tr>
<td align="center">MOD(a, b)</td>
<td align="center">取模函数，a MOD b</td>
</tr>
<tr>
<td align="center">RAND()</td>
<td align="center">返回0~1之间的随机数</td>
</tr>
<tr>
<td align="center">RAND(x)</td>
<td align="center">返回0~1之间的随机数，x作为种子值<br />相同的x产生的随机数相同</td>
</tr>
<tr>
<td align="center">ROUND(x)</td>
<td align="center">将传入的值四舍五入取整</td>
</tr>
<tr>
<td align="center">ROUND(a, b)</td>
<td align="center">将传入的a四舍五入并保留b位小数<br />（b可以是负数）</td>
</tr>
<tr>
<td align="center">FORMAT(a, b)</td>
<td align="center">同上（但若b&lt;&#x3D;0，则只保留整数位）</td>
</tr>
<tr>
<td align="center">TRUNCATE(a,b)</td>
<td align="center">截断函数，将传入的a不作任何舍入保留b位小数</td>
</tr>
<tr>
<td align="center">SQRT(X)</td>
<td align="center">开平方函数</td>
</tr>
</tbody></table>
<hr>
<p><strong>数值函数——三角函数</strong></p>
<table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">RADIANS(x)</td>
<td align="center">将角度转换为弧度</td>
</tr>
<tr>
<td align="center">DEGREES(S)</td>
<td align="center">将弧度转换为角度</td>
</tr>
</tbody></table>
<p><span class="red bold">注意：</span>以下三角函数参数</p>
<ul>
<li>rad表示弧度</li>
<li>deg表示角度</li>
</ul>
<table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SIN(rad)</td>
<td align="center">正弦函数</td>
</tr>
<tr>
<td align="center">ASIN(x)</td>
<td align="center">反正弦函数，x∈[-1, 1]</td>
</tr>
<tr>
<td align="center">COS(rad)</td>
<td align="center">余弦函数</td>
</tr>
<tr>
<td align="center">ACOS(x)</td>
<td align="center">反余弦函数，x∈[-1, 1]</td>
</tr>
<tr>
<td align="center">TAN(rad)</td>
<td align="center">正切函数</td>
</tr>
<tr>
<td align="center">ATAN(x)</td>
<td align="center">反正切函数</td>
</tr>
<tr>
<td align="center">ATAN2(a,b)</td>
<td align="center">返回两个值的反正切值</td>
</tr>
<tr>
<td align="center">COT(rad)</td>
<td align="center">余切函数</td>
</tr>
</tbody></table>
<hr>
<p><strong>数值函数——指数与对数</strong></p>
<table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">POW(a,b)</td>
<td align="center">返回a的b次方</td>
</tr>
<tr>
<td align="center">POWER(a, b)</td>
<td align="center">同上</td>
</tr>
<tr>
<td align="center">EXP(x)</td>
<td align="center">返回e的x次方</td>
</tr>
<tr>
<td align="center">LN(x)</td>
<td align="center">返回以e为底x的对数</td>
</tr>
<tr>
<td align="center">LOG(x)</td>
<td align="center">同上</td>
</tr>
<tr>
<td align="center">LOG10(x)</td>
<td align="center">返回以10为底x的对数</td>
</tr>
<tr>
<td align="center">LOG2(x)</td>
<td align="center">返回以2为底x的对数</td>
</tr>
</tbody></table>
<hr>
<p><strong>数值函数——进制转换</strong></p>
<table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">BIN(x)</td>
<td align="center">二进制</td>
</tr>
<tr>
<td align="center">HEX(x)</td>
<td align="center">十六进制</td>
</tr>
<tr>
<td align="center">OCT(x)</td>
<td align="center">八进制</td>
</tr>
<tr>
<td align="center">CONV(x, a, b)</td>
<td align="center">返回x在a进制的情况下转换为b进制的结果</td>
</tr>
</tbody></table>
<hr>
<p><strong>字符串函数</strong></p>
<p><span class="red bold">注意：</span>（包括所有字符串函数）这些函数只用在字符串就太可惜了，这里的参数可以传入字段名，这是当然的</p>
<table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">CONVERT(str USING encoding)</td>
<td align="center">将str的编码格式变为encoding</td>
</tr>
<tr>
<td align="center">ASCII(str)</td>
<td align="center">返回字符串第一个字符的ASCII码</td>
</tr>
<tr>
<td align="center">CHAR_LENGTH(str)</td>
<td align="center">返回字符串的<span class="red">字符个数</span></td>
</tr>
<tr>
<td align="center">LENGTH(str)</td>
<td align="center">返回字符串占用的<span class="red">字节个数</span><br />（utf8里面每个汉字占3个字节）</td>
</tr>
<tr>
<td align="center">CONCAT(str1, str2, …)</td>
<td align="center">字符串连接函数</td>
</tr>
<tr>
<td align="center">CONCAT_WS(s, str1, str2, …)</td>
<td align="center">字符串分隔连接函数<br />并且使用分隔符s将他们隔开</td>
</tr>
<tr>
<td align="center">INSERT(str, index, len, replacestr)</td>
<td align="center">字符串插入型替换函数<br />将str中从第index个字符开始的len个字符<br />替换为replacestr</td>
</tr>
</tbody></table>
<p><span class="red bold">注意！：</span>SQL的字符索引从1开始算，如：</p>
<pre><code>INSERT(&#39;hello&#39;, 2, 3, uuuuu)
的结果为
huuuuuo
</code></pre>
<table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">REPLACE(str, a, b)</td>
<td align="center">将字符串中所有a字符串替换为b字符串<br />若没有a字符串则不替换</td>
</tr>
<tr>
<td align="center">UPPER(str)</td>
<td align="center">大写转换</td>
</tr>
<tr>
<td align="center">UCASE(str)</td>
<td align="center">同上</td>
</tr>
<tr>
<td align="center">LOWER(str)</td>
<td align="center">小写转换<br />一个巧妙的用法：<br />LOWER(last_name) &#x3D; ‘King’</td>
</tr>
<tr>
<td align="center">LCASE(str)</td>
<td align="center">同上</td>
</tr>
<tr>
<td align="center">LEFT(str, n)</td>
<td align="center">从str左边取n个字符</td>
</tr>
<tr>
<td align="center">RIGHT(str, n)</td>
<td align="center">从str右边取n个字符</td>
</tr>
<tr>
<td align="center">LPAD(str, len, pad)</td>
<td align="center">左补齐函数<br />右对齐效果<br />若str不足len个字符，则在其左侧使用pad补齐</td>
</tr>
<tr>
<td align="center">RPAD(str, len, pad)</td>
<td align="center">右补齐函数<br />左对齐效果<br />若str不足len个字符，则在其右侧使用pad补齐</td>
</tr>
<tr>
<td align="center">TRIM(str)</td>
<td align="center">去除首尾空格</td>
</tr>
<tr>
<td align="center">LTRIM(str)</td>
<td align="center">去除字符串左侧空格</td>
</tr>
<tr>
<td align="center">RTRIM(str)</td>
<td align="center">去除字符串右侧空格</td>
</tr>
<tr>
<td align="center">TRIM(s FROM str)</td>
<td align="center">去除str首尾的s字符</td>
</tr>
<tr>
<td align="center">TRIM(LEAIDNG s FROM str)</td>
<td align="center">去除str开始处的s字符</td>
</tr>
<tr>
<td align="center">TRIM(TRAILING s FROM str)</td>
<td align="center">去除str结尾处的s字符</td>
</tr>
<tr>
<td align="center">REPEAT(str, n)</td>
<td align="center">把str重复n次</td>
</tr>
<tr>
<td align="center">SPACE(n)</td>
<td align="center">返回n个空格</td>
</tr>
<tr>
<td align="center">STRCMP(s1, s2)</td>
<td align="center">比较两个字符串</td>
</tr>
<tr>
<td align="center">SUBSTR(str, index, len)</td>
<td align="center">返回str从index开始共len个字符<br /><span class="red">注意index从1开始</span></td>
</tr>
<tr>
<td align="center">LOCAT(substr, str)</td>
<td align="center">返回substr首次在str中出现的位置<br />未找到返回0</td>
</tr>
<tr>
<td align="center">ELT(n, s1, s2, …)</td>
<td align="center">返回参数中后面的第n个字符串<br />即返回sn</td>
</tr>
<tr>
<td align="center">FIELD(s, s1, s2, …)</td>
<td align="center">返回s在参数中后面的字符串中首次出现的位置<br /><span class="red">注意位置从1开始</span></td>
</tr>
<tr>
<td align="center">FIND_IN_SET(s1, s2)</td>
<td align="center">返回s1在s2中首次出现的位置<br />其中s2是以逗号分隔的字符串集<br />（如’11,22,33,44,55’）</td>
</tr>
<tr>
<td align="center">REVERSE(str)</td>
<td align="center">返回反转后的字符串</td>
</tr>
<tr>
<td align="center">NULLIF(str1, str2)</td>
<td align="center">比较两个字符串<br />若相等返回NULL，否则返回str1</td>
</tr>
</tbody></table>
<hr>
<p><strong>日期与时间函数——获取时间</strong></p>
<table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><span class="red">CURDATE()</span></td>
<td align="center">返回当前日期，包括年、月、日</td>
</tr>
<tr>
<td align="center">CURRENT_DATE()</td>
<td align="center">同上</td>
</tr>
<tr>
<td align="center"><span class="red">CURTIME()</span></td>
<td align="center">返回当前时间，包括时、分、秒</td>
</tr>
<tr>
<td align="center">CURRENT_TIME()</td>
<td align="center">同上</td>
</tr>
<tr>
<td align="center"><span class="red">NOW()</span></td>
<td align="center">返回当前系统日期和时间</td>
</tr>
<tr>
<td align="center"><span class="red">SYSDATE()</span></td>
<td align="center">同上</td>
</tr>
<tr>
<td align="center">CURRENT_TIMESTAMP()</td>
<td align="center">同上（这个返回的确实是时间而不是时间戳）</td>
</tr>
<tr>
<td align="center">LOCALTIME()</td>
<td align="center">同上</td>
</tr>
<tr>
<td align="center">LOCALTIMESTAMP()</td>
<td align="center">同上（这个返回的确实是时间而不是时间戳）</td>
</tr>
<tr>
<td align="center">UTC_DATE()</td>
<td align="center">返回UTC（世界标准时间）日期</td>
</tr>
<tr>
<td align="center">UTC_TIME()</td>
<td align="center">返回UTC（世界标准时间）时间</td>
</tr>
</tbody></table>
<hr>
<p><strong>日期与时间函数——日期与时间戳转换</strong></p>
<p><span class="red bold">注意：</span>这里的时间戳与Java中的不同，Java中的时间戳返回的是毫秒数，这里只返回秒数</p>
<table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">UNIX_TIMESTAMP()</td>
<td align="center">以UNIX时间戳的形式返回当前时间</td>
</tr>
<tr>
<td align="center">UNIX_TIMESTAMP(DATE)</td>
<td align="center">将DATE转换为时间戳</td>
</tr>
<tr>
<td align="center">FROM_UNIXTIME(timestamp)</td>
<td align="center">将timestamp时间戳转换为日期和时间</td>
</tr>
</tbody></table>
<hr>
<p><strong>日期与时间函数——获取月份、星期、星期数、天数</strong></p>
<p><span class="red bold">注意：</span>日期和时间在SQL中的表现形式默认是 <code>YYYY-MM-dd HH-mm-ss</code>，若传入的字符串符合这种格式，SQL会将字符串隐式转换为日期和时间</p>
<table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">YEAR(date)</td>
<td align="center">返回传入日期的年份</td>
</tr>
<tr>
<td align="center">MONTH(date)</td>
<td align="center">返回传入日期的月份</td>
</tr>
<tr>
<td align="center">DAY(date)</td>
<td align="center">返回传入日期的天</td>
</tr>
<tr>
<td align="center">HOUR(date&#x2F;time)</td>
<td align="center">返回传入日期或时间的小时数</td>
</tr>
<tr>
<td align="center">MINUTE(date&#x2F;time)</td>
<td align="center">返回传入日期或时间的分钟数</td>
</tr>
<tr>
<td align="center">SECOND(date&#x2F;time)</td>
<td align="center">返回传入日期或时间的秒数</td>
</tr>
<tr>
<td align="center">MONTHNAME(date)</td>
<td align="center">以名称的形式返回传入的日期的月份</td>
</tr>
<tr>
<td align="center">DAYNAME(date)</td>
<td align="center">以名称的形式返回传入日期为星期几</td>
</tr>
<tr>
<td align="center">WEEKDAY(date)</td>
<td align="center">返回传入的日期为星期几<br /><span class="red">周一为0, …周日为6 </span></td>
</tr>
<tr>
<td align="center">QUARTER(date)</td>
<td align="center">返回传入日期为所在年的第几季度<br /><span class="red">范围为1~4</span></td>
</tr>
<tr>
<td align="center">WEEK(date)</td>
<td align="center">返回传入日期位于所在年的第几周</td>
</tr>
<tr>
<td align="center">WEEKOFYEAR(date)</td>
<td align="center">同上</td>
</tr>
<tr>
<td align="center">DAYOFYEAR(date)</td>
<td align="center">返回传入日期位于所在年的第几天</td>
</tr>
<tr>
<td align="center">DAYOFMONTH(date)</td>
<td align="center">返回传入日期位于所在月份的第几天</td>
</tr>
<tr>
<td align="center">DAYOFWEEK(date)</td>
<td align="center">返回传入日期为星期几<br /><span class="red">周日为1, … 周六为7</span></td>
</tr>
</tbody></table>
<hr>
<p><strong>日期与时间函数——获取特定的一部分</strong></p>
<table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">EXTRACT(type FROM date)</td>
<td align="center">获取date日期中的type部分</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">type可用值</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">MICROSECOND</td>
<td align="center">微秒数</td>
</tr>
<tr>
<td align="center">SECOND</td>
<td align="center">秒数</td>
</tr>
<tr>
<td align="center">MINUTE</td>
<td align="center">分钟数</td>
</tr>
<tr>
<td align="center">HOUR</td>
<td align="center">小时数</td>
</tr>
<tr>
<td align="center">DAY</td>
<td align="center">天数</td>
</tr>
<tr>
<td align="center">WEEK</td>
<td align="center">星期</td>
</tr>
<tr>
<td align="center">MONTH</td>
<td align="center">月份</td>
</tr>
<tr>
<td align="center">QUARTER</td>
<td align="center">季度</td>
</tr>
<tr>
<td align="center">YEAR</td>
<td align="center">年份</td>
</tr>
<tr>
<td align="center">SECOND_MICROSECOND</td>
<td align="center">秒和毫秒</td>
</tr>
<tr>
<td align="center">MINUTE_SECOND</td>
<td align="center">分钟和秒</td>
</tr>
<tr>
<td align="center">HOUR_MICROSECOND</td>
<td align="center">小时和毫秒</td>
</tr>
<tr>
<td align="center">HOUR_SECOND</td>
<td align="center">小时和秒</td>
</tr>
<tr>
<td align="center">HOUR_MINUTE</td>
<td align="center">小时和分钟</td>
</tr>
<tr>
<td align="center">DAY_MICROSECOND</td>
<td align="center">天数和毫秒</td>
</tr>
<tr>
<td align="center">DAY_SECOND</td>
<td align="center">天数和秒</td>
</tr>
<tr>
<td align="center">DAY_MINUTE</td>
<td align="center">天数和分钟</td>
</tr>
<tr>
<td align="center">DAY_HOUR</td>
<td align="center">天数和小时</td>
</tr>
<tr>
<td align="center">YEAR_MONTH</td>
<td align="center">年和月</td>
</tr>
</tbody></table>
<hr>
<p><strong>日期与时间函数——时间转换为秒数</strong></p>
<p><span class="red bold">注意：</span>这里的秒数并不是时间戳，而是一天中的秒数</p>
<table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">TIME_TO_SEC(date&#x2F;time)</td>
<td align="center">将传入的日期或时间转换为一天中的秒数</td>
</tr>
<tr>
<td align="center">SEC_TO_TIME(second)</td>
<td align="center">将传入的秒数转换为一天中的时间</td>
</tr>
</tbody></table>
<hr>
<p><strong>日期与时间函数——日期计算函数</strong></p>
<p><span class="red bold">注意：</span></p>
<ol>
<li><code>INTERVAL</code> 是关键字</li>
<li>type是值expr的类型（如增加一年就是 <code>INTERVAL 1 YEAR</code>）</li>
<li>expr可以为负数</li>
<li>若要操作两个参数，要注意expr传入的是字符串，并且两个参数之间要加上下划线（如增加1分钟和1秒就是 <code>INTERVAL &#39;1_1&#39; MINUTE_SECOND</code>）</li>
</ol>
<table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">DATE_ADD(date, INTERVAL expr type)</td>
<td align="center">返回date增加指定值的日期和时间</td>
</tr>
<tr>
<td align="center">ADDDATE(date, INTERVAL expr type)</td>
<td align="center">同上</td>
</tr>
<tr>
<td align="center">DATE_SUB(date, INTERVAL expr type)</td>
<td align="center">返回date减少指定值的日期和时间</td>
</tr>
<tr>
<td align="center">SUBDATE(date, INTERVAL expr type)</td>
<td align="center">同上</td>
</tr>
<tr>
<td align="center">DATEDIFF(date1, date2)</td>
<td align="center">返回date2-date1的绝对值，精确到天</td>
</tr>
<tr>
<td align="center">FROM_DAYS(n)</td>
<td align="center">返回从0000-01-01起，n天后的日期</td>
</tr>
<tr>
<td align="center">TO_DAYS(date)</td>
<td align="center">返回date距离0000-01-01的天数</td>
</tr>
<tr>
<td align="center">LAST_DAY(date)</td>
<td align="center">返回date所在月份的最后一天的日期</td>
</tr>
<tr>
<td align="center">MAKEDATE(year, day)</td>
<td align="center">返回year年中的第day天的日期</td>
</tr>
<tr>
<td align="center">PERIOD_ADD(time, n)</td>
<td align="center">返回time加上n月后的时间<br /><span class="red">注意参数time的传入格式为YYYYMM，且传入的是数值</span></td>
</tr>
</tbody></table>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT PERIOD_ADD(202205,2) FROM DUAL;</code></pre>

<table>
<thead>
<tr>
<th align="center">type</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">HOUR</td>
<td align="center">小时</td>
</tr>
<tr>
<td align="center">MINUTE</td>
<td align="center">分钟</td>
</tr>
<tr>
<td align="center">SECOND</td>
<td align="center">秒</td>
</tr>
<tr>
<td align="center">YEAR</td>
<td align="center">年</td>
</tr>
<tr>
<td align="center">MONTH</td>
<td align="center">月</td>
</tr>
<tr>
<td align="center">DAY</td>
<td align="center">日</td>
</tr>
<tr>
<td align="center">YEAR_MONTH</td>
<td align="center">年和月</td>
</tr>
<tr>
<td align="center">DAY_HOUR</td>
<td align="center">天数和小时</td>
</tr>
<tr>
<td align="center">DAY_MINUTE</td>
<td align="center">天数和分钟</td>
</tr>
<tr>
<td align="center">DAY_SECOND</td>
<td align="center">天数和秒</td>
</tr>
<tr>
<td align="center">HOUR_SECOND</td>
<td align="center">小时和秒</td>
</tr>
<tr>
<td align="center">MINUTE_SECOND</td>
<td align="center">分钟和秒</td>
</tr>
</tbody></table>
<hr>
<p><strong>日期与时间函数——时间计算函数</strong></p>
<table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ADDTIME(time1, time2)</td>
<td align="center">返回time1加上time2的时间<br />当time2只有一个数字时，默认代表秒<br />可以为负数</td>
</tr>
<tr>
<td align="center">SUBTIME(time1, time2)</td>
<td align="center">返回time1减去time2的时间<br />当time2只有一个数字时，默认代表秒<br />可以为负数</td>
</tr>
<tr>
<td align="center">TIMEDIFF(date1&#x2F;time1, date2&#x2F;time2)</td>
<td align="center">返回time2-time1的绝对值，返回的格式为时间</td>
</tr>
<tr>
<td align="center">MAKETIME(hour, minute, second)</td>
<td align="center">将给定的小时、分钟和秒数组合成一个时间</td>
</tr>
</tbody></table>
<hr>
<p><strong>日期的格式化与解析</strong></p>
<table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">DATE_FORMAT(date fmt)</td>
<td align="center"><span class="red">（格式化）</span>按照字符串fmt格式化日期date值</td>
</tr>
<tr>
<td align="center">TIME_FORMAT(time, fmt)</td>
<td align="center"><span class="red">（格式化）</span>按照字符串fmt格式化时间time值</td>
</tr>
<tr>
<td align="center">STR_TO_DATE(str, fmt)</td>
<td align="center"><span class="red">（解析）</span>按照字符串fmt将str解析为一个日期</td>
</tr>
<tr>
<td align="center">GET_FORMAT(date_type, format_type)</td>
<td align="center">返回以format_type标准表示的date_type的fmt格式</td>
</tr>
</tbody></table>
<p><span class="red bold">fmt—格式化形式的填写：</span></p>
<table>
<thead>
<tr>
<th align="center">格式符</th>
<th align="center">含义</th>
<th align="center">格式符</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&amp;nbsp;</td>
<td align="center"><span class="red">年</span></td>
<td align="center"><span class="red">份</span></td>
<td align="center">&amp;nbsp;</td>
</tr>
<tr>
<td align="center">%Y</td>
<td align="center">四位数字年份</td>
<td align="center">%y</td>
<td align="center">后两位数字年份</td>
</tr>
<tr>
<td align="center">&amp;nbsp;</td>
<td align="center"><span class="red">月</span></td>
<td align="center"><span class="red">份</span></td>
<td align="center">&amp;nbsp;</td>
</tr>
<tr>
<td align="center">%M</td>
<td align="center">英文完整名称月份</td>
<td align="center">%b</td>
<td align="center">英文缩写名称月份</td>
</tr>
<tr>
<td align="center">%m</td>
<td align="center">两位数字月份<br />（1月显示01）</td>
<td align="center">%c</td>
<td align="center">最短个数数字月份<br />（1月显示1）</td>
</tr>
<tr>
<td align="center">&amp;nbsp;</td>
<td align="center"><span class="red">天</span></td>
<td align="center"><span class="red">数</span></td>
<td align="center">&amp;nbsp;</td>
</tr>
<tr>
<td align="center">%D</td>
<td align="center">数字+英文后缀天数</td>
<td align="center">%d</td>
<td align="center">两位数字天数</td>
</tr>
<tr>
<td align="center">%e</td>
<td align="center">最短数字数字天数</td>
<td align="center">&amp;nbsp;</td>
<td align="center">&amp;nbsp;</td>
</tr>
<tr>
<td align="center">&amp;nbsp;</td>
<td align="center"><span class="red">小</span></td>
<td align="center"><span class="red">时</span></td>
<td align="center">&amp;nbsp;</td>
</tr>
<tr>
<td align="center">%H</td>
<td align="center">两位数字小时<br />24小时制</td>
<td align="center">&amp;nbsp;</td>
<td align="center">&amp;nbsp;</td>
</tr>
<tr>
<td align="center">%h</td>
<td align="center">两位数字小时<br />12小时制</td>
<td align="center">%I（i大写）</td>
<td align="center">两位数字小时<br />12小时制</td>
</tr>
<tr>
<td align="center">%k</td>
<td align="center">最短数字小时<br />24小时制</td>
<td align="center">%l（L小写）</td>
<td align="center">最短数字数字小时<br />12小时制</td>
</tr>
<tr>
<td align="center">&amp;nbsp;</td>
<td align="center"><span class="red">分</span></td>
<td align="center"><span class="red">钟</span></td>
<td align="center">&amp;nbsp;</td>
</tr>
<tr>
<td align="center">%i</td>
<td align="center">两位数字分钟</td>
<td align="center">&amp;nbsp;</td>
<td align="center">&amp;nbsp;</td>
</tr>
<tr>
<td align="center">&amp;nbsp;</td>
<td align="center"><span class="red">秒</span></td>
<td align="center"><span class="red">钟</span></td>
<td align="center">&amp;nbsp;</td>
</tr>
<tr>
<td align="center">%S</td>
<td align="center">两位数字表示秒</td>
<td align="center">%s</td>
<td align="center">两位数字表示秒<br />（没错这两个一样）</td>
</tr>
<tr>
<td align="center"><span class="red">完</span></td>
<td align="center"><span class="red">整</span></td>
<td align="center"><span class="red">时</span></td>
<td align="center"><span class="red">间</span></td>
</tr>
<tr>
<td align="center">%T</td>
<td align="center">24小时制完整时间<br />（使用默认格式 00:00:00）</td>
<td align="center">%r</td>
<td align="center">12小时制完整时间<br />（使用默认格式 00:00:00）</td>
</tr>
<tr>
<td align="center">&amp;nbsp;</td>
<td align="center"><span class="red">星</span></td>
<td align="center"><span class="red">期</span></td>
<td align="center">&amp;nbsp;</td>
</tr>
<tr>
<td align="center">%W</td>
<td align="center">英文完整名称星期</td>
<td align="center">%a</td>
<td align="center">英文缩写名称星期</td>
</tr>
<tr>
<td align="center">%w</td>
<td align="center">数字星期<br />（周日为0, …, 周六为6）</td>
<td align="center">&amp;nbsp;</td>
<td align="center">&amp;nbsp;</td>
</tr>
<tr>
<td align="center"><span class="red">年</span></td>
<td align="center"><span class="red">中</span></td>
<td align="center"><span class="red">参</span></td>
<td align="center"><span class="red">数</span></td>
</tr>
<tr>
<td align="center">%j</td>
<td align="center">三位数字年中天数</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">%U</td>
<td align="center">最短数字表示年中周数<br />（定义周日为每周第一天）</td>
<td align="center">%u</td>
<td align="center">最短数字表示年中周数<br />（定义周一为每周第一天）</td>
</tr>
<tr>
<td align="center">&amp;nbsp;</td>
<td align="center"><span class="red">特</span></td>
<td align="center"><span class="red">殊</span></td>
<td align="center">&amp;nbsp;</td>
</tr>
<tr>
<td align="center">%p</td>
<td align="center">AM或PM</td>
<td align="center">%%</td>
<td align="center">表示百分号</td>
</tr>
</tbody></table>
<p><span class="red bold">date_type与format_type的填写：</span></p>
<ul>
<li>每个date_type都可以对应五个format_type</li>
<li>GET_FORMAT返回的是一个fmt（如%H:%i:%s）</li>
</ul>
<table>
<thead>
<tr>
<th align="center">date_type<br />格式化内容</th>
</tr>
</thead>
<tbody><tr>
<td align="center">DATE</td>
</tr>
<tr>
<td align="center">TIME</td>
</tr>
<tr>
<td align="center">DATETIME</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">format_type<br />格式化标准</th>
</tr>
</thead>
<tbody><tr>
<td align="center">USA</td>
</tr>
<tr>
<td align="center">JIS</td>
</tr>
<tr>
<td align="center">ISO</td>
</tr>
<tr>
<td align="center">EUR</td>
</tr>
<tr>
<td align="center">INTERNAL</td>
</tr>
</tbody></table>
<p><span class="red bold">使用例：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">DATE_FORMAT(hire_date, &#39;%Y-%m-%d&#39;) &gt;&#x3D; &#39;1997-01-01&#39;
DATE_FORMAT(hire_date, &#39;%Y&#39;) &gt;&#x3D; &#39;1997&#39;
hire_date &gt;&#x3D; STR_TO_DATE(&#39;1997-01-01&#39;, &#39;%Y-%m-%d&#39;)</code></pre>

<h2 id="MySQL单行函数——流程控制函数"><a href="#MySQL单行函数——流程控制函数" class="headerlink" title="MySQL单行函数——流程控制函数"></a>MySQL单行函数——流程控制函数</h2><p><span class="red bold">注意：</span>最下面两个流程控制的ELSE都是可选的</p>
<table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">IF(expr, value1, value2)</td>
<td align="center">expr?value1:value2</td>
</tr>
<tr>
<td align="center">IFNULL(value1, value2)</td>
<td align="center">value1 &#x3D;&#x3D; NULL?value2:value1</td>
</tr>
<tr>
<td align="center">CASE<br />WHEN 条件1 THEN 结果1<br />WHEN 条件2 THEN 结果2<br />[ELSE 结果n]<br />END</td>
<td align="center">if(条件1){结果1}<br />else if(条件2){结果2}<br />else{结果n}</td>
</tr>
<tr>
<td align="center">CASE 字段名<br />WHEN 常量1 THEN 结果1<br />WHEN 常量2 THEN 结果2<br />[ELSE 结果n]<br />END</td>
<td align="center">switch() {<br />case 常量1: 结果1<br />case 常量2: 结果2<br />default: 结果n }</td>
</tr>
</tbody></table>
<h2 id="MySQL单行函数——加密与解密"><a href="#MySQL单行函数——加密与解密" class="headerlink" title="MySQL单行函数——加密与解密"></a>MySQL单行函数——加密与解密</h2><table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">PASSWORD(str)</td>
<td align="center">返回字符串的41位长加密版本，该过程不可逆<br /><span class="red">在MySQL8.0中失效</span></td>
</tr>
<tr>
<td align="center">MD5(str)</td>
<td align="center">返回字符串经过md5加密算法加密后的值<br />该过程不可逆<br />若参数NULL，返回为NULL</td>
</tr>
<tr>
<td align="center">SHA(str)</td>
<td align="center">返回字符串经过SHA加密算法加密后的值<br />该过程不可逆<br />若参数NULL，返回为NULL</td>
</tr>
<tr>
<td align="center">ENCODE(value, password_seed)</td>
<td align="center">使用指定种子加密value<br /><span class="red">在MySQL8.0中失效</span></td>
</tr>
<tr>
<td align="center">DECODE(value, password_seed)</td>
<td align="center">使用指定种子解密value<br /><span class="red">在MySQL8.0中失效</span></td>
</tr>
</tbody></table>
<h2 id="MySQL单行函数——MySQL当前信息函数"><a href="#MySQL单行函数——MySQL当前信息函数" class="headerlink" title="MySQL单行函数——MySQL当前信息函数"></a>MySQL单行函数——MySQL当前信息函数</h2><table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">VERSION()</td>
<td align="center">返回MySQL版本号</td>
</tr>
<tr>
<td align="center">CONNECTION_ID()</td>
<td align="center">返回当前客户端与MySQL服务器的连接ID</td>
</tr>
<tr>
<td align="center">DATABASE()</td>
<td align="center">返回MySQL命令行所在的数据库</td>
</tr>
<tr>
<td align="center">SCHEMA()</td>
<td align="center">同上</td>
</tr>
<tr>
<td align="center">USER()</td>
<td align="center">返回当前连接MySQL的用户名<br />返回格式为“用户名@IP地址”</td>
</tr>
<tr>
<td align="center">CURRENT_USER()</td>
<td align="center">同上</td>
</tr>
<tr>
<td align="center">SYSTEM_USER()</td>
<td align="center">同上</td>
</tr>
<tr>
<td align="center">SESSION_USER()</td>
<td align="center">同上</td>
</tr>
<tr>
<td align="center">CHARSET(value)</td>
<td align="center">返回字符串value的字符集</td>
</tr>
<tr>
<td align="center">COLLATION(value)</td>
<td align="center">返回字符串value的比较规则</td>
</tr>
</tbody></table>
<h2 id="MySQL单行函数——其它函数"><a href="#MySQL单行函数——其它函数" class="headerlink" title="MySQL单行函数——其它函数"></a>MySQL单行函数——其它函数</h2><table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">INET_ATON(ipstr)</td>
<td align="center">将一个ip地址字符串转换为一个数字</td>
</tr>
<tr>
<td align="center">INET_NTOA(value)</td>
<td align="center">将一个数字转换为IP地址</td>
</tr>
<tr>
<td align="center">BENCHMARK(n, expr)</td>
<td align="center">将表达式expr重复执行n次<br />用于测试MySQL处理expr表达式所耗费的时间</td>
</tr>
</tbody></table>
<h2 id="MySQL聚合函数（多行函数）"><a href="#MySQL聚合函数（多行函数）" class="headerlink" title="MySQL聚合函数（多行函数）"></a>MySQL聚合函数（多行函数）</h2><p><span class="red bold">聚合函数：</span>也称多行函数，是指该函数作用于一组数据，<span class="red bold">多个数据返回一个值</span></p>
<hr>
<p><strong>五个常用聚合函数</strong></p>
<p><span class="red bold">注意：</span></p>
<ul>
<li>所有聚合函数都会受到 <code>GROUP BY</code> 分组影响</li>
<li>MySQL不支持聚合函数嵌套使用，但Oracle可以</li>
</ul>
<table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">AVG(field)</td>
<td align="center">返回该字段所有<span class="red">非空数值</span>的平均值<br /><span class="red">仅适用于数值</span></td>
</tr>
<tr>
<td align="center">SUM(field)</td>
<td align="center">返回该字段所有<span class="red">非空数值</span>的和<br /><span class="red">仅适用于数值</span></td>
</tr>
<tr>
<td align="center">MAX(field)</td>
<td align="center">返回该字段的最大值</td>
</tr>
<tr>
<td align="center">MIN(field)</td>
<td align="center">返回该字段的最小值</td>
</tr>
<tr>
<td align="center">COUNT(field)</td>
<td align="center">返回该字段在查询结构下数据的个数<br /><span class="red">（非NULL）</span></td>
</tr>
</tbody></table>
<p><span class="red bold">AVG&#x2F;SUM：</span>可以实现a+b的都可以使用 <code>AVG</code> 和 <code>SUM</code> ，因此 <code>AVG</code> 和 <code>SUM</code> 仅适用于数值类型</p>
<p><span class="red bold">MAX&#x2F;MIN：</span>可以实现对比或排序的都可以使用 <code>MAX</code> &#x2F; <code>MIN</code> ，因此 <code>MAX</code> 和 <code>MIN</code> 可以适用于数值、字符串和日期</p>
<p><span class="red bold">COUNT：</span></p>
<ul>
<li><p><span class="red bold">重要：</span>当涉及到外连接时，谨慎使用 <code>COUNT(*)</code>，大多数情况下应使用 <code>COUNT(字段名)</code></p>
</li>
<li><p><span class="red"><code>COUNT(字段名)</code> 和 <code>COUNT(常量)</code> 不会将NULL值计入, <code>COUNT(*)</code> 会将NULL计入</span></p>
</li>
<li><p><span class="red"><code>COUNT</code> 会受到WHERE筛选的影响</span></p>
</li>
<li><p>若 <code>COUNT()</code> 中写了一个常量，因为常量会分配给表中的每一行，所以在筛选条件下有多少行就有多少个常量被挑选出来</p>
</li>
<li><p><code>COUNT(*)</code> 和 <code>COUNT(常量)</code> 都可以用于统计表中的记录个数</p>
<ul>
<li><span class="red">在字段非空的情况下</span>， <code>COUNT(*)</code> 、 <code>COUNT(常量)</code> 和 <code>COUNT(字段名)</code> 都可以用于统计表中的记录个数（行数），在效率方面，他们有这样的关系：<ul>
<li>若数据库使用MyISAM存储引擎，每个表都有一个隐藏字段记录数据行数，因此三者效率相同</li>
<li>若数据库使用InnoDB存储引擎，则三者效率关系为： <code>COUNT(*)</code> &#x3D; <code>COUNT(常量)</code> &gt; <code>COUNT(字段名)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="MySQL分组与汇总（GROUP-BY-WITH-ROLLUP）"><a href="#MySQL分组与汇总（GROUP-BY-WITH-ROLLUP）" class="headerlink" title="MySQL分组与汇总（GROUP BY WITH ROLLUP）"></a>MySQL分组与汇总（GROUP BY WITH ROLLUP）</h2><hr>
<p><strong>分组（GROUP BY）</strong></p>
<p>对于聚合函数，它是作用于多行的函数，而通常我们需要根据某个字段的内容分批执行多行函数（如统计每个部门的平均工资），这时就需要分组</p>
<p><span class="red bold">注意：</span>聚合函数会受到分组的影响（正因如此分组才有意义）</p>
<p>分组可以被多个字段所影响，使用 <code>GROUP BY 字段名, 字段名, ...</code> ，看下面例子</p>
<ul>
<li>分组的字段名不分先后，谁前谁后结果一样，因为只有两个字段都一样的才会被分到一组，是一个且的关系</li>
</ul>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT department_id, AVG(salary)
FROM employees
GROUP BY department_id;</code></pre>

<p><span class="red bold">注意（重要）：</span>在使用分组时，<span class="red">SELECT中的非聚合函数字段，必须作为分组的依据出现在 <code>GROUP BY</code> 中</span>，若没有作为分组依据出现，<span class="red">虽然不会报错</span>，但会产生歧义：</p>
<ul>
<li><p>聚合函数会根据分组将聚合函数涉及的字段中的一组（多行）转变为一行，那么如何看待在一组中另一个要展示的字段存在不同的值并且它也要跟着将一组变为一行？</p>
</li>
<li><p>在MySQL中，由于其不严谨，默认将显示department_name的第一个值，但很明显这是没有意义的，在Orecle中这样做则直接报错</p>
</li>
</ul>
<p><img src="https://s1.ax1x.com/2022/05/23/XSlOpQ.md.png" alt="XSlOpQ.md.png"></p>
<hr>
<p><strong>汇总（WITH ROLLUP）</strong></p>
<p>在 <code>GOUP BY 字段名</code> 后面加上 <code>WITH ROLLUP</code> 会将<span class="red">分组后得到的结果在另起一行上做一个汇总（如：若求平均值，则将分组后的结果再一起求一次平均值）</span>（没有分组就没有汇总的必要了）</p>
<p><span class="red bold">注意：</span>在使用了 <code>WITH ROLLUP</code> 之后，<span class="red">谨慎使用排序！</span></p>
<ul>
<li>对分立的结果和汇总的结果进行排序是没有意义的，MySQL在8.0之前会报错，在8.0之后若同时使用汇总和排序则会将汇总结果自动上升到第一位，无论汇总的结果大小</li>
</ul>
<h2 id="MySQL分组筛选（HAVING）"><a href="#MySQL分组筛选（HAVING）" class="headerlink" title="MySQL分组筛选（HAVING）"></a>MySQL分组筛选（HAVING）</h2><p><span class="red bold">对分组后结果的筛选需求：</span></p>
<p><code>WHERE</code> 仅用于对行数未变化的（未经过聚合函数书里的）表进行筛选，也正因此它写在 <code>GROUP BY</code> 前面，<span class="red"> <code>WHERE</code> 条件中禁止出现聚合函数</span>，以下代码将会报错</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 顺便提一句，WHERE中禁止出现字段别名
SELECT department_id, MAX(salary)
FROM employees
WHERE MAX(salary) &gt; 10000
GROUP BY department_id;</code></pre>

<p><span class="red bold">分组筛选：</span></p>
<p><code>HAVING</code> 对分组后的结果进行筛选，其语法与 <code>WHERE</code> 相同，不同点在于<span class="red"> <code>HAVING</code> 必须放在 <code>GROUP BY</code> 之后</span>（理所当然，因为先分组，再对分组结果筛选），上面的例子应该改成这样：</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 顺便提一句，HAVING里面可以使用字段别名
SELECT department_id, MAX(salary)
FROM employees
GROUP BY department_id
HAVING MAX(salary) &gt; 10000;</code></pre>

<hr>
<p><strong>HAVING和WHERE</strong></p>
<p><code>HAVING</code> 和 <code>WHERE</code> 都可以写非聚合函数条件</p>
<p><span class="red bold">效率：</span>在这两者共存的情况下，<span class="red">强烈建议将非聚合函数过滤条件写在 <code>WHERE</code> 里</span>，因为在分组前筛选掉没有用的数据可以提升分组和分组筛选的效率（见 SQL语句的执行顺序）</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT department_id, MAX(salary)
FROM employee_id
WHERE department_id IN (10,20,30,40)
GROUP BY department_id
HAVING MAX(salary) &gt; 10000;</code></pre>

<h2 id="一个基本完整的SELECT语句"><a href="#一个基本完整的SELECT语句" class="headerlink" title="一个基本完整的SELECT语句"></a>一个基本完整的SELECT语句</h2><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT （DISTINCT）..., ...（或存在聚合函数）,
    CASE （字段名） WHEN 条件 THEN 结果
    END AS &quot;别名&quot;

FROM 表名
    &#123;LEFT | RIGHT&#125; JOIN 另一张表 ON 条件 &#x2F; USING (连接用字段)
WHERE 非聚合筛选条件
GROUP BY 字段名 （WITH ROLLUP）
HAVING 筛选条件

ORDER BY 排序用字段 （DESC&#x2F;ASC）
LIMIT 偏移量,一页的数据量 &#x2F; LIMIT 一页数据量 OFFSET 偏移量

UNION WITH 第二次查询;</code></pre>

<h2 id="SQL语句的执行顺序"><a href="#SQL语句的执行顺序" class="headerlink" title="SQL语句的执行顺序"></a>SQL语句的执行顺序</h2><table>
<thead>
<tr>
<th align="center">SQL语句的执行顺序</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="https://s1.ax1x.com/2022/05/23/XShq1S.png" alt="XShq1S.png"></td>
</tr>
</tbody></table>
<hr>
<p><strong>第一部分</strong></p>
<ol>
<li>执行 <code>FROM</code> 和 <code>JOIN</code> 将两张表进行笛卡尔积连接</li>
<li>执行 <code>ON</code> 或 <code>USING</code> 对笛卡尔积连接后的表进行筛选</li>
<li>是否是外连接，若是，则向其中一个表补充一些数据</li>
<li>执行 <code>WHERE</code> 筛选（<span class="red">因此筛选禁止出现别名</span>）</li>
<li>执行 <code>GROUP BY</code> 分组（<span class="red">因此分组禁止出现别名</span>）</li>
<li>执行 <code>HAVING</code> 分组筛选<ul>
<li><span class="red">注意：</span>MySQL中的 <code>HAVING</code> 允许使用别名，因为MySQL对其进行了拓展（见 <a target="_blank" rel="noopener" href="https://qastack.cn/dba/50391/why-does-mysql-allow-having-to-use-select-aliases">为什么MySQL允许HAVING使用SELECT别名？</a>）</li>
</ul>
</li>
</ol>
<hr>
<p><strong>第二部分</strong></p>
<ol start="7">
<li>执行 <code>SELECT</code> 选择所需字段</li>
<li>执行 <code>DISTINCT</code> 去重</li>
</ol>
<hr>
<p><strong>第三部分</strong></p>
<ol start="9">
<li>执行 <code>ORDER BY</code> 排序</li>
<li>执行 <code>LIMIT</code> 分页</li>
</ol>
<hr>
<p><strong>最后（真的是最后）</strong></p>
<p>合并选择结果</p>
<h2 id="MySQL子查询——单行子查询"><a href="#MySQL子查询——单行子查询" class="headerlink" title="MySQL子查询——单行子查询"></a>MySQL子查询——单行子查询</h2><hr>
<p><strong>子查询的引入</strong></p>
<p><span class="red bold">需求：</span><br>查询员工表中工资比Abel高的员工姓名</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 两次查询
SELECT salary FROM employees
WHERE last_name &#x3D; &#39;Abel&#39;;

SELECT last_name FROM employees
WHERE salary &gt; 上面的查询结果;

-- 自连接
SELECT e1.last_name
FROM employees e1
JOIN employees e2 ON e1.salary &gt; e2.salary AND e2.last_name &#x3D; &#39;Abel&#39;;</code></pre>
<table>
<thead>
<tr>
<th align="center">自连接解法解析</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="https://s1.ax1x.com/2022/05/23/X9MJBt.md.png" alt="X9MJBt.md.png"></td>
</tr>
</tbody></table>
<hr>
<p><strong>子查询</strong></p>
<p>让我们认识一下子查询：</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 外查询（主查询）
SELECT last_name FROM employees
WHERE salary &gt; (
    -- 内查询（子查询）
    SELECT salary FROM employees
    WHERE last_name &#x3D; &#39;Abel&#39;
);</code></pre>

<hr>
<p><strong>子查询的分类</strong></p>
<p><span class="red bold">从内查询一次查询返回的结果行数：</span></p>
<ol>
<li>单行子查询：指内查询查询出来的是单行数据，结果交给外查询的单行函数或单行操作符处理</li>
<li>多行子查询：指内查询查询出来的是多行数据，结果交给外查询的聚合函数处理</li>
</ol>
<p><span class="red bold">从内查询是否被执行多次：</span></p>
<ol>
<li>非相关子查询：指内查询的结果是固定的，与外查询没有关联</li>
<li>相关子查询：指内查询的结果会受到外查询的影响</li>
</ol>
<hr>
<p><strong>单行子查询</strong></p>
<p><span class="red bold">单行子查询格式：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT ... FROM ...
WHERE 字段名 单行操作符 (子查询);</code></pre>

<table>
<thead>
<tr>
<th align="center">单行操作符</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&#x3D;</td>
<td align="center">等于</td>
</tr>
<tr>
<td align="center">!&#x3D;</td>
<td align="center">不等于</td>
</tr>
<tr>
<td align="center">&lt;&gt;</td>
<td align="center">不等于</td>
</tr>
<tr>
<td align="center">&gt;</td>
<td align="center">大于</td>
</tr>
<tr>
<td align="center">&gt;&#x3D;</td>
<td align="center">大于等于</td>
</tr>
<tr>
<td align="center">&lt;</td>
<td align="center">小于</td>
</tr>
<tr>
<td align="center">&lt;&#x3D;</td>
<td align="center">小于等于</td>
</tr>
</tbody></table>
<hr>
<p><strong>子查询在WHERE</strong></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">&#x2F;* 查询与141号的manager_id或department_id
相同的其他员工的employee_id、manager_id、department_id
*&#x2F;

-- 方法1：
SELECT employee_id, manager_id, department_id
FROM employees
WHERE employee_id !&#x3D; 141
AND manager_id &#x3D; (
    SELECT manager_id
    FROM employees
    WHERE employee_id &#x3D; 141
)
AND department_id &#x3D; (
    SELECT department_id
    FROM employees
    WHERE employee_id &#x3D; 141
);

-- 方法2:成对比较
SELECT employee_id, manager_id, department_id
FROM employees
WHERE employee_id !&#x3D; 141
AND (manager_id, department_id) &#x3D; (
    SELECT manager_id, department_id
    FROM employees
    WHERE employee_id &#x3D; 141
);</code></pre>

<hr>
<p><strong>子查询在HAVING</strong></p>
<p>子查询能作为HAVING里面的一个条件，这是当然的</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 查询最低工资大于50号部门最低工资的部门ID和该部门最低工资

SELECT department_id, MIN(salary)
FROM employees
GROUP BY department_id
HAVING MIN(salary) &gt; (
    SELECT MIN(salary)
    FROM departments 
    WHERE department_id &#x3D; 50
);</code></pre>

<hr>
<p><strong>子查询在CASE</strong></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">&#x2F;* 查询员工的employee_id, last_name和location（自定义字段）
 其中，若员工department_id与location_id为1800的department_id相同
则location为‘Canada’，其余为‘USA’
*&#x2F;

SELECT employee_id, last_name, 
    CASE e.department_id
     WHEN (
        SELECT d.department_id
        FROM departments d
        WHERE d.location_id &#x3D; 1800
    ) THEN &#39;Canada&#39;
    ELSE &#39;USA&#39;
    END AS &quot;location&quot;
FROM employees;</code></pre>

<hr>
<p><strong>子查询可能的问题</strong></p>
<ol>
<li>空值：查出来一条记录都没有，则需要检查子查询的查询结果是否为空</li>
<li>非法单行子查询：使用单行操作符操作有多行结果的子查询</li>
</ol>
<h2 id="MySQL子查询——多行子查询"><a href="#MySQL子查询——多行子查询" class="headerlink" title="MySQL子查询——多行子查询"></a>MySQL子查询——多行子查询</h2><p><span class="red bold">多行子查询：</span>指子查询的结果为多行数据</p>
<hr>
<p><strong>多行子查询在WHERE&#x2F;HAVING</strong></p>
<table>
<thead>
<tr>
<th align="center">多行操作符</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">IN</td>
<td align="center">等于查询结果中的任意一个</td>
</tr>
<tr>
<td align="center">ANY</td>
<td align="center">需要和单行比较符一起使用<br /><span class="red">和子查询返回的所有值比较<br />有一个为真则返回该数据</span></td>
</tr>
<tr>
<td align="center">SOME</td>
<td align="center">与ANY作用相同</td>
</tr>
<tr>
<td align="center">ALL</td>
<td align="center">需要和单行比较符一起使用<br /><span class="red">和子查询返回的所有值比较<br />都为真则返回该数据</span></td>
</tr>
</tbody></table>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">&#x2F;* 返回其他job_id中比job_id为‘IT_PROG’的部门中任一员工工资低的
员工的员工号、姓名、job_id和salary *&#x2F;

SELECT employee_id, last_name, job_id, salary
FROM employees
WHERE job_id !&#x3D; &#39;IT_PROG&#39;
AND salary &lt; ANY (
    SELECT salary
    FROM employees
    WHERE job_id &#x3D; &#39;IT_PROG&#39;
);

&#x2F;* 返回其他job_id中比job_id为‘IT_PROG’的部门中所有员工工资低的
员工的员工号、姓名、job_id和salary *&#x2F;
SELECT employee_id, last_name, job_id, salary
FROM employees
WHERE job_id !&#x3D; &#39;IT_PROG&#39;
AND salary &lt; ALL (
    SELECT salary
    FROM employees
    WHERE job_id &#x3D; &#39;IT_PROG&#39;
);</code></pre>

<hr>
<p><strong>多行子查询在FROM</strong></p>
<p>多行子查询的结果可以看做一张单独的表，这样可以间接实现聚合函数的嵌套</p>
<p><span class="red bold">注意：</span>当子查询被看做一张表时，它需要有一个别名</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 查询平均工资最低部门ID

-- 方法0（使用排序）
-- 方法0独有缺点：若最低平均工资的部门有多个则会漏掉
SELECT department_id, AVG(salary)
FROM employees
GROUP BY department_id
ORDER BY AVG(salary)
LIMIT 1;

-- 方法1（使用子查询）
SELECT department_id
FROM employees
GROUP BY department_id
HAVING AVG(salary) &#x3D; (
    SELECT MIN(avg_sal)
    FROM (
        SELECT AVG(salary) &quot;avg_sal&quot;
        FROM employees
        GROUP BY department_id 
    ) t_avg_sal
)

-- 方法2（使用子查询 + 多行操作符）
SELECT department_id, AVG(salary)
FROM employees
GROUP BY department_id
HAVING AVG(salary) &lt;&#x3D; ALL (
    SELECT AVG(salary)
    FROM employees
    GROUP BY department_id
)

-- 方法3（使用子查询+排序）
SELECT department_id, AVG(salary)
FROM employees
GROUP BY department_id
HAVING AVG(salary) &#x3D; (
    SELECT AVG(salary) &quot;avg_sal&quot;
    FROM employees
    GROUP BY department_id
    ORDER BY avg_sal
    LIMIT 0, 1
);

-- 方法4（子查询在FROM）
SELECT d.department_id
FROM (
    SELECT department_id, AVG(salary) &quot;avg_sal&quot;
    FROM employees
    GROUP BY department_id
    ORDER BY avg_sal ASC
    LIMIT 1
) t_avg_sal 
JOIN departments d USING (department_id)
WHERE d.salary &#x3D; t_avg_sal.avg_sal;</code></pre>

<hr>
<p><strong>子查询在SELECT</strong></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 查询平均工资最低的部门信息 和 其平均工资
-- 选择上面任意一个方法，将SELECT增加一个字段即可

SELECT d.department_id, d.department_name, (
    SELECT AVG(salary) FROM employees
    -- 这里的d.department_id是可以取到最终结果的，因为SELECT是最后执行的，查询结果的department_id将被应用在这里
    WHERE department_id &#x3D; d.department_id
)
FROM (
    SELECT department_id, AVG(salary) &quot;avg_sal&quot;
    FROM employees
    GROUP BY department_id
    ORDER BY avg_sal ASC
    LIMIT 1
) t_avg_sal 
JOIN departments d USING (department_id)
WHERE d.salary &#x3D; t_avg_sal.avg_sal;</code></pre>

<hr>
<p><strong>多行子查询的空值问题</strong></p>
<p>若多行子查询的结果中出现了NULL值，则主查询与子查询运算的结果将可能为空，<span class="red">注意在子查询中排除掉NULL值</span></p>
<h2 id="相关子查询——基本"><a href="#相关子查询——基本" class="headerlink" title="相关子查询——基本"></a>相关子查询——基本</h2><p><span class="red bold">相关子查询：</span>指的是子查询的结果会随主查询给的值变化，主查询每提交一个值，子查询都要重新查一遍</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 查询工资大于本部门平均工资的员工信息

-- 方法1（在WHERE中相关子查询）
SELECT last_name, salary, department_id
FROM employees e1
WHERE salary &gt; (
    SELECT AVG(salary)
    FROM employees e2
    WHERE e2.department_id &#x3D; e1.department_id
);

-- 方法2（在FROM中多表连接子查询）（效率高）
SELECT last_name, salary, department_id
FROM employees e
JOIN (
    SELECT AVG(salary) &quot;avg_salary&quot;, department_id
    FROM employees
) t_avg_sal
ON t_avg_sal.department_id &#x3D; e.department_id AND e.salary &gt; t_avg_sal.salary;</code></pre>

<p><span class="red bold">相关子查询为什么不需要分组：</span>因为SQL的执行顺序，在计算 <code>AVG(salary)</code> 之前我们已经把不满足 <code>e2.department_id = e1.department_id</code> 的行都去除了</p>
<blockquote>
<p>也就是说当传入的行的department_id为10，则因为过滤条件，在e2表中，我们只提取出了department_id为10的行，然后再计算他们的平均值</p>
</blockquote>
<hr>
<p><strong>子查询在ORDER BY</strong></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 查询员工的id, salary，按照department_name排序

-- 方法1（ORDER BY相关子查询）
SELECT e.employee_id, e.salary, e.department_id
FROM employees e
ORDER BY (
    SELECT department_name
    FROM departments d
    WHERE e.department_id &#x3D; d.department_id
) ASC;

-- 方法2（表连接）（效率高）
SELECT e.employee_id, e.salary, e.department_id, t_department_id_name.department_name
FROM employees e
JOIN (
    SELECT department_id, department_name
    FROM departments
    -- GROUP BY department_id
) t_department_id_name ON e.department_id &#x3D; t_department_id_name.department_id
ORDER BY department_name ASC;</code></pre>

<hr>
<p><strong>子查询可以写在哪里？</strong></p>
<p>在SQL结构中，除了 <code>GROUP BY</code> 和 <code>LIMIT</code> 之外的地方都可以写子查询（是的SELECT都可以）</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">&#x2F;* 若employee表中emokoyee_id与job_history表中employee_id相同的数目不小于2
输出这些相同id的员工的employee_id, last_name和其job_id*&#x2F;

-- 方法1（表连接）
SELECT e.employee_id, e.last_name, e.job_id
FROM employees e
JOIN job_history USING (employee_id)
GROUP BY employee_id
HAVING COUNT(*) &gt;&#x3D; 2;

-- 方法2（子查询）
SELECT e.employee_id, e.last_name, e.job_id
FROM employees e
WHERE (
    SELECT COUNT(*)
    FROM job_history j
    WHERE e.employee_id &#x3D; j.employee_id
) &gt;&#x3D; 2;</code></pre>

<h2 id="相关子查询——-NOT-EXISTS"><a href="#相关子查询——-NOT-EXISTS" class="headerlink" title="相关子查询——(NOT) EXISTS"></a>相关子查询——(NOT) EXISTS</h2><p><span class="red bold">注意：</span>大部分使用到 <code>IN</code> 的地方都可以改写为 <code>EXISTS</code>, <code>NOT IN</code> 可以改为 <code>NOT EXISTS</code></p>
<hr>
<p><strong>EXISTS</strong></p>
<p><span class="red bold">EXISTS：</span>当外查询传入的数据在相关子查询内满足条件而导致相关子查询能查出数据时，<span class="red">返回true（相关子查询的结果将被忽略）</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">WHERE EXISTS (相关子查询)</code></pre>

<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 查询公司管理者的employee_id, last_name, job_id, department_id信息

-- 方法1（自连接）
SELECT DISTINCT mgr.employee_id, mgr.last_name, mgr.job_id, mgr.department_id
FROM employees emp
JOIN employees mgr ON emp.manager_id &#x3D; mgr.employee_id;

-- 方法2（多行子查询）
SELECT employee_id, last_name, job_id, department_id
FROM employees
WHERE employee_id IN (
    SELECT DISTINCT manager_id
    FROM employees
    WHERE manager_id IS NOT NULL
);

-- 方法3（EXISTS相关子查询）
SELECT DISTINCT employee_id, last_name, job_id, department_id
FROM employees e1
WHERE EXISTS (
    -- 当e1的员工id等于e2的管理者id表明此时e1传进的员工是管理者
    SELECT *
    FROM employees e2
    WHERE e1.employee_id &#x3D; e2.manager_id
)</code></pre>

<hr>
<p><strong>NOT EXISTS</strong></p>
<p><span class="red bold">NOT EXISTS：</span>就是上面 <code>EXISTS</code> 的相反，外查询传入的数据不满足子查询的条件时返回该行数据</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">&#x2F;* 查询departments表中，不存在于employees表中的部门的department_id和department_name
*&#x2F;

-- 方法1（外连接）
SELECT d.department_id, d.department_name
FROM departments d
LEFT JOIN employees e USING (department_id)
&#x2F;* 虽然他们用department_id连接，但是两个表的department_id还是分开的
选出e表中的NULL行即为空部门
因此让e表中任一字段为空即可*&#x2F;
WHERE e.department_id IS NULL;

-- 方法2（NOT EXISTS相关子查询）
SELECT d.department_id, d.department_name
FROM departments d
WHERE NOT EXISTS (
    SELECT *
    FROM employees e
    WHERE d.department_id &#x3D; e.department_id
);

-- 注意这里相关子查询行不通，因为IS NULL是单行操作符，当子查询查出多行结果时，会报错</code></pre>

<h2 id="数据库的创建和管理"><a href="#数据库的创建和管理" class="headerlink" title="数据库的创建和管理"></a>数据库的创建和管理</h2><hr>
<p><strong>数据库的创建</strong></p>
<p><span class="red bold">使用默认字符集创建：</span><br>在创建数据库时不指定字符集，则使用该版本MySQL的默认字符集</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CREATE DATABASE 数据库名;</code></pre>

<p><span class="red bold">指定字符集创建：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CREATE DATABASE 数据库名 CHARACTER SET &#39;字符集名&#39;;

CREATE DATABASE 数据库名 CHARSET &#39;字符集名&#39;;</code></pre>

<p><span class="red bold">若不存在则创建（推荐）：</span><br>若要创的数据库与现有数据库重名，无论它们的字符集相同与否，新的数据库都不会创建成功</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CREATE DATABASE IF NOT EXISTS 数据库名;</code></pre>

<hr>
<p><strong>数据库的管理</strong></p>
<p><span class="red bold">查看当前可连接的数据库：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SHOW DATABASES;</code></pre>

<p><span class="red bold">切换数据库：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">USE 数据库名;</code></pre>

<p><span class="red bold">查看当前连接中（使用中）的数据库：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT DATABASE() [FROM DUAL];</code></pre>

<p><span class="red bold">查看当前连接中的数据库中的表：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SHOW TABLES;</code></pre>

<p><span class="red bold">查看指定数据库中的表：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SHOW TABLES FROM 表名;</code></pre>

<hr>
<p><strong>数据库的修改</strong></p>
<p><span class="red bold">更改指定数据库的字符集：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">ALTER DATABASE 数据库名 CHARACTER SET &#39;字符集名&#39;;

ALTER DATABASE 数据库名 CHARSET &#39;字符集名&#39;;</code></pre>

<p><span class="red bold">数据库改名？：</span>数据库不能改名，可视化软件可以给数据库改名的原理是新建一个表然后将旧表的数据复制过去</p>
<hr>
<p><strong>数据库的跑路</strong></p>
<p><span class="red bold">直接删除指定数据库：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">DROP DATABASE 数据库名;</code></pre>

<p><span class="red bold">若存在则删除（推荐）：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">DROP DATABASE IF EXISTS 数据库名;</code></pre>

<h2 id="表的创建与管理"><a href="#表的创建与管理" class="headerlink" title="表的创建与管理"></a>表的创建与管理</h2><hr>
<p><strong>表的命名规则</strong></p>
<ul>
<li>数据库名、表名不得超过30个字符、变量名不得超过29个</li>
<li>只能包含：<code>A-Z</code> <code>a-z</code> <code>0-9</code> 和 <code>_</code></li>
<li>数据库名、表名、字段名等对象名中不能包含空格</li>
<li>在同一个MySQL软件中，数据库不得重名；</li>
<li>同一个数据库中，表不得重名</li>
<li>同一个表中、字段不得重名</li>
<li>保证用户字段与SQL保留字、常用方法没有冲突。若坚持使用存在冲突的用户字段，将该字段在SQL语句中使用 着重号 括住</li>
<li>保证字段名和类型的一致性，当一个字段名存在于多张表中时，注意其在多张表中的类型应该是一致的</li>
</ul>
<hr>
<p><strong>字段的命名规则</strong></p>
<ul>
<li>小写字母或数字，下滑线分割，禁止数字开头，禁止两个下划线之间只有数字</li>
<li>禁止使用SQL保留字</li>
<li>表必备的三个字段：<ul>
<li>id：主键，类型为BIGINT UNSIGNED，自增步长1</li>
<li>gmt_create：存放记录的创建时间</li>
<li>gmt_modified：存放记录的最新修改时间</li>
</ul>
</li>
<li>表的命名最好遵循 “业务名称_表的作用”</li>
</ul>
<hr>
<p><strong>表的创建和结构查询</strong></p>
<p><span class="red bold">创建表：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CREATE TABLE [IF NOT EXISTS] 表名(
    -- 这里定义字段
    字段名 数据类型[(长度)] [约束条件] [DEFAULT 默认值],
    字段名 数据类型[(长度)] [约束条件] [DEFAULT 默认值], 
    ...
);</code></pre>

<p><span class="red bold">基于现有的表创建新的表：</span></p>
<p>基于现有的表的指定某些字段来创建新的表，<span class="red">其实就是将查询结果搞成一张新的表，因此此操作会复制旧表的数据至新表</span></p>
<p><span class="red">注意：</span></p>
<ul>
<li>该查询语句中的别名、筛选条件、多表连接等会影响查询结果的语句，都会作用于新的表中</li>
<li>非空约束会被复制，<span class="red">主键、外键和唯一性约束会丢失</span></li>
</ul>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CREATE TABLE 表名
AS
SELECT 字段名, 字段名, ...
FROM [另一个数据库.]另一张表;</code></pre>

<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 包括表数据
CREATE TABLE employees_copy
AS
SELECT * 
FROM employees;

-- 不包括表数据
CREATE TABLE employees
AS
SELECT * 
FROM employees
WHERE FALSE;</code></pre>

<p><span class="red bold">查看表结构：</span><br>查看表的字段、类型、约束条件和默认值</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">DESC 表名;</code></pre>

<hr>
<p><strong>计算列</strong></p>
<p>类似于EXCEL中定义一格是另外两格的计算结果，MySQL也可以定义这样的“格”，严格意义上是将这一个字段的数据都定义为某种计算方式。</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CREATE TABLE [IF NOT EXISTS] 表名(
    字段名 数据类型[(长度)] [约束条件] [DEFAULT 默认值],
    字段名 数据类型[(长度)] [约束条件] [DEFAULT 默认值],
    字段名 数据类型[(长度)] GENERATED AS (计算公式) VIRTUAL
)
</code></pre>

<hr>
<p><strong>表中字段的修改（ALTER）</strong></p>
<p><span class="red bold">增加字段（ADD）：</span></p>
<p>默认在最后一列增加字段，也可以使用 <code>FIRST</code> 使其增加到最前一列，使用 <code>AFTER 字段名</code> 使其添加到指定字段后一列</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">ALTER TABLE 表名
ADD [COLUMN] 字段名 数据类型[(长度)] [FIRST|AFTER 字段名] [约束条件] [默认值];</code></pre>

<p><span class="red bold">修改一个字段的数据类型、长度和默认值（MODIFY）：</span></p>
<p>注意默认值的格式，字段是字符串就用单引号将默认值引起以传入一个字符串</p>
<p><span class="red">注意：该操作可能会使字段丢失约束信息</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">ALTER TABLE 表名
MODIFY 字段名 数据类型[(长度)] [FIRST|AFTER 字段名] [限制条件] DEFAULT 默认值;</code></pre>

<p><span class="red bold">删除字段的默认值：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">ALTER TABLE 表名
ALTER COLUMN 字段名 DROP DEFAULT;</code></pre>

<p><span class="red bold">重命名字段（CHANGE）：</span></p>
<p>使用 <code>CHANGE</code> 也可以改变字段的类型和长度</p>
<p><span class="red">注意：该操作可能会使字段丢失约束信息</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">ALTER TABLE 表名
CHANGE 字段名 新字段名 数据类型[(长度)];</code></pre>

<p><span class="red bold">删除字段（DROP COLUMN）：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">ALTER TABLE 表名
DROP COLUMN 字段名;</code></pre>

<hr>
<p><strong>表的修改</strong></p>
<p><span class="red bold">重命名表（RENAME）：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 方式1
RENAME TABLE 表名 TO 新表名;

-- 方式2
ALTER TABLE 表名
RENAME TO 新表名;</code></pre>

<p><span class="red bold">删除表（DROP TABLE）：</span></p>
<p><span class="red">注意删除表操作不能回滚</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">DROP TABLE [IF EXISTS] 表名1[, 表名2, ...];</code></pre>

<p><span class="red bold">清空表(TRUNCATE)：</span></p>
<p><span class="red">注意清空表操作不能回滚</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">TRUNCATE TABLE 表名;</code></pre>

<hr>
<p><strong>TRUNCATE TABLE与DELETE FROM</strong></p>
<p>相同：删除表数据，保留表结构<br>不同：</p>
<ol>
<li>TRUNCATE TABLE：自动提交（不受自动提交设置影响），不可回滚</li>
<li>DELETE FROM：表数据可以选择性（使用WHERE）或全部删除（不使用WHERE），可以实现回滚</li>
</ol>
<h2 id="初识事务——提交与回滚"><a href="#初识事务——提交与回滚" class="headerlink" title="初识事务——提交与回滚"></a>初识事务——提交与回滚</h2><hr>
<p><strong>提交（COMMIT）</strong></p>
<p><span class="red bold">事务提交：</span>相当于确认，提交事务会将前一次提交之后的所有对表的增删改操作永久应用到数据库中，<span class="red">意味着执行了提交，则当次提交之前的操作不可以回滚</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">COMMIT;</code></pre>

<hr>
<p><strong>回滚（ROLLBACK）</strong></p>
<p><span class="red bold">事务回滚：</span>相当于撤销，回滚事务<span class="red">会将数据回滚到上一次 <code>COMMIT</code> 之后（部分不能被回滚的操作会导致回滚失败）</span></p>
<p><img src="https://s1.ax1x.com/2022/05/27/Xemf91.png" alt="Xemf91.png"></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">ROLLBACK;</code></pre>

<hr>
<p><strong>关于DDL与DML的回滚</strong></p>
<ol>
<li>DDL（数据库定义）一旦执行不可回滚 <code>SET autocommit = false</code> 无效</li>
<li>DML（数据库操作）：若执行DML之前执行 <code>SET autocommit = false</code> （默认开启自动提交）则可以实现回滚</li>
</ol>
<hr>
<p><strong>MySQL8.0新特性DDL的原子性</strong></p>
<p>在MySQL8.0之后，数据库定义语言（DDL）具有原子性，即<span class="red">当一条DDL语句对多个数据库或多张表操作时，若有一个操作失败，则会自动回滚</span></p>
<p><span class="red bold">注意：</span>在MySQL8.0之前，DDL语句事务不会回滚</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 若表book1存在，表book2不存在
DROP TABLE book1, book2;

-- 则在MySQL5.7中book1表会被删除</code></pre>

<h2 id="数据的增删改"><a href="#数据的增删改" class="headerlink" title="数据的增删改"></a>数据的增删改</h2><hr>
<p><strong>增加数据（INSERT INTO）</strong></p>
<p><span class="red bold">指定数据添加：</span></p>
<ul>
<li>若没有在表名后指明字段， <code>VALUES</code> 里的数据顺序要与字段声明的顺序（在表中的顺序）相同</li>
</ul>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 在插入数据时可以指定字段，数据的顺序要与指定的字段顺序相同（推荐指定字段名）
INSERT INTO 表名[(字段名1, 字段名2, ...)]
VALUES (数据1, 数据2, ...), (数据1, 数据2, ...), ...;</code></pre>

<p><span class="red bold">将查询结果添加：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 注意查询结果的字段要与表名后的字段相同
INSERT INTO 表名[(字段名1, 字段名2, ...)]
SELECT 字段名1, 字段名2, ...
FROM ...
WHERE ...</code></pre>

<p><span class="red">注意！：</span>在使用查询结果增加时，注意两个表中相应字段的数据长度，若为 <code>查询小长度字段-&gt;插入大长度字段</code>，则没什么需要担心的，<span class="red">若为 <code>查询大长度字段-&gt;插入小长度字段</code> 则需要注意可能会有数据插入失败。</span></p>
<hr>
<p><strong>修改数据（UPDATE SET）</strong></p>
<ul>
<li>可以通过筛选条件实现单条或批量的数据修改</li>
</ul>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">UPDATE 表名
SET 字段名1 &#x3D; 值1[, 字段名2 &#x3D; 值2]
WHERE 筛选条件;

UPDATE emp1
SET salary &#x3D; salary * 1.2
WHERE &#96;name&#96; like &#39;%a%&#39;;</code></pre>

<hr>
<p><strong>数据删除（DELETE FROM）</strong></p>
<p><span class="red">普通删除：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">DELETE FROM 表名
WHERE 筛选条件;</code></pre>

<p><span class="red">多表删除：</span></p>
<p>当一个数据同时存在于多张表，并且有将他们全部删除的需求时，可以使用多表连接进行删除：</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">DELETE m,U
FROM my_employees m 
JOIN users u USING (userid)
WHERE m.userid &#x3D; &#39;Bbiri&#39;;</code></pre>

<p><span class="red">注意：</span>数据的增加、修改和删除都有可能由于约束导致操作失败。</p>
<h2 id="MySQL数据类型"><a href="#MySQL数据类型" class="headerlink" title="MySQL数据类型"></a>MySQL数据类型</h2><hr>
<p><strong>整数类型（INT）</strong></p>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">字节</th>
<th align="center">有符号取值范围</th>
<th align="center">无符号取值范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">TINYINT</td>
<td align="center">1</td>
<td align="center">-(2^8)&#x2F;2 ~ (2^8)&#x2F;2 - 1</td>
<td align="center">0~255</td>
</tr>
<tr>
<td align="center">SMALLINT</td>
<td align="center">2</td>
<td align="center">-(2^16)&#x2F;2 ~ (2^16)&#x2F;2 - 1</td>
<td align="center">0~65535</td>
</tr>
<tr>
<td align="center">MEDIUMINT</td>
<td align="center">3</td>
<td align="center">-(2^24)&#x2F;2 ~ (2^24)&#x2F;2 - 1</td>
<td align="center">0~(2^24) - 1</td>
</tr>
<tr>
<td align="center">INT&#x2F;INTEGER</td>
<td align="center">4</td>
<td align="center">-(2^32)&#x2F;2 ~ (2^32)&#x2F;2 - 1</td>
<td align="center">0~(2^32) - 1</td>
</tr>
<tr>
<td align="center">BIGINT</td>
<td align="center">5</td>
<td align="center">-(2^64)&#x2F;2 ~ (2^64)&#x2F;2 - 1</td>
<td align="center">0~(2^64) - 1</td>
</tr>
</tbody></table>
<p><span class="red bold">整数类型的显式位数限制和补零（ZEROFILL）：</span></p>
<p><span class="red">注意：</span>该功能在MySQL8.0之后不建议使用</p>
<ul>
<li>整数类型也可以像浮点型一样做显式的位数限制，但其实并没有什么卵用，<span class="red">做这个显式的位数限制并不会使超过此位数但不超过数据类型取值范围的数不能输入到数据库中</span></li>
<li>显式位数限制需要配合补零使用才有效果：</li>
</ul>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CREATE TABLE test (
    id INT(3) ZEROFILL;
);

-- INSERT INTO test VALUES(15)
-- --&gt; 显示015
-- INSERT INTO test VALUES(1592)
-- --&gt; 显示1592（即使超过显式定义的限制还是可以插入该数据）</code></pre>

<p><span class="red">注意：</span>将一个字段声明为补零，则默认声明该字段为无符号数</p>
<hr>
<p><strong>浮点类型（FLOAT DOUBLE REAL）</strong></p>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">字节</th>
</tr>
</thead>
<tbody><tr>
<td align="center">FLOAT</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">DOUBLE</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">REAL</td>
<td align="center">?</td>
</tr>
</tbody></table>
<ul>
<li>REAL默认与DOUBLE相同，也可以通过设置将其默认与FLOAT相同</li>
</ul>
<p><span class="red">注意：</span>浮点类型的无符号取值范围就是有符号取值范围去掉负数部分，因此声明一个浮点类型是无符号的并不会增加无符号浮点数的取值范围，也不会减少其占用空间。</p>
<p><span class="red bold">浮点数精度设定：</span></p>
<ul>
<li><p>浮点数的精度设定不像整数位数限制那么鸡肋，它是确实能够起到限制插入数据的格式的作用的</p>
  <pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">   -- 限制字段为总共五位，其中小数位两位的双精浮点数
   CREATE TABLE test (
price DOUBLE(5, 2)
   );

   INSERT INTO test VALUES(23.55);
   -- --&gt;显示23.55

   INSERT INTO test VALUES(23.558);
   -- --&gt;显示23.56（四舍五入）

   INSERT INTO test VALUES(23.554);
   -- --&gt;显示23.55（四舍五入）

   INSERT INTO test VALUES(999.998);
   -- --&gt;报错（四舍五入后超出范围）

   INSERT INTO test VALUES(114514.00);
   -- --&gt;报错</code></pre></li>
</ul>
<p><span class="red">注意2：</span>其他数据库未必支持浮点数的精度设定，因此和整数类型一样，不建议使用这样的语法</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- FLOAT(M, D)
-- DOUBLE(M, D)
-- 精度（M）：表示小数位+整数位个数
-- 标度（D）：表示小数位个数

CREATE TABLE test (
    price DOUBLE()
);</code></pre>

<hr>
<p><strong>定点数类型（DECIMAL）</strong></p>
<p>为解决浮点数在计算时精度丢失的问题……（这句话Java说过了）</p>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">字节数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">DECIMAL(M, D)&#x2F;DEC&#x2F;NUMERIC</td>
<td align="center">M+2</td>
</tr>
</tbody></table>
<ul>
<li><p>不指定精度和标度默认为<code>DECIMAL(10, 0)</code></p>
</li>
<li><p>精度（M）：表示小数位+整数位个数</p>
</li>
<li><p>标度（D）：表示小数位个数</p>
</li>
<li><p>同样会有四舍五入的情况</p>
</li>
</ul>
<hr>
<p><strong>位类型（BIT）</strong></p>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">字节数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">BIT(M)</td>
<td align="center">约为(M+7)&#x2F;8</td>
</tr>
</tbody></table>
<ul>
<li><p>M：M为几就可以存储几位，不写默认一位</p>
</li>
<li><p>在控制台中查询位类型字段出来的默认显示的是十六进制，在MySQL中默认为二进制，如果需要将结果进行进制转换，可以这样做：</p>
</li>
</ul>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 转换为16进制
SELECT HEX(b2) FROM bit_test;

-- 转换为10进制
SELECT b2 + 0 FROM bit_test;

-- 转换为8进制
SELECT OCT(b2) FROM bit_test;

-- 转换为2进制
SELECT BIN(B2) FROM bit_test;</code></pre>

<hr>
<p><strong>日期与事件类型</strong></p>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">字节</th>
<th align="center">日期格式</th>
<th align="center">最小值</th>
<th align="center">最大值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">YEAR</td>
<td align="center">1</td>
<td align="center">YYYY或YY</td>
<td align="center">1901</td>
<td align="center">2155</td>
</tr>
<tr>
<td align="center">TIME</td>
<td align="center">3</td>
<td align="center">HH:MM:SS</td>
<td align="center">-838:59:59</td>
<td align="center">838:59:59</td>
</tr>
<tr>
<td align="center">DATE</td>
<td align="center">3</td>
<td align="center">YYYY-MM-DD</td>
<td align="center">1000-01-01</td>
<td align="center">9999-12-03</td>
</tr>
<tr>
<td align="center">DATETIME</td>
<td align="center">8</td>
<td align="center">YYYY-MM-DD HH:MM:SS</td>
<td align="center">1000-01-01 00:00:00</td>
<td align="center">9999-12-31 23:59:59</td>
</tr>
<tr>
<td align="center">TIMESTAMP</td>
<td align="center">4</td>
<td align="center">YYYY-MM-DD HH:MM:SS</td>
<td align="center">1970-01-01 00:00:00 UTC</td>
<td align="center">1038-01-19 03:14:07 UTC</td>
</tr>
</tbody></table>
<p><span class="red bold">关于两位YEAR：</span></p>
<p><span class="red">两位YEAR在MySQL5.5开始不建议使用</span></p>
<p>两位YEAR存储取值范围为00~99，并且遵循以下规则：</p>
<ul>
<li>当取值为01<del>69时，表示2001</del>2069年</li>
<li>当取值为70<del>99时，表示1970</del>1999年</li>
<li>当取值为数值0或00时，表示0000年</li>
<li>当取值为字符串’0’时，表示2000年</li>
</ul>
<p><span class="red bold">关于DATETIME与TIMESTAMP：</span></p>
<ul>
<li><code>TIMESTAMP</code>存储空间小，表示的日期时间范围小</li>
<li>两个日期比较大小或日期计算时，<code>TIMESTAMP</code> 更快</li>
<li><span class="red"><code>TIMESTAMP</code> 和时区有关</span>，其会根据用户时区不同显示不同的结果。而 <code>DATATIME</code> 只能反映出数据插入时当地的时区，其他时区查询到的结果会有误差</li>
</ul>
<hr>
<p><strong>字符串类型</strong></p>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">CHAR(M)</td>
</tr>
<tr>
<td align="center">VARCHAR(M)</td>
</tr>
<tr>
<td align="center">TINYTEXT</td>
</tr>
<tr>
<td align="center">TEXT</td>
</tr>
<tr>
<td align="center">MEDIUMTEXT</td>
</tr>
<tr>
<td align="center">LONGTEXT</td>
</tr>
<tr>
<td align="center">ENUM</td>
</tr>
<tr>
<td align="center">SET</td>
</tr>
</tbody></table>
<p><span class="red bold">CHAR:</span></p>
<ul>
<li><code>CAHR</code> 类型一般需要指定字符串的长度，若不指定则默认长度为1</li>
<li>若插入的数据长度比指定的长度要小，则会在右侧填充空格，但当MySQL检索该字段时，会把数据右侧的空格去掉，不管是它自己填充的还是插入数据时写的</li>
</ul>
<p><span class="red bold">VARCAHR:</span></p>
<ul>
<li><code>VARCAHR</code> 类型字段在声明时<span class="red">必须要指定长度</span></li>
<li>在MySQL4.0版本以下时，指定的长度是字节数，当存储汉字时，需要考虑每个汉字需要占用3个字节。<br />在MySQL5.0版本以上时，指定的长度是字符数，不需要考虑中文占用多个字节的情况</li>
<li>当然也因此，在声明长度时，最大允许声明长度不是65535，而是65535&#x2F;3&#x3D;21845</li>
</ul>
<p><span class="red bold">CHAR与VARCHAR相比：</span></p>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">特点</th>
<th align="center">空间</th>
<th align="center">时间</th>
</tr>
</thead>
<tbody><tr>
<td align="center">CHAR</td>
<td align="center">定长</td>
<td align="center">易浪费</td>
<td align="center">效率高</td>
</tr>
<tr>
<td align="center">VARCHAR</td>
<td align="center">变长</td>
<td align="center">节省</td>
<td align="center">效率低</td>
</tr>
</tbody></table>
<p>从数据使用方面：</p>
<ul>
<li>当在存储很短的信息时，建议 <code>CHAR</code></li>
<li>当存储固定长度的信息时，建议 <code>CHAR</code></li>
<li>当该字段需要频繁改变时，建议 <code>CHAR</code></li>
</ul>
<p>从存储引擎方面：</p>
<ul>
<li>MySQL使用InnoDB存储引擎，其内部存储格式被没有区分定长与变长，其主要的性能影响因素是存储总量，<span class="red">因此推荐使用 <code>VARCHAR</code></span>，因为它家省空间。</li>
</ul>
<p><span class="red bold">各种TEXT：</span></p>
<ul>
<li>MySQL不允许各种TEXT类型做主键，因为TEXT类型的长度是不确定的</li>
<li>TEXT可以存储很长的文本段，运行速度慢，因此若不是他别长的内容还是建议使用 <code>CHAR</code> 和 <code>VARCHAR</code></li>
<li>TEXT与BLOB类型在数据删除后会出现很大的数据空洞，使文件碎片多，建议将其单独作为一个表（详见 BLOB -&gt; TEXT与BLOB使用注意事项）</li>
<li><span class="red">TEXT不能定义默认值</span></li>
</ul>
<p><span class="red bold">ENUM:</span></p>
<p>定义枚举字段可以使该字段的值只在枚举的值和NULL（若没有指定非空）里面选择</p>
<p><span class="red">注意：</span>在插入数据时，除了直接输入枚举的值，还可以使用枚举值的索引（或称下标）的数值或字符形式</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CREATE TABLE enum_test(
    season(&#39;春&#39;, &#39;夏&#39;, &#39;秋&#39;, &#39;冬&#39;)
);

-- 使用索引（下标）
INSERT INTO enum_test VALUES(1, &#39;3&#39;);</code></pre>

<p><span class="red bold">SET:</span></p>
<p>上面 <code>ENUM</code> 只能选一个作为数据的值，<code>SET</code> 可以选择0个（NULL）或多个作为数据的值</p>
<p><span class="red">注意：</span>SET不允许重复</p>
<hr>
<p><strong>二进制字符串&#x2F;对象类型</strong></p>
<p><code>BINARY</code> 与 <code>VARBINARY</code> 类似于 <code>CHAR</code> 和 <code>VARCHAR</code>，只是他们存储的是二进制字符串</p>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">BINARY(M)</td>
<td align="center">定长</td>
</tr>
<tr>
<td align="center">VARBINARY(M)</td>
<td align="center">变长</td>
</tr>
</tbody></table>
<p><span class="red bold">BINARY：</span>存储的是固定长度的二进制字符串，M表示最多能存储的字节数，若未指定则默认为1，若数据小于指定的字节，则在右边填充’\0’补齐</p>
<p><span class="red bold">VARBINARY：</span>对于可变长二进制字符串，则必须指定最大长度M</p>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">TINYBLOB</td>
</tr>
<tr>
<td align="center">BLOB</td>
</tr>
<tr>
<td align="center">MEDIUMBLOB</td>
</tr>
<tr>
<td align="center">LONGBLOB</td>
</tr>
</tbody></table>
<p><span class="red bold">各种BLOB：</span><code>BLOB</code> 适用于存储二进制对象的，如图片、音视频等，但实际上数据库并不会用于存储二进制对象，而是存储二进制对象的访问途径</p>
<p><span class="red bold">TEXT与BLOB使用注意事项：</span></p>
<ul>
<li><code>TEXT</code> 和 <code>BLOB</code> 在尽进行大量数据删除或更新操作时，容易在数据表中留下空洞，以后填入这些空洞的记录长度也可能不同。为了提高性能，建议使用 <code>OPTIMIZE TABLE</code> 功能对表进行碎片整理。</li>
<li>若需要对大文本字段进行模糊查询，MySQL提供了前缀索引，但依然要避免对 <code>TEXT</code> 和 <code>BLOB</code> 进行检索</li>
<li>将 <code>TEXT</code> 和 <code>BLOB</code> 分离到单独的表中，在某些环境下这样做可以让你把原数据表中数据列转换为固定长度的数据行，这会减少主表中的碎片，使你得到固定长度数据行的优势</li>
</ul>
<hr>
<p><strong>JSON类型</strong></p>
<p>JSON是一种轻量级的数据交换格式，JSON可以将Javascript对象中表示的一组数据转换为字符串，然后在网络和程序之间传递这个字符串，并在需要时将字符串还原为各编程语言所支持的格式</p>
<p><span class="red bold">写入：</span></p>
<p>在写入JSON数据时，其格式类似于在网页控制台中输出对象的格式：</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">INSERT INTO test
VALUES(&#39;&#123;&quot;name&quot;:&quot;lihua&quot;, &quot;age&quot;:18, &quot;address&quot;:&#123;&quot;city&quot;:&quot;beijing&quot;, &quot;province&quot;:&quot;beijing&quot;&#125;&#125;&#39;)</code></pre>

<p>上面代码的结构类似于：</p>
<p><img src="https://s1.ax1x.com/2022/06/07/XD9Wlt.png" alt="XD9Wlt.png"></p>
<p><span class="red bold">提取：</span></p>
<p>可以使用以下格式提取JSON数据中的数据：</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT 字段名 -&gt; &#39;$.数据名&#39; [AS 别名]
FROM 表名;</code></pre>

<p>以下是例子：</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CREATE TABLE json_test(
	js JSON
);

INSERT INTO json_test VALUES
(&#39;&#123;&quot;name&quot;:&quot;lihua&quot;, &quot;age&quot;:18, &quot;address&quot;:&#123;&quot;city&quot;:&quot;beijing&quot;, &quot;province&quot;:&quot;beijing&quot;&#125;&#125;&#39;);

SELECT js -&gt; &#39;$.name&#39;, js -&gt; &#39;$.age&#39;
FROM json_test;</code></pre>

<p>结果：</p>
<table>
<thead>
<tr>
<th align="center">js -&gt; ‘$.name’</th>
<th align="center">js -&gt; ‘$.age’</th>
</tr>
</thead>
<tbody><tr>
<td align="center">“lihua”</td>
<td align="center">18</td>
</tr>
</tbody></table>
<hr>
<p><strong>数据类型规范</strong></p>
<ul>
<li>任何字段若为非负数，必须指定为UNSIGNED</li>
<li>小数类型使用DECIMAL</li>
<li>若字符串长度几乎相等，使用CHAR</li>
<li>VARCHAR中数据的长度不应该超过5000，若超过，使用TEXT并且另开一张表，使用主键进行对应</li>
</ul>
<h2 id="MySQL约束（CONSTRAINT）"><a href="#MySQL约束（CONSTRAINT）" class="headerlink" title="MySQL约束（CONSTRAINT）"></a>MySQL约束（CONSTRAINT）</h2><p>为了保证数据的完整性，SQL规范以约束的方式对表数据进行额外的条件限制，从以下四个方面考虑：</p>
<ol>
<li>实体完整性：同一个表中不能存在两条完全相同无法区分的记录</li>
<li>域完整性：数据只能是指定的类型或枚举限定的值，不能出现无效的值</li>
<li>引用完整性：外键的值必须能在另一个对应的表中找到</li>
<li>用户自定义完整性：如用户名唯一，密码非空或其他规则</li>
</ol>
<p>约束的使用场景：</p>
<ol>
<li>创建表时 <code>CREATE TABLE</code></li>
<li>修改表时 <code>ALTER TABLE</code></li>
</ol>
<p><span class="red bold">查看表中的约束：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT * FROM information_schema.TABLE_CONSTRAINTS
WHERE TABLE_NAME &#x3D; &#39;表名&#39;;

SHOW INDEX FROM 表名 [FROM 数据库名];</code></pre>

<hr>
<p><strong>非空约束（NOT NULL）</strong></p>
<p>在创建表，声明字段时，可以在数据类型后加上 <code>NOT NULL</code> 限制该字段的数据不能为空</p>
<p><span class="red">注意:</span></p>
<ul>
<li>若不设置，则默认所有类型的值都可以为空</li>
<li>非空约束只能对某个字段单独限定非空（只能对列约束），不能组合非空（不能对表约束）</li>
<li>一个表中可以有很多列分别设置为非空</li>
</ul>
<p><span class="red bold">定义约束：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CREATE TABLE 表名(
    字段名 数据类型 NOT NULL
);</code></pre>

<p><span class="red bold">修改约束：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">ALTER TABLE 表名
MODIFY 字段名 数据类型 NOT NULL;</code></pre>

<p><span class="red">注意：</span>当该字段下有空数据时，不能修改该字段为非空</p>
<p><span class="red bold">删除约束：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">ALTER TABLE 表名
MODIFY 字段名 数据类型 NULL;</code></pre>

<hr>
<p><strong>唯一性约束（UNIQUE）</strong></p>
<p>唯一性约束可以是列约束，也可以是表约束</p>
<p><span class="red">注意：</span></p>
<ul>
<li>同一张表可以有多个唯一性约束</li>
<li>可以是列约束和组合约束（表约束）</li>
<li><span class="red">唯一性约束默认允许列的值为空，并且多个NULL不视为重复</span></li>
<li>在创建唯一约束的时候，若不给唯一约束命名，则默认与字段名相同</li>
<li><span class="red">MySQL会给有唯一性约束的字段创建一个唯一索引</span></li>
</ul>
<p><span class="red bold">复合约束：</span>指将多个字段捆绑并定义唯一性，仅当这多个字段的数据同时相同时，才会增加失败，<span class="red">复合约束只能定义在表约束中</span></p>
<p><span class="red bold">定义约束：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 列约束
CREATE TABLE 表名(
    字段名 数据类型 UNIQUE
);

-- 表约束
CREATE TABLE 表名(
    字段名 数据类型,
    [CONSTRAINT 约束名] UNIQUE(字段名)
);</code></pre>

<p><span class="red bold">修改约束：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 列约束
ALTER TABLE 表名
MODIFY 字段名 数据类型 UNIQUE;

-- 表约束
ALTER TABLE 表名
ADD [CONSTRAINT 约束名] UNIQUE(字段名[, 字段名, ...]);</code></pre>

<p><span class="red">注意：</span><br>当该字段下有相同数据时，不能修改该字段为唯一</p>
<p><span class="red bold">删除约束：</span></p>
<p>说明：</p>
<ul>
<li>增加唯一性约束的列上会自动创建唯一索引</li>
<li>删除唯一性约束只能通过删除唯一索引实现</li>
<li>删除时需要指定唯一索引的名称，唯一索引名和唯一约束名相同</li>
<li>若未指定唯一约束名，若是单列约束，则默认和列名相同<br />若是复合约束，则默认与第一列的名称相同</li>
</ul>
<p><span class="red bold">删除索引：</span></p>
<p>回顾：如何查看索引：</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT * FROM information_schema.TABLE_CONSTRAINTS
WHERE TABLE_NAME &#x3D; &#39;表名&#39;;

SHOW INDEX FROM 表名 [FROM 数据库名];</code></pre>

<p>使用以下代码删除索引：</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">ALTER TABLE 表名
DROP INDEX 索引名;</code></pre>

<hr>
<p><strong>主键约束（PRIMARY KEY）</strong></p>
<p>主键用于唯一标识表中的一行记录，主键是唯一约束和非空约束的组合，<span class="red">主键不允许重复和空值</span></p>
<p><span class="red">注意：</span></p>
<ul>
<li>一个表中只能有一个主键约束，主键可以声明为列约束，也可以声明为表约束</li>
<li>主键约束可以对应一张表中的一列或多列（复合主键）</li>
<li>若声明了复合主键，则这些列<span class="red">都不允许空值</span>，且它们的值<span class="red">不允许同时重复</span></li>
<li><span class="red">MySQL主键名总是PRIMARY</span></li>
<li>当创建主键约束时，会在所在的列或组合列上建立对应的主键索引（<span class="red">因此可以使用主键查询的，尽量使用主键查询，效率更高</span>）</li>
<li>不要修改主键字段的值</li>
</ul>
<p><span class="red bold">定义约束：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 列约束
CREATE TABLE 表名(
    字段名 数据类型 PRIMARY KEY
);

-- 表约束
CREATE TABLE 表名(
    字段名 数据类型,
    PRIMARY KEY(字段名[, 字段名, ...])
);</code></pre>

<p><span class="red bold">修改约束：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 列约束
ALTER TABLE 表名
MODIFY 字段名 数据类型 PRIMARY KEY;

-- 表约束
ALTER TABLE 表名
ADD PRIMARY KEY(字段名);</code></pre>

<p><span class="red bold">删除约束：</span></p>
<p><span class="red">注意：该操作危险！！！</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">ALTER TABLE 表名
DROP PRIMARY KEY;</code></pre>

<hr>
<p><strong>自增列（AUTO_INCREMENT）</strong></p>
<p>使某个字段的值自动增长</p>
<p><span class="red">注意：</span></p>
<ul>
<li>一个表最多只能有一个自增列</li>
<li>当需要产生唯一标识符或顺序值时，可以设置自增长</li>
<li>自增长约束的列必须是键列（主键&#x2F;唯一键）</li>
<li>自增字段的数据类型必须为整型</li>
<li>若自增列在插入数据时指定了0和NULL，则会在当前最大值基础上自增<br />若设置了具体值则直接使用该值</li>
<li>在开发中，一旦字段上声明了自增，就不要再给该字段赋值</li>
</ul>
<p><span class="red bold">定义约束：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CREATE TABLE 表名(
    字段名 数据类型 [UNIQUE&#x2F;PRIMARY KEY] AUTO_INCREMENT
);</code></pre>

<p><span class="red bold">修改约束：</span></p>
<p>一般不会这么做</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">ALTER TABLE 表名
MODIFY 字段名 数据类型 AUTO_INCREMENT;</code></pre>

<p><span class="red bold">修改自增值：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">ALTER TABLE 表名
AUTO_INCREMENT &#x3D; 值;</code></pre>

<p><span class="red bold">删除约束：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">ALTER TABLE 表名
MODIFY 字段名 数据类型;</code></pre>

<p><span class="red bold">MySQL8.0新特性——自增值持久化：</span></p>
<p>在MySQL5.7中，表的自增值保存在内存中，一旦重启MySQL服务，内存中的自增值就会消失，在启动MySQL服务时，会重新使用表中的最大值作为自增值。</p>
<p>而在MySQL8.0中，自增值放在日志中，每次计数器改变都会更新日志，重启MySQL服务后，InnoDB会从日志中重新读取自增值</p>
<hr>
<p><strong>外键约束（FOREIGN KEY）</strong></p>
<p><span class="red">注意：</span>开发中基本不使用外键，数据耦合性过高</p>
<ul>
<li>从表（引用别人的表）的外键列必须引用主表（被引用的表）的主键会唯一性约束的列</li>
<li>在创建外键约束时，若不给外键约束命名，则将列名作为外键约束名</li>
<li>若要在创建表时就指定外键，需要先创建主表（被引用），再创建从表（引用）</li>
<li>删除表时，需要先删从表（引用），再删主表（被引用）</li>
<li>一个表可以指定多个外键约束</li>
<li>当创建外键约束时，系统默认会在所在的列上建立对应的索引，但是索引名是列名，不是外键的约束名</li>
<li><span class="red">删除外键约束后，还需要手动删除对应的索引</span></li>
</ul>
<p><span class="red bold">定义约束：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 表约束
CREATE TABLE 表名 (
    字段名 数据类型,
    [CONSTRAINT 约束名] FOREIGN KEY (外键字段名) REFERENCES 主表名(被引用字段名)
);</code></pre>

<p><span class="red bold">修改约束：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">ALTER TABLE 表名
ADD [CONSTRAINT 约束名] FOREIGN KEY (外键字段名) REFERENCES 主表名(被引用字段名);</code></pre>

<p><span class="red bold">约束等级：</span></p>
<p>zszz，外键约束里面，主表和从表中的某个字段有依赖关系，指定依赖等级，即指定当主表（被引用表）中有数据变更或删除时，数据库应该做的操作。</p>
<p>可以通过在声明外键语句后面加上 <code>ON UPDATE 约束等级 ON DELETE 约束等级</code> 设定当数据变更和删除时，数据库的操作，约束等级有以下几种：</p>
<ul>
<li><p><code>CASCADE</code>：在主表上更新&#x2F;删除被引用记录时，同步更新&#x2F;删除掉从表的数据</p>
</li>
<li><p><code>SET NULL</code>：在主表上更新&#x2F;删除被引用记录时，将从表上对应的记录设为NULL</p>
</li>
<li><p><code>NO ACTION</code>：若从表中有匹配的记录，则不允许主表对应记录的更新和删除</p>
</li>
<li><p><code>RESTRICT</code>（默认）：同 <code>NO ACTION</code></p>
</li>
<li><p><code>SET DEFAULT</code>：在主表上更新&#x2F;删除被引用记录时，将从表上对应的记录设为默认值</p>
</li>
</ul>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 设定当主表数据修改时，从表数据也跟着改
-- 当主表数据删除时，从表数据设为空
CREATE TABLE 表名(
    字段名 数据类型,
    [CONSTRAINT 约束名] FOREIGN KEY (外键字段名) REFERENCES 主表名(被引用字段名) ON UPDATE CASCADE ON DELETE SET NULL;
)</code></pre>

<p><span class="red">外键约束建议使用：</span></p>
<p><code>ON UPDATE CASCADE ON DELETE RESTRICT</code></p>
<p><span class="red bold">删除约束：</span></p>
<p>回顾：如何看约束名</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT * FROM information_schema.TABLE_CONSTRAINTS
WHERE TABLE_NAME &#x3D; &#39;从表名&#39;;

SHOW INDEX FROM 从表名 [FROM 数据库名]</code></pre>

<p><span class="red">注意：</span>删的是 <code>Key_name</code></p>
<p>删除约束：</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">ALTER TABLE 从表名
DROP FOREIGN KEY 外键约束名;</code></pre>

<p>除此之外还需要手动删除索引：</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">ALTER TABLE 从表名
DROP INDEX 约束名;</code></pre>

<p><span class="red bold">总结：</span></p>
<p><span class="red">实际开发中，不要使用外键和级联</span>，因为外键和级联适用于单机低并发，不适合分布式、高并发，级联更新为强阻塞，严重影响数据库的插入速度，<span class="red">所有的外键概念在Java后端应用层解决</span></p>
<p><span class="red">级联更新：</span>就是说当主表外键依赖的字段数据被修改时，就会触发从表中相应数据的更新。</p>
<hr>
<p><strong>检查约束（CHECK）</strong></p>
<p><span class="red">MySQL5.7不支持检查约束，8.0之后支持</span></p>
<p>检查约束相当于给插入该字段的数据做一个限制，当插入的数据满足括号内的语句时才允许插入，否则报错</p>
<p>使用以下代码给字段添加检查约束</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 列约束
CREATE TABLE 表名(
    字段名 数据类型 CHECK(条件语句)
);

-- 表约束
CREATE TABLE 表名(
    字段名 数据类型,
    [CONSTRAINT 约束名] CHECK(条件语句)
);

-- 如：输入的工资必须大于2000
CHECK(salary &gt; 2000)

-- 如：插入的数据必须为男或女
CHECK(sex IN (&#39;男&#39; OR &#39;女&#39;))</code></pre>

<p><span class="red bold">如何查看已经定义的检查约束：</span></p>
<p>检查约束不会创建索引，在 <code>information_schema.TABLE_CONSTRAINTS</code> 里查询也不会显示检查条件，使用 <code>SHOW</code> 查看表信息即可获得检查约束的信息，建议在控制台执行该语句，在MySQL执行出来的结果不会换行</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SHOW CREATE TABLE 表名;</code></pre>

<p><span class="red bold">修改约束：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">ALTER TABLE 表名
MODIFY 字段名 数据类型 CHECK(条件语句);

-- 不知道为什么，反正就是不要命名，命名会报错
ALTER TABLE 表名
ADD CHECK(条件语句);</code></pre>

<p><span class="red bold">删除约束：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">ALTER TABLE test
DROP CONSTRAINT test_chk_1;</code></pre>

<hr>
<p><strong>默认值约束（DEFAULT）</strong></p>
<p>若在插入数据时，该字段没有被赋值，则使用默认值</p>
<p><span class="red bold">定义约束：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CREATE TABLE 表名(
    字段名 数据类型 DEFAULT 值
);</code></pre>

<p><span class="red bold">修改约束：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">ALTER TABLE 表名
MODIFY 字段名 数据类型 DEFAULT 值;</code></pre>

<p><span class="red bold">删除约束：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">ALTER TABLE 表名
MODIFY 字段名 数据类型;</code></pre>

<p><span class="red bold">面试题：</span></p>
<ol>
<li><p>如何在建表时避免空值</p>
<p> 加非空约束和默认值约束：<code>NOT NULL DEFAULT &#39;&#39;</code> 或 <code>NOT NULL DEFAULT 0</code></p>
</li>
<li><p>为什么要避免空值</p>
<p> （1）NULL值遇到运算符会返回NULL，不好比较<br> （2）效率低，影响索引效果</p>
</li>
<li><p>AUTO_INCREMENT自增一定从1开始吗</p>
<p> 默认的AUTO_INCREMENT自增值是1，当然我们可以自行设置自增值，这样插入的数据就会从设定的值开始递增</p>
</li>
<li><p>并不是每个表都可以任意选择存储引擎</p>
<p> MySQL支持多种存储引擎，每个表都可以指定不同的存储引擎，但外键约束不可以跨引擎使用</p>
</li>
</ol>
<h2 id="数据库对象"><a href="#数据库对象" class="headerlink" title="数据库对象"></a>数据库对象</h2><p>常见的数据库对象</p>
<table>
<thead>
<tr>
<th align="center">对象</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">表（TABLE）</td>
<td align="center">存储数据的逻辑单元，以记录和字段的形式存在</td>
</tr>
<tr>
<td align="center">数据字典</td>
<td align="center">即系统表，存放数据库相关信息的表。<br />系统表的数据通常由数据库系统维护，程序员不应该修改，只可查看</td>
</tr>
<tr>
<td align="center">约束（CONSTRAINT）</td>
<td align="center">执行数据校验的规则，用于保证数据完整性</td>
</tr>
<tr>
<td align="center">视图（VIEW）</td>
<td align="center">一个或多个数据表里的数据的逻辑显示，视图不保存数据</td>
</tr>
<tr>
<td align="center">索引（INDEX）</td>
<td align="center">用于提高查询性能，相当于书的目录</td>
</tr>
<tr>
<td align="center">存储过程（PROCEDURE）</td>
<td align="center">用于完成一个完整的业务处理，没有返回值，但可以传出参数将多个值传给调用环境</td>
</tr>
<tr>
<td align="center">存储函数（FUNCTION）</td>
<td align="center">用于完成一次特定的计算，具有一个返回值</td>
</tr>
<tr>
<td align="center">触发器（TRIGGER）</td>
<td align="center">相当于一个事件监听器，当数据库发生特定事件后，触发器被触发，完成相应的处理</td>
</tr>
</tbody></table>
<h2 id="MySQL视图（VIEW）"><a href="#MySQL视图（VIEW）" class="headerlink" title="MySQL视图（VIEW）"></a>MySQL视图（VIEW）</h2><p><span class="red bold">视图人称小TABLE：</span>视图是某个表的某些字段及其记录的映射，被映射的表称为<span class="red">基表</span></p>
<hr>
<p><strong>视图概述</strong></p>
<p><span class="red">视图的特点：</span></p>
<ul>
<li>视图并不是一个新的表，它只是一种映射，就像镜子里的人<ul>
<li>你可以理解为它封装了一些查询语句</li>
</ul>
</li>
<li>它可以是表的映射，也可以是查询结果的映射（如将各部门平均工资制成视图）</li>
<li>视图的创建和删除不会影响基表，但视图的增删改查与表是同步的，反之亦然</li>
</ul>
<p><span class="red bold">视图的作用：</span></p>
<ul>
<li>简化查询</li>
<li>控制低权限人员的字段访问</li>
</ul>
<hr>
<p><strong>视图操作</strong></p>
<p><span class="red bold">创建视图：</span></p>
<p>查询语句是各种各样的查询语句，筛选、多表连接等都适用</p>
<p>甚至基于视图创建视图也可以，视图套娃！</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 详细版
CREATE [OR REPLACE]
[ALGORITHM &#x3D; &#123;UNDEFINED | MERGE | TEMPTABLE&#125;]
VIEW 视图名称 [(字段列表)]
AS 
查询语句
[WITH [CASCADED | LOCAL] CHECK OPTION];

-- 精简版
CREATE VIEW 视图名称 [(字段列表)]
AS 
查询语句;</code></pre>

<p><span class="red">若想让视图的字段名与原表名不一样，起别名的方式有两种：</span></p>
<ol>
<li><p>在视图名称后面自定义视图的字段名：</p>
<p> <span class="red">注意：括号中的别名与查询语句的字段要对应，数量要相同</span></p>
</li>
</ol>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">视图名称 (字段列表)</code></pre>

<ol>
<li>在查询语句中定义别名：</li>
</ol>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT book AS vu_book
...</code></pre>

<blockquote>
<p>如果两种都用的话，第一种的效果会覆盖第二种</p>
</blockquote>
<p><span class="red bold">查看数据库中的视图对象信息：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 查看数据库中的表和视图
SHOW TABLES;

-- 查看视图结构
DESC 视图名;

-- 查看视图的属性信息
SHOW TABLE STATUS LIKE &#39;视图名&#39;;

-- 查看视图的详细定义信息
SHOW CREATE VIEW 视图名;</code></pre>

<p><span class="red bold">对视图增删改：</span></p>
<p>对视图的增删改与和表的增删改是一样的，但是以下情况会更新失败：</p>
<ul>
<li>视图中找不到基表的对应数据，有如下几种情况：<ul>
<li>视图中的信息是一张基表的聚合查询，该视图不能更新</li>
<li>视图中使用了DISTINCT，无论有没有有效去重，该视图不能更新，只能查询</li>
<li>定义视图时使用了分组、聚合筛选（HAVING）、联合查询结果（UNION），则该视图不支持所有更新操作</li>
<li>视图中的信息是多张查询（JOIN），则该视图不可 <code>INSERT</code> 和 <code>DELETE</code></li>
<li>定义视图时指定了<code>ALGORITHM = TEMPTABLE</code>，该视图不支持 <code>INSERT</code> 和 <code>DELETE</code></li>
<li>视图中不包括基表中所有被定义为非空又未指定默认值的列，该视图不支持<code>INSERT</code></li>
<li>在定义视图时，字段列表中使用了数学表达式和子查询，该视图整体不支持 <code>UPDATE</code>，对于使用了数学表达式和子查询的字段不支持 <code>UPDATE</code></li>
<li>定义视图时包含子查询，并且子查询使用了FROM后面的表，该视图不支持所有更新操作</li>
<li>视图的基表是一个不可更新视图</li>
<li>常量视图</li>
</ul>
</li>
</ul>
<p><span class="red bold">修改视图字段信息：</span></p>
<p>当基表中有字段名称改变时，视图会失效，或想要这个表映射到其他表时，可以使用 <code>OR REPLACE</code>，将新的信息覆盖到现有的视图上</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CREATE OR REPLACE VIEW 视图名
AS
查询语句;</code></pre>

<p><span class="red bold">删除视图：</span></p>
<p>删除视图和删除表的操作一样</p>
<p><span class="red">注意：</span>若存在一个视图A，是基于另一个视图B创建的，则若删除视图B，视图A失效</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 可以删除多个视图
DROP VIEW [IF EXISTS] 视图名1[, 视图名2, ...];</code></pre>

<h2 id="MySQL存储过程（PROCEDURE）"><a href="#MySQL存储过程（PROCEDURE）" class="headerlink" title="MySQL存储过程（PROCEDURE）"></a>MySQL存储过程（PROCEDURE）</h2><hr>
<p><strong>存储过程的分类</strong></p>
<ol>
<li>无参无返回</li>
<li>有参无返回（仅IN）</li>
<li>无参有返回（仅OUT）</li>
<li>有参有返回（IN和OUT）</li>
<li>有参有返回（INOUT）</li>
</ol>
<p><span class="red">注意：</span>IN、OUT、INOUT可以在一个存储中带多个</p>
<hr>
<p><strong>存储过程的优缺点</strong></p>
<p><span class="red bold">优点：</span></p>
<ul>
<li>一次编译多次使用，减少开发工作量</li>
<li>安全性强，可以设置权限</li>
<li>减少网络传输量，将代码封装在存储过程中，需要的时候仅需调用即可</li>
<li>封装，对于相对复杂的数据库操作，可能需要多次连接数据库，若使用存储过程，仅需一次连接用于调用存储过程即可</li>
</ul>
<p><span class="red bold">缺点：</span></p>
<ul>
<li>可移植性差，存储过程不能跨数据库移植</li>
<li>调试困难</li>
<li>版本管理困难，若数据表的索引变化，可能导致存储过程失效</li>
<li>不适用于高并发</li>
</ul>
<hr>
<p><strong>存储过程总体基本格式</strong></p>
<ul>
<li>关于begin_label，跳转到 MySQL流程控制-&gt;跳转结构——LEAVE 查看</li>
</ul>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CREATE PROCEDURE 存储过程名(IN | OUT | INOUT 参数名 参数类型, ...)
[CHARACTERISTICS ...]
[begin_label:] BEGIN
    存储过程体 
END 结束符</code></pre>

<p><span class="red bold">特征（CHARACTERISTICS）：</span></p>
<p>特征是对存储过程的约束条件，它可以写以下这些值：</p>
<p><code>LANGUAGE SQL</code>：说明存储过程的执行体是由SQL语句组成的</p>
<p><code>[NOT] DETERMINISTIC</code>：说明存储过程的执行结果是否确定。</p>
<ul>
<li><span class="red">默认为不确定（NOT DETERMINISTIC）</span></li>
<li>确定表示每次输入相同的值都会得到相同的输出</li>
<li>不确定表示输入相同的值可能得到不同的输出</li>
</ul>
<p><code>&#123; CONTAINS SQL | NO SQL |&#125;</code>：</p>
<ul>
<li><span class="red">默认为 <code>CONTAINS SQL</code></span></li>
<li><code>CONTAINS SQL</code>：表示存储过程体包含SQL语句，但是没有读写数据的SQL语句</li>
<li><code>NO SQL</code>：表示存储过程体没有SQL语句</li>
</ul>
<p><code>&#123; READS SQL DATA | MODIFIES SQL DATA &#125;</code>：</p>
<ul>
<li><code>READS SQL DATA</code>：表示当前存储过程体包含读数据的SQL语句</li>
<li><code>MODIFIES SQL DATA</code>：表示当前存储过程体包含写数据的SQL语句</li>
</ul>
<p><code>SQL SECURITY &#123; DEFINER | INVORKER &#125;</code>：表示允许执行当前存储过程的用户</p>
<ul>
<li><span class="red">默认为 <code>DEFINER</code></span></li>
<li><code>DEFINER</code>：只有当前存储过程的创造者或定义者可以执行</li>
<li><code>INVOKER</code>：拥有当前存储过程访问权限的用户可以执行</li>
</ul>
<p><code>COMMENT &#39;这是存储过程或存储函数的注释&#39;</code>：注释</p>
<p><span class="red bold">结束标记重定义（DELIMITER）：</span></p>
<p>规定存储过程体中的每一句使用分号结尾，为避免和SQL中的结束符冲突，需要在定义存储过程的之前重新定义SQL的结束标记，淡然用完就给改回去，通常会将结束符重定义为 <code>$</code> 或 <code>//</code></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">DELIMITER 新的结束符</code></pre>

<p>例子：</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 暂时重定义结束符为$
DELIMITER $

-- 在END后使用
CREATE PROCEDURE 存储过程名(IN | OUT | INOUT 参数名 参数类型, ...)
[CHARACTERISTICS ...]
BEGIN
    SQL语句1;
    SQL语句2;
END $

-- 改回去
DELIMITER ;</code></pre>

<hr>
<p><strong>存储过程的调用（CALL）</strong></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CALL 存储过程名[(变量1, 变量2, ...)];</code></pre>

<hr>
<p><strong>通过OUT输出参数</strong></p>
<p><span class="red bold">将结果赋给参数：</span><br>使用 <code>INTO</code> 将查询到的字段赋给参数</p>
<p><span class="red">注意：</span>参数的命名最好和字段名不一样.若一样，给表起别名，然后在SELECT后面的字段指明表名（表名.字段）</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">DELIMITER $

CREATE PROCEDURE 存储过程名(OUT 参数名 数据类型, ...)
BEGIN
    SELECT 字段&#x2F;表达式1[, 字段&#x2F;表达式2, ...] INTO 参数名1 [, 参数名2, ...]
    FROM 表名
END $

DELIMITER ;</code></pre>

<p><span class="red bold">调用存储过程并查看结果：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 调用存储过程
CALL 存储过程名(@参数名);

-- 查看结果
CELECT @参数名;</code></pre>

<hr>
<p><strong>通过IN传入参数</strong></p>
<p><span class="red bold">基本格式：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">DELIMITER $

CREATE PROCEDURE show_someone_salary(IN emp_name VARCHAR(25))
BEGIN
    SELECT salary FROM employees
    WHERE last_name &#x3D; emp_name;
END $

DELIMITER ;</code></pre>

<p><span class="red bold">调用存储过程：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 方式1(传入常量)
CALL show_someone_salary(&#39;Abel&#39;);

-- 方式2(传入变量)
-- 等于或冒号等于都可以
SET @emp_name :&#x3D; &#39;Abel&#39;;
CALL show_someone_salary(@emp_name);</code></pre>

<hr>
<p><strong>带IN和OUT</strong></p>
<p>会用上面两个就会用这个了</p>
<p><span class="red bold">基本格式：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">DELIMITER $

CREATE PROCEDURE show_someone_salary2(IN emp_name VARCAHR(25), OUT emp_salary DOUBLE)
BEGIN
    SELECT salary INTO emp_salary
    FROM employees
    WHERE last_name &#x3D; emp_name;
END $

DELIMITER ;</code></pre>

<p><span class="red bold">调用存储过程：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SET @emp_name :&#x3D; &#39;Abel&#39;;
CALL show_someone_salary2(@emp_name, @emp_salary);

SELECT @emp_salary;</code></pre>

<hr>
<p><strong>使用INOUT</strong></p>
<p>适用于参数和返回的变量的类型一样，可以共用一个参数的情况</p>
<p><span class="red bold">基本格式：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">DELIMITER $

CREATE PROCEDURE show_mgr_name(INOUT emp_name VARCHAR(25))
BEGIN
    SELECT e2.last_name INTO emp_name
    FROM employees e1
    JOIN employees e2 ON e1.manager_id &#x3D; e2.employee_id
    WHERE e1.last_name &#x3D; emp_name;
END $

DELIMITER ;
</code></pre>

<p><span class="red bold">调用存储过程：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SET @emp_name &#x3D; &#39;Abel&#39;;
CALL show_mgr_name(@emp_name);

SELECT @emp_name;</code></pre>

<hr>
<p><strong>总结</strong></p>
<p><span class="red bold">不建议使用存储过程！</span></p>
<h2 id="MySQL存储函数（FUNCTION）"><a href="#MySQL存储函数（FUNCTION）" class="headerlink" title="MySQL存储函数（FUNCTION）"></a>MySQL存储函数（FUNCTION）</h2><p>存储函数相当于用户自定义的函数</p>
<p><span class="red">存储过程与存储函数：</span></p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">关键字</th>
<th align="center">调用方法</th>
<th align="center">返回值</th>
<th align="center">应用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">存储过程</td>
<td align="center">PROCEDURE</td>
<td align="center">CALL 存储过程名()</td>
<td align="center">没有或多个</td>
<td align="center">一般用于更新</td>
</tr>
<tr>
<td align="center">存储函数</td>
<td align="center">FUNCTION</td>
<td align="center">SELECT 存储函数名()</td>
<td align="center">一个</td>
<td align="center">用于查询结果为一个值并返回时</td>
</tr>
</tbody></table>
<ul>
<li>存储函数可以放在查询语句中使用，存储过程不行</li>
<li>存储过程可以执行对表的更新和事务操作</li>
</ul>
<hr>
<p><strong>存储函数基本格式</strong></p>
<p>关于begin_label，跳转到 MySQL流程控制-&gt;跳转结构——LEAVE 查看</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">DELIMITER $

CREATE FUNCTION 函数名(参数名 参数类型, ...)
RETURNS 返回值类型
[CHARACTERISTICS ...]
[begin_label:] BEGIN
    函数体
    RETURN &#123; 值 | (语句) &#125;;
END $

DELIMITER ;</code></pre>

<p><span class="red bold">注意：</span></p>
<ul>
<li>存储函数不支持定义IN OUT，存储函数的参数总为IN</li>
<li>必须使用 <code>RETURNS</code> 指定返回值类型，在函数体必须使用 <code>RETURN</code> 返回值</li>
</ul>
<hr>
<p><strong>存储函数的调用</strong></p>
<p>存储函数和SQL自带的函数的调用方式一样，使用即调用：</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT 存储函数名(参数)
FROM ...;</code></pre>

<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">DELIMITER $

CREATE FUNCTION email_by_name()
RETURNS VARCHAR(20)
BEGIN
    RETURN(SELECT email FROM employees
    WHERE last_name &#x3D; &#39;Abel&#39;);
END $

DELIMITER ;</code></pre>

<p><span class="red">注意：</span>若在创建存储过程时报错</p>
<ul>
<li><p><code>This function has none of DETERMINISTIC, NO SQL, or READS SQL DATA in its declaration and binary logging is enabled (you *might* want to use the less safe log_bin_trust_function_creators variable)</code></p>
<ul>
<li>解决1：根据实际情况加上特征值 <code>CONTAINS SQL DETERMINISTIC READS SQL DATA</code></li>
<li>解决2：定义不安全变量 <code>SET GLOBAL log_bin_trust_function_creators = 1;</code></li>
</ul>
</li>
<li><p><code>You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;函数名() ...</code></p>
<ul>
<li>检查函数名是否与内置函数名冲突</li>
</ul>
</li>
</ul>
<h2 id="存储过程与存储函数属性的查看、修改、删除"><a href="#存储过程与存储函数属性的查看、修改、删除" class="headerlink" title="存储过程与存储函数属性的查看、修改、删除"></a>存储过程与存储函数属性的查看、修改、删除</h2><hr>
<p><strong>查看</strong></p>
<p><span class="red bold">使用SHOW CREATE：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SHOW CREATE &#123;PROCEDURE | FUNCTION&#125; 存储过程名或存储函数名;</code></pre>

<p><span class="red bold">使用SHOW STATUS：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 若不写LIKE则显示所有存储过程或存储函数
SHOW &#123;PROCEDURE | FUNCTION&#125; STATUS [LIKE] &#39;存储过程名或存储函数名&#39;;</code></pre>

<p><span class="red bold">从 <code>information_schema.ROUTINES</code> 查看：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 当存在存储过程与存储函数同名的情况下，需要指明ROUTINE_TYPE
SELECT * FROM information_schema.ROUTINES
WHERE ROUTINE_NAME &#x3D; &#39;存储过程名或存储函数名&#39; [AND ROUTINE_TYPE &#x3D; &#123;&#39;PROCEDURE&#39; | &#39;FUNCTION&#39;&#125;];</code></pre>

<hr>
<p><strong>修改（MODIFY）</strong></p>
<p><span class="red">注意：</span>不能修改存储过程体或存储函数体</p>
<p>只能修改特性的部分，并且可修改的值有限：</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 可以修改的值有：
&#123; CONTAINS SQL | NO SQL&#125;
&#123; READS SQL DATA | MODIFY SQL DATA &#125;
SQL SERCURITY &#123; DEFINER | INVOKER &#125;
COMMENT &#39;&#39;</code></pre>

<p>使用以下代码修改一个存储过程或存储函数</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">ALTER &#123; PROCEDURE | FUNCTION &#125; 存储过程名或存储函数名 [CHARACTERISTICS ...];</code></pre>

<hr>
<p><strong>删除（DROP）</strong></p>
<p>使用以下代码删除存储过程或存储函数</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">DROP &#123; PROCEDURE | FUNCTION &#125; 存储过程名或存储函数名;</code></pre>

<h2 id="MySQL变量"><a href="#MySQL变量" class="headerlink" title="MySQL变量"></a>MySQL变量</h2><p>变量：分为系统变量（全局系统变量、会话系统变量）、用户自定义变量</p>
<hr>
<p><strong>系统变量</strong></p>
<p><span class="red bold">系统变量：</span>系统变量有系统定义，属于服务器层面。当启动MySQL服务，生成MySQL服务实例期间，MySQL将为服务器内存汇总的系统变量赋值。<br />这些系统变量定义了当前MySQL服务实例的属性和特征。<br />这些系统变量要么是编译MySQL时参数的默认值，要么是配置文件（my.ini）中的参数值<br />可以通过 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html">Server System Variables</a> 查看MySQL的系统变量</p>
<p><span class="red bold">系统变量的分类：</span></p>
<ul>
<li>全局系统变量（GLOBAL）：针对所有会话（连接）有效，但不能跨重启（<span class="red">MySQL8.0之后可以实现跨重启</span>，详见下面 全局变量持久化）。当前会话对全局系统变量的修改会导致其他会话的系统变量的值<ul>
<li>静态变量：是特殊的全局系统变量，它不支持在MySQL运行期间对其进行修改</li>
</ul>
</li>
<li>会话系统变量（SESSION）（默认）：仅针对当前会话有效。会话期间，当前会话对会话系统变量进行修改，不会影响其他会话的系统变量的值</li>
</ul>
<table>
<thead>
<tr>
<th align="center">全局系统变量与会话系统变量</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="https://s1.ax1x.com/2022/06/12/X2QJtU.png" alt="全局系统变量与会话系统变量.png"></td>
</tr>
</tbody></table>
<p><span class="red">注意：</span>在MySQL中有些系统变量只能是全局的，有些系统变量既可以是全局的也可以是会话的，在设置的时候需要指定是在哪个层面修改，有些系统变量的只能是会话的</p>
<p><span class="red bold">查看全部或部分系统变量：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 查看全局系统变量
SHOW GLOBAL VARIABLES;

-- 查看会话系统变量
SHOW [SESSION] VARIABLES;

-- 查看部分全局系统变量
SHOW GLOBAL VARIABLES LIKE &#39;系统变量名&#39;;

-- 查看部分会话系统变量
SHOW [SESSION] VARIABLES LIKE &#39;系统变量名&#39;;</code></pre>

<p><span class="red bold">查看指定的系统变量：</span></p>
<p>在MySQL中，系统变量以 <code>@@</code> 开头，其中 <code>@@globle</code> 仅用于标记</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 查看指定的系统变量的值
SELECT @@GLOBAL.变量名;

-- 查看指定的会话变量的值
SELECT @@ssesion.变量名;

-- 当这样写时，系统会先在会话变量中找，若没有，择取全局变量里找
SELECT @@变量名;</code></pre>

<p><span class="red bold">修改系统变量：</span></p>
<ul>
<li>方式1：直接修改配置文件my.ini，需要重启MySQL服务使其生效</li>
<li>方式2：在MySQL运行期间使用 <code>SET</code> 修改系统变量的值，<span class="red">重启失效</span></li>
</ul>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 为全局系统变量赋值
SET @@global.变量名 &#x3D; 值;
SET GLOBAL 变量名 &#x3D; 变量值;

-- 为会话系统变量赋值
SET @@session.变量名 &#x3D; 值;
SET SESSION 变量名 &#x3D; 值;</code></pre>

<p><span class="red bold">全局变量持久化：</span></p>
<p>要想实现对全局变量的修改在重启后还生效，需要在GLOBAL前加上 <code>PERSIST</code>，使用该命令的参数会保存在 <code>mysqld-auto.cnf</code> 中，每次启动都会读取这些配置</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SET PERSIST GLOBAL 变量名 &#x3D; 变量值;</code></pre>

<hr>
<p><strong>用户变量</strong></p>
<p><span class="red bold">用户变量的分类：</span></p>
<ul>
<li>会话用户变量：会话用户变量使用 <code>@</code> 开头，其作用域为当前会话</li>
<li>局部变量：只在 BEGIN 和 END 中有效，因此只能在存储函数和存储过程中使用</li>
</ul>
<p><span class="red bold">会话用户变量的定义和赋值：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 方式1；使用 SET 语句
SET @用户变量 &#x3D; 值;
SET @用户变量 :&#x3D; 值;

-- 方式2：使用 &quot;:&#x3D;&quot; 或 INTO 
SELECT @用户变量 :&#x3D; 表达式 [FROM ...]
SELECT 表达式1[, 表达式2, ...] INTO @用户变量[, @用户变量2, ...] [FROM ...]</code></pre>

<p><span class="red bold">会话用户变量值的查看：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT @用户变量;</code></pre>

<p><span class="red bold">局部变量的定义：</span></p>
<p><span class="red">注意：</span></p>
<ul>
<li>局部变量必须使用 <code>DECLARE</code> 声明</li>
<li>只能在 BEGIN … END 中声明和使用</li>
<li>必须声明在 存储过程体或存储函数体 的最前面</li>
<li>局部变量<span class="red">是唯一一种在声明的是时候需要指明类型变量</span></li>
<li>默认值可以是一个指定的传入变量，只要他们类型相同</li>
</ul>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 若没有指定默认值，则默认为NULL
DECLARE 变量名 类型 [default 默认值];

-- 若多个变量相同类型
DECLARE 变量名1, 变量名2 类型 [default 默认值];</code></pre>

<p><span class="red bold">局部变量的赋值：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 方式1：使用 SET
SET 变量名 &#x3D; 值;
SET 变量名 :&#x3D; 值;

-- 方式2： 使用 INTO
SELECT 字段名或表达式1[, 字段名或表达式2, ...] INTO 变量名1[, 变量名2, ...]
FROM ...</code></pre>

<p><span class="red bold">局部变量值的查看：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT @局部变量;</code></pre>

<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 会话用户变量
SET @num1 &#x3D; 1;
SET @num2 &#x3D; 6;


-- 局部变量
DELIMITER $

CREATE PROCEDURE sum_print()
BEGIN 
    DECLARE num1 TINYINT default 1;
    DECLARE num2 TINYINT default 2;
    DECLARE sum_num TINYINT;

    SELECT num1 + num2 INTO sum_num;

    SELECT sum_num;
END $

DELIMITER ;
</code></pre>

<h2 id="MyQSL定义条件与处理程序（异常处理）"><a href="#MyQSL定义条件与处理程序（异常处理）" class="headerlink" title="MyQSL定义条件与处理程序（异常处理）"></a>MyQSL定义条件与处理程序（异常处理）</h2><p>定义条件和处理程序使用在存储过程、存储函数中</p>
<p><span class="red">注意：</span>它们都使用 <code>DECLARE</code> 定义，需要放在存储过程体和存储函数体的最前面</p>
<hr>
<p><strong>定义条件</strong></p>
<p><span class="red bold">定义条件：</span>指事先定义程序在执行过程中可能遇到的问题。实质上就是给MYSQL中的错误码命名</p>
<p>使用以下代码定义条件</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">DECLARE 错误名称 CONDITION FOR &#123; 错误码 | SQLSTATE &#39;状态码&#39;&#125;;</code></pre>

<ul>
<li><p>错误码：错误码分为两种</p>
<ul>
<li><code>MySQL_error_code</code>：（错误码）数值型错误代码，在错误信息的ERROR后面</li>
<li><code>sqlstate_value</code>：（状态码）5位字符串错误代码，在括号里面</li>
</ul>
</li>
</ul>
<br />

<p>例子：</p>
<p>定义 “Field_Not_Be_Null” 错误名与MySQL中国违反非空约束的错误类型 “ERROR 1048 (23000)” 对应</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">DECLARE Field_Not_Be_Null CONDITION FOR 1048;
DECLARE Field_Not_Be_Null CONDITION FOR SQLSTATE &#39;23000&#39;;</code></pre>

<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">DECLARE command_not_allowed CONDITION FOR 1148;

DECLARE command_not_allowed CONDITION FOR SQLSTATE &#39;42000&#39;;</code></pre>

<hr>
<p><strong>处理程序</strong></p>
<p><span class="red bold">处理程序：</span>指定义在遇到问题时采取的处理方式，使存储过程和存储函数在遇到警告或错误时能继续执行。增强了存储程序处理问题的能力，避免程序异常停止运行</p>
<p><span class="red bold">定义处理程序：</span></p>
<p>使用以下代码定义处理程序</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">DECLARE 处理方式 HANDLER FOR 错误类型 处理语句;</code></pre>

<ul>
<li>处理方式：处理方式有三个取值<ul>
<li><code>CONTINUE</code>：忽略错误，继续执行下面的语句</li>
<li><code>EXIT</code>：遇到错误马上退出</li>
<li><code>UNDO</code>：撤回之前的操作（<span class="red">注意：MySQL不支持该操作</span>）</li>
</ul>
</li>
<li>错误类型：指何时触发该处理程序，可以有以下取值<ul>
<li><code>SQLSTATE &#39;状态码&#39;</code>：（根据需要填写）</li>
<li><code>MySQL_error_code</code>：（根据需要填写）</li>
<li><code>错误名称</code>：（根据需要填写）上面定义条件所定义的错误名称</li>
<li><code>SQLWARING</code>：（写的就是这一串英文）匹配所有以01开头的SQLSTATE错误码</li>
<li><code>NOT FOUND</code>：（写的就是这一串英文）匹配所有以02开头的SQLSTATE错误码</li>
<li><code>SQLEXCEPTION</code>：（写的就是这一串英文）匹配所有没有被SQLWARING或NOT FOUND捕获的错误码</li>
</ul>
</li>
<li>处理语句：条件触发后所执行的语句，可以是简单的单条语句，也可以是 <code>BEGIN ... END</code> 这样的复合语句</li>
</ul>
<br />

<p>例子：</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">DECLARE EXIT HANDLER FOR SQLWARNING SET @info &#x3D; &#39;ERROR&#39;;</code></pre>

<h2 id="MySQL流程控制"><a href="#MySQL流程控制" class="headerlink" title="MySQL流程控制"></a>MySQL流程控制</h2><p><span class="red bold">注意：</span>在写语句时一定要注意使用 <code>WHERE</code> ，不要将数据全部改了！</p>
<hr>
<p><strong>流程控制的分类</strong></p>
<ul>
<li>判断（分支）：<code>IF</code>、<code>CASE</code></li>
<li>循环：<code>LOOP</code>、<code>WHILE</code>、<code>REPEAT</code></li>
<li>跳转：<code>ITERATE</code>、<code>LEAVE</code></li>
</ul>
<p><span class="red">注意：</span>使用流程控制，必须使用变量，因为语句中的 表达式 部分无法访问到表，更无法访问到表中的指定一条数据</p>
<hr>
<p><strong>分支结构——IF</strong></p>
<p><span class="red bold">结构：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">IF 表达式1 THEN 语句1;
[ELSEIF 表达式2 THEN 语句2;]
[ELSEIF ...]
[ELSE 语句;]
END IF; </code></pre>

<hr>
<p><strong>分支结构——CASE</strong></p>
<p><span class="red bold">结构：</span></p>
<p><span class="red">注意：</span>CASE结构使用在 <code>BEGIN... END</code> 中时，以 <code>END CASE;</code> 结尾<br />使用在SELECT中时，使用 <code>END</code> 结尾</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 写法1
CASE &#123; 字段名（仅限SELECT中） | 变量名 | (表达式) &#125;
WHEN 值1 THEN 结果1或语句1（若为语句需要加分号）
THEN 值2 THEN 结果2或语句2（若为语句需要加分号）
...
ELSE 结果n或语句n（若为语句需要加分号）
END [CASE;]

-- 写法2
CASE 
WHEN 条件1 THEN 结果1或语句1（若为语句需要加分号）
THEN 条件2 THEN 结果2或语句2（若为语句需要加分号）
...
ELSE 结果n或语句n
END [CASE;]</code></pre>

<hr>
<p><strong>循环结构——LOOP、LEAVE</strong></p>
<p>LOOP用于循环执行某些语句，但LOOP的基本结构并没有能让它跳出循环的语句，因此它需要结合分支结构和 <code>LEAVE</code> 使用</p>
<p><span class="red bold">结构：</span></p>
<ul>
<li>label指循环结构的名称</li>
</ul>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">[label:] LOOP
    语句;
    [IF 条件 THEN LEAVE [label];]
END LOOP [label]</code></pre>

<p>例子</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 将一个变量循环加到10

DELIMITER &#x2F;&#x2F;

CREATE PROCEDURE loop_test()
BEGIN
    DECLARE i INT DEFAULT 0;

    plus:
    LOOP
        SET i &#x3D; i + 1;
        IF i &gt;&#x3D; 10 THEN
            LEAVE plus;
        END IF;
    END LOOP plus;

    SELECT i;

END &#x2F;&#x2F;

DELIMITER ;</code></pre>

<hr>
<p><strong>循环结构——WHILE … DO …</strong></p>
<p><span class="red bold">结构：</span></p>
<p><span class="red">注意循环条件不要使用分号</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">[while_label:] WHILE 循环条件 DO
    语句;
END WHILE [while_label];</code></pre>

<hr>
<p><strong>循环结构——REPEAT … UNTIL</strong></p>
<p><span class="red bold">结构：</span></p>
<p><span class="red">注意：</span></p>
<ul>
<li>单词 <code>UNTIL</code></li>
<li>循环条件不要使用分号</li>
<li>循环体无论如何至少执行一次</li>
</ul>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">[repeat_label:] REPEAT
    语句;
    UNTIL 结束循环条件
END REPEAT [repeat_label];</code></pre>

<hr>
<p><strong>跳转结构——LEAVE</strong></p>
<p>相当于 <code>break</code> ，用于跳出，不仅能跳出循环，还能跳出 <code>BEGIN ... END</code> 结构。</p>
<p><span class="red bold">格式：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">LEAVE 标记名;</code></pre>

<hr>
<p><strong>跳转结构——ITERATE</strong></p>
<p>相当于 <code>continue</code> ，它只能使用在循环内部，意为直接跳回循环开始处，在 <code>ITERATE</code> 下面的语句在本次循环中不会执行</p>
<p><span class="red bold">格式：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">ITERATE 标记名;</code></pre>

<h2 id="MySQL游标（CURSOR）"><a href="#MySQL游标（CURSOR）" class="headerlink" title="MySQL游标（CURSOR）"></a>MySQL游标（CURSOR）</h2><p>相当于Java集合里面的迭代器，游标可以使用户逐条读取结果集中的数据，<span class="red">但是，在使用游标期间，数据会被加锁，高并发情况下效率低下</span></p>
<hr>
<p><strong>游标的使用</strong></p>
<p><span class="red bold">声明游标：</span></p>
<p><span class="red">注意：</span></p>
<ul>
<li>游标使用 <code>DECLARE</code> 声明，它需要放在 <code>BEGIN ... END</code> 结构的前面，并且<span class="red">变量声明的后面</span></li>
</ul>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- MySQL、SQL server、DB2、MariaDB格式
DECLARE 游标名 CURSOR FOR SELECT结果集;

-- Oracle、PostgreSQL格式
DECLARE 游标名 CURSOR IS SELECT结果集;</code></pre>

<p><span class="red bold">打开游标：</span></p>
<p>这一步会将SELECT结果集移到游标的工作内存中</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">OPEN 游标名;</code></pre>

<p><span class="red bold">使用游标：</span></p>
<ul>
<li>该操作会将指针当前指向的行的每一列数据保存到变量中，因此变量数量与结果集里字段的数量要一致</li>
<li>存储过后，游标指针指向下一行</li>
</ul>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">FETCH 游标名 INTO 变量1[, 变量2, ...];</code></pre>

<p><span class="red bold">关闭游标：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CLOSE 游标名;</code></pre>

<p>例子：输入一个工资总和，公司员工的工资从高到低累加，当这个值大于等于输入的工资总和时，退出累加，并且记录其中进行了几次累加</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">DELIMITER $

CREATE PROCEDURE get_count_by_limit_total(IN limit_total_salary DOUBLE, OUT total_count TINYINT)
BEGIN
    -- 累加变量和每行变量
    DECLARE total, temp_sal DOUBLE DEFAULT 0.0;
    -- 计次变量
    DECLARE loop_count TINYINT DEFAULT 0;

    -- 游标声明
    DECLARE mark CURSOR FOR
        SELECT salary FROM test ORDER BY salary DESC;

    OPEN mark;

    total_count: LOOP
        IF total &gt;&#x3D; limit_total_salary THEN LEAVE total_count;
        ELSE
            -- 取出数据
            FETCH mark INTO temp_sal;
            SET total &#x3D; total + temp_sal;
            SET loop_count &#x3D; loop_count + 1;
            END IF;
    END LOOP total_count;

    CLOSE mark;

    SELECT loop_count INTO total_count;

END $

DELIMITER ;</code></pre>

<h2 id="MySQL触发器（TRIGGER）"><a href="#MySQL触发器（TRIGGER）" class="headerlink" title="MySQL触发器（TRIGGER）"></a>MySQL触发器（TRIGGER）</h2><p>触发器是由事件来触发某个操作，这些事件包括 <code>INSERT</code> <code>UPDATE</code> <code>DELETE</code> 事件</p>
<hr>
<p><strong>触发器的优缺点</strong></p>
<p><span class="red bold">触发器的优点：</span></p>
<ul>
<li>确保数据的完整性，对于一些有关联的表，一张表变动可能需要另外一些表的数据一起变</li>
<li>可以自动记录日志，记录什么时间执行了什么操作，如写一个修改了某张表的数据之后自动向记录表写操作日志的触发器</li>
<li>可以对当前要插入的数据进行合法性检查</li>
</ul>
<p><span class="red bold">触发器的缺点：</span></p>
<ul>
<li>可读性差，在触发器写好之后若没有语法错误是不会报错的，但是若在触发器中的增删改操作在执行时会报错，则仅当该触发器被触发时才会报错，这会导致这个报错要从一堆触发器里面找</li>
<li>表的结构变更可能会导致触发器出错</li>
</ul>
<p><span class="red bold">注意：</span></p>
<p>若是基于外键约束的修改，如当设置了 <code>ON DELETE SET NULL</code>，则当从表中的数据被自动 SET NULL 时，从表的 UPDATE 触发器<span class="red">不会触发</span></p>
<hr>
<p><strong>触发器操作</strong></p>
<p><span class="red bold">触发器的创建：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CREATE TRIGGER 触发器名
&#123; BEFORE | AFTER &#125; &#123; INSERT | UPDATE | DELETE &#125; ON 表名
FOR EACH ROW
触发器语句;</code></pre>

<ul>
<li>表名：表示触发器监控的对象</li>
<li><code>BEFORE | AFTER</code>：表示触发器执行时间，在事件之前执行还是之后执行</li>
<li><code>INSERT | UPDATE | DELETE</code>：对监控对象的哪种操作会触发触发器</li>
<li>触发器语句：可以是单条，也可以是使用 <code>BEGIN ... END</code> 包裹的语句块</li>
</ul>
<p>例子：</p>
<p>定义一个触发器，基于员工表“employees”的INSERT事件，在INSET之前检查将要添加的新员工的薪资是否大于他的领导的薪资，若大于，则报自定义异常：sqlstate_value 为‘HY000’，从而使添加失败</p>
<ul>
<li><p>这里涉及两个新问题：</p>
<ul>
<li>如何对当前需要添加的数据进行读取（详见 OLD 与 NEW）</li>
<li>如何自定义异常</li>
</ul>
<p>  这会在本章最后说明，当然也可以直接看这一段代码</p>
</li>
</ul>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">DELIMITER $

CREATE TRIGGER salary_check_trigger
    BEFORE INSERT
    ON employees
    FOR EACH ROW
BEGIN
    DECLARE mgr_sal DOUBLE;
    SELECT salary
    INTO mgr_sal
    FROM employees
    -- 使用NEW代表新的记录
    WHERE employee_id &#x3D; NEW.manager_id;

    IF NEW.salary &gt; mgr_sal
    THEN
        -- 自定义异常
        SIGNAL SQLSTATE &#39;HY000&#39; SET MESSAGE_TEXT &#x3D; &#39;薪资高于领导的薪资&#39;;
    END IF;
END $

DELIMITER ;</code></pre>

<p><span class="red bold">查看触发器信息：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 查看当前数据库所有的触发器
SHOW TRIGGERS;

-- 查看当前数据库中某个触发器的定义
SHOW CREATE TRIGGER 触发器名;

-- 从系统数据库查看
SELECT * FROM information_schema.TRIGGERS;</code></pre>

<p><span class="red bold">删除触发器：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">DROP TRIGGER [IF EXISTS] 触发器名;</code></pre>

<hr>
<p><strong>OLD 与 NEW</strong></p>
<p><span class="red bold">NEW：</span></p>
<p>当前需要添加的但并未添加的记录，定义为关键字 <code>NEW</code></p>
<p>可以使用 <code>NEW.字段名</code> 读取该行未添加记录的数据</p>
<p><span class="red bold">OLD:</span></p>
<p>当需要读取当前操作的表中的记录的数据时（如当前删除的数据），定义为关键字 <code>OLD</code></p>
<p>可以使用 <code>OLD.字段名</code> 读取该行即将被操作的记录的数据</p>
<hr>
<p><strong>如何自定义异常</strong></p>
<p>使用以下格式在过程中抛出一个自定义异常</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SIGNAL SQLSTATE &#39;自定义状态码&#39; SET MESSAGE_TEXT &#x3D; &#39;异常信息&#39;;</code></pre>

<h2 id="MySQL8-0新特性——窗口函数"><a href="#MySQL8-0新特性——窗口函数" class="headerlink" title="MySQL8.0新特性——窗口函数"></a>MySQL8.0新特性——窗口函数</h2><hr>
<p><strong>窗口函数</strong></p>
<p>MySQL8.0开始支持窗口函数，窗口函数会在查询中将数据进行分组，但与 <code>GROUP BY</code> 不同的是，窗口函数不会将他们聚合为一条记录</p>
<p><span class="red bold">窗口函数的分类：</span></p>
<ul>
<li>静态窗口函数：窗口大小固定</li>
<li>动态窗口函数：窗口大小会随记录不同而变化</li>
</ul>
<table>
<thead>
<tr>
<th align="center">函数分类</th>
<th align="center">函数名</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">序号函数</td>
<td align="center">ROW_NUMBER()</td>
<td align="center">按照分组和排序结果，另起一个字段<br />并标上顺序序号</td>
</tr>
<tr>
<td align="center">序号函数</td>
<td align="center">RANK()</td>
<td align="center">并列排序<br />会跳过重复的序号</td>
</tr>
<tr>
<td align="center">序号函数</td>
<td align="center">DENSE_RANK()</td>
<td align="center">并列排序<br />不会跳过重复的序号</td>
</tr>
<tr>
<td align="center">分布函数</td>
<td align="center">PERCENT_RANK()</td>
<td align="center">等级值百分比</td>
</tr>
<tr>
<td align="center">分布函数</td>
<td align="center">CUME_DIST()</td>
<td align="center">累积分布值</td>
</tr>
<tr>
<td align="center">前后函数</td>
<td align="center">LAG(字段名, [n], [default])</td>
<td align="center">返回当前行的前n行（不写则为1）的字段名对应的值<br />若没有对应的值，默认使用NULL<br />若定义了default值，则使用difault值</td>
</tr>
<tr>
<td align="center">前后函数</td>
<td align="center">LEAD(字段名, [n], [default])</td>
<td align="center">返回当前行的后n行（不写则为1）的字段名对应的值<br />若没有对应的值，默认使用NULL<br />若定义了default值，则使用difault值</td>
</tr>
<tr>
<td align="center">首尾函数</td>
<td align="center">FIRST_VALUE(字段名)</td>
<td align="center">返回当前组第一行指定字段的值<br />并将其应用到该组全部行</td>
</tr>
<tr>
<td align="center">首尾函数</td>
<td align="center">LAST_VALUE(字段名)</td>
<td align="center">返回当前组最后一行指定字段的值<br />并将其应用到该组全部行</td>
</tr>
<tr>
<td align="center">其它函数</td>
<td align="center">NTH_VALUE(字段名, n)</td>
<td align="center">返回当前行第n个应用到expr的值</td>
</tr>
<tr>
<td align="center">其它函数</td>
<td align="center">NTILE(n)</td>
<td align="center">将分区中的有序数据分为n个桶，并记录桶的编号</td>
</tr>
</tbody></table>
<p><span class="red">并列排序：</span>指若排序依据中有相同的值，则他们的序号相同</p>
<p><span class="red bold">结构：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT 窗口函数 OVER ([PARTITION BY 字段名 ORDER BY 字段名 &#123; ASC | DESC &#125;]) [AS 列的别名]
FROM ...;

-- 我们把OVER后面的分组和排序方法称为一个窗口
-- 若这种分组和排序方法要使用多次，我们可以像下面这样，给窗口起一个别名
-- 需要的时候通过 OVER 窗口名 进行调用

-- 需要注意的是：窗口的声明需要放在过滤条件后面，若没有过滤条件，则放FROM后面

SELECT 窗口函数 OVER 窗口名 [AS 列的别名]
FROM ... 
WINDOW 窗口名 AS (
    [PARTITION BY 字段名]
    [ORDER BY 字段名 &#123; ASC | DESC &#125;]
    [frame_units frame_extent]
);</code></pre>

<ul>
<li><code>OVER</code>：用于指定函数窗口的范围<ul>
<li>若省略后面括号的内容，则窗口会包含所有满足 <code>WHERE</code> 条件的记录，窗口函数会基于所有这个记录进行计算</li>
</ul>
</li>
<li>窗口名：给窗口设置别名</li>
<li><code>PARTITION BY</code>：指定窗口函数按照那些字段分组，分组后，窗口函数可以在每个分组中分别执行</li>
<li><code>ORDER BY</code>：指定窗口函数按照那些字段排序，排序后，窗口函数按照排序后的记录顺序进行编号</li>
<li><code>FRAME</code>：为分区中某个子集定义规则，可以用来作为滑动窗口使用</li>
</ul>
<hr>
<p><strong>帧基本（FRAME）</strong></p>
<blockquote>
<p>参考资料1：<a target="_blank" rel="noopener" href="https://blog.csdn.net/georgelee954/article/details/105763302">https://blog.csdn.net/georgelee954/article/details/105763302</a><br>参考资料2：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/346876184">https://zhuanlan.zhihu.com/p/346876184</a></p>
</blockquote>
<p><span class="red bold">帧基本单位（frame_units）：</span></p>
<p>帧基本单位取值有两种，分别是 <code>&#123; ROWS | RANGE &#125;</code></p>
<ul>
<li><code>ROWS</code>：<span class="red">以行为单位</span>，以一行为一个单位执行函数</li>
<li><code>RANGE</code>：<span class="red">以值为单位</span>，以一个或多个相同的排序依据值为单位执行函数</li>
</ul>
<p><span class="red bold">帧范围（frame_extent）：</span></p>
<p>帧范围语句有以下几种：</p>
<ul>
<li><code>CURRENT ROW</code>：当前行</li>
<li><code>UNBOUNDED PRECEDING</code>：当前行上侧所有行（不超过当前<code>PARTITION BY</code> 分组）</li>
<li><code>UNBOUNDED FOLLOWING</code>：当前行下侧所有行（不超过当前<code>PARTITION BY</code> 分组）</li>
<li><code>expr PRECEDING</code>：当前行上侧expr行(expr可以是数字，也可以是表达式)</li>
<li><code>expr FOLLOWING</code>：当前行下侧expr行(expr可以是数字，也可以是表达式)</li>
</ul>
<p>帧范围取值方法有两种，分别是：</p>
<ul>
<li><code>frame_start</code>：只指定开始行，结束行为默认值（当前行）<ul>
<li>帧范围指定方法：  <pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 采用指定开始行，直接写帧范围语句即可
-- 以下代码指定帧开始行为当前行上一行，结束行为默认值（当前行）
... OVER (PARTITION BY ... ORDER BY ... ROWS 1 PRECEDING)</code></pre></li>
</ul>
</li>
<li><code>frame_between</code>：指定开始行和结束行<ul>
<li>帧范围指定方法：  <pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 采用指定开始行和结束行，使用 BETWEEN ...AND ...
-- 以下代码指定帧开始行为当前行上所有，结束行为当前行下所有行
... OVER (PARTITION BY ... ORDER BY ... RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)</code></pre></li>
</ul>
</li>
</ul>
<hr>
<p><strong>帧基本单位与范围详解</strong></p>
<p><span class="red bold">ROWS：</span></p>
<p><code>ROWS</code> 是以 行 为单位的帧基本单位，无论它前面有没有 <code>PARTITION BY</code> 和 <code>ORDER BY</code> ，它可以搭配所有帧范围语句</p>
<p>在搭配帧范围语句时，将会有以下效果：</p>
<ul>
<li><p>（<span class="red">当前行</span>）搭配 <code>CURRENT ROW</code> （仅指定开始行，结束默认当前行）:</p>
  <pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT id, r1, SUM(r1) OVER (PARTITION BY id ORDER BY r1 ASC RANGE CURRENT ROW) AS wf_result
FROM t1
WHERE id &#x3D; 1;</code></pre>
<p>  <img src="https://s1.ax1x.com/2022/06/17/XqAk4I.png" alt="ROWS + CURRENT ROW.png"></p>
<blockquote>
<p>在当前分组下，每一行仅对当前行运算</p>
</blockquote>
</li>
<li><p>（<span class="red">拓展上限</span>）搭配 <code>UNBOUNDED PRECEDING</code> （仅指定开始行，结束默认当前行）：</p>
  <pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT id, r1, SUM(r1) OVER (PARTITION BY id ORDER BY r1 ASC ROWS UNBOUNDED PRECEDING) AS wf_result
FROM t1
WHERE id &#x3D; 1;</code></pre>

<p>  <img src="https://s1.ax1x.com/2022/06/17/XqmA6x.png" alt="ROWS + UNBOUNDED PRECEDING.png"></p>
<blockquote>
<p>在当前分组下，每一行需要对其本身和其上面的所有行运算</p>
</blockquote>
</li>
<li><p>（<span class="red">拓展上限</span>）搭配 <code>expr PRECEDING</code> （仅指定开始行，结束默认当前行）</p>
  <pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT id, r1, SUM(r1) OVER (PARTITION BY id ORDER BY r1 ASC ROWS 2 PRECEDING) AS wf_result
FROM t1
WHERE id &#x3D; 1;</code></pre>

<p>  <img src="https://s1.ax1x.com/2022/06/17/XqnGG9.png" alt="ROWS + expr PRECEDING.png"></p>
<blockquote>
<p>在当前分组下，每一行需要对其本身和其上面的expr行运算</p>
</blockquote>
</li>
<li><p>（<span class="red">拓展下限</span>）搭配 <code>UNBOUNDED FOLLOWING</code> （指定开始行与结束行）：</p>
<p>  <span class="red">注意拓展下限必须使用 <code>BETWEEN AND</code> </span></p>
  <pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT id,
    r1,
    SUM(r1)
        OVER (PARTITION BY id ORDER BY r1 ASC ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) AS wf_result
FROM t1
WHERE id &#x3D; 1;</code></pre>

<p>  <img src="https://s1.ax1x.com/2022/06/17/Xq2sYT.png" alt="ROWS + UNBOUNDED FOLLOWING.png"></p>
<blockquote>
<p>在当前分组下，每一行需要对其本身和其下面的所有行运算</p>
</blockquote>
</li>
<li><p>（<span class="red">拓展下限</span>）搭配 <code>expr FOLLOWING</code> （指定开始行与结束行）：</p>
  <pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT id,
    r1,
    SUM(r1) OVER (PARTITION BY id ORDER BY r1 ASC ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING)
        AS wf_result
FROM t1
WHERE id &#x3D; 1;</code></pre>

<p>  <img src="https://s1.ax1x.com/2022/06/17/XqR8BR.png" alt="ROWS + expr FOLLOWING.png"></p>
<blockquote>
<p>在当前分组下，每一行需要对其本身和其下面的expr行运算</p>
</blockquote>
</li>
</ul>
<p><span class="red bold">RANGE：</span></p>
<p><code>RANGE</code> 是以 值（内容） 为单位，无论它前面有没有 <code>PARTITION BY</code> ,但有无 <code>ORDER BY</code> 会影响其可搭配的帧范围语句</p>
<br />

<p>在没有 <code>ORDER BY</code> 时，可搭配 </p>
<ol>
<li><code>CURRENT ROW</code></li>
<li><code>UNBOUNDED PRECEDING</code></li>
<li><code>BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING</code></li>
</ol>
<p>不可搭配 <code>expr PRECEDING</code> 和 <code>expr FOLLOWING</code></p>
<p>在没有排序情况下搭配帧范围语句时，将会有以下效果：</p>
<ul>
<li><p>（<span class="red">拓展上下限</span>）搭配 <code>CURRENT ROW</code> 、 <code>UNBOUNDED PRECEDING</code> 、 <code>BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING</code> ：</p>
  <pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT id, r1, SUM(r1) OVER
(PARTITION BY id 
RANGE &#123; CURRENT ROW | UNBOUNDED PRECEDING | BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING &#125;
)
AS wf_result
FROM t1
WHERE id IN (1, 2);</code></pre>

<p>  <img src="https://s1.ax1x.com/2022/06/17/XqTcpq.png" alt="NO ORDER RANGE + any.png"></p>
<blockquote>
<p>在当前分组下，每一行对当前组所有行运算</p>
</blockquote>
</li>
</ul>
<br />

<p>在没有 <code>ORDER BY</code> 时，可搭配所有帧范围语句</p>
<p>在有排序情况下搭配帧范围语句时，将会有以下效果：</p>
<ul>
<li><p>（<span class="red">当前值</span>）搭配 <code>CURRENT ROW</code> （指定开始值，结束值默认当前行的值）:</p>
  <pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT id, r1, SUM(r1) OVER (PARTITION BY id ORDER BY r1 RANGE CURRENT ROW) AS wf_result
FROM t1
WHERE id &#x3D; 1;</code></pre>

<p>  <img src="https://s1.ax1x.com/2022/06/17/XqOZfH.png" alt="WITH ORDER RANGE + CURRENT ROW.png"></p>
<blockquote>
<p>在当前分组下，每一行需要对其本身和与其值（以排序字段的值为依据）相同的行进行运算</p>
</blockquote>
</li>
<li><p>（<span class="red">无穷小于等于当前值</span>）搭配 <code>UNBOUNDED PRECEDING</code> （指定开始值，结束值默认当前行的值）：</p>
  <pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT id, r1, SUM(r1) OVER (PARTITION BY id ORDER BY r1 RANGE UNBOUNDED PRECEDING) AS wf_result
FROM t1
WHERE id &#x3D; 1;</code></pre>

<p>  <img src="https://s1.ax1x.com/2022/06/17/XqOb3d.png" alt="WITH ORDER RANGE + UNBOUNDED PRECEDING.png"></p>
<blockquote>
<p>在当前分组下，每一行需要对其本身和所有小于等于其值（以排序字段的值为依据）的行运算</p>
</blockquote>
</li>
<li><p>（<span class="red">满足 距离当前值 ≤ expr，并小于当前值</span>）搭配 <code>expr PRECEDING</code> （指定开始值，结束值默认当前行的值）：</p>
  <pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT id, r1, SUM(r1) OVER (PARTITION BY id ORDER BY r1 RANGE 2 PRECEDING) AS wf_result
FROM t1
WHERE id &#x3D; 1;</code></pre>

<p>  <img src="https://s1.ax1x.com/2022/06/17/XqjawV.png" alt="WITH ORDER RANGE + expr PRECEDING.png"></p>
<blockquote>
<p>在当前分组下，每一行需要对其本身和满足以下条件的行运算：</p>
<ol>
<li>小于等于当前值</li>
<li>与当前值的距离小于等于expr</li>
</ol>
</blockquote>
</li>
<li><p>（<span class="red">无穷大于等于当前值</span>）搭配 <code>UNBOUNDED FOLLOWING</code> （指定开始值与结束值）：</p>
  <pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT id, r1, SUM(r1) OVER (PARTITION BY id ORDER BY r1 ASC RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) AS wf_result
FROM t1
WHERE id &#x3D; 1;</code></pre>

<p>  <img src="https://s1.ax1x.com/2022/06/17/Xqvt9e.png" alt="WITH ORDER RANGE + UNBOUNDED FOLLOWING.png"></p>
<blockquote>
<p>在当前分组下，每一行需要对其本身和所有大于等于其值（以排序字段的值为依据）的行运算</p>
</blockquote>
</li>
<li><p>（<span class="red">满足 距离当前值 ≤ expr，并大于当前值</span>）搭配 <code>expr FOLLOWING</code> （指定开始值与结束值）：</p>
  <pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT id, r1, SUM(r1) OVER (PARTITION BY id ORDER BY r1 ASC RANGE BETWEEN CURRENT ROW AND 2 FOLLOWING) AS wf_result
FROM t1
WHERE id &#x3D; 1;</code></pre>

<p>  <img src="https://s1.ax1x.com/2022/06/17/XqxtaV.png" alt="WITH ORDER RANGE + expr FOLLOWING.png"></p>
<blockquote>
<p>在当前分组下，每一行需要对其本身和满足以下条件的行运算：</p>
<ol>
<li>大于等于当前值</li>
<li>与当前值的距离小于等于expr</li>
</ol>
</blockquote>
</li>
</ul>
<hr>
<p><strong>各窗口函数详解——序号函数</strong></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 准备工作
CREATE TABLE goods
(
    id          INT PRIMARY KEY AUTO_INCREMENT,
    category_id INT,
    category    VARCHAR(15),
    &#96;name&#96;      VARCHAR(30),
    price       DOUBLE(10, 2),
    stock       INT,
    upper_time  DATETIME
);

INSERT INTO goods(category_id, category, name, price, stock, upper_time)
VALUES (1, &#39;女装&#x2F;女士精品&#39;, &#39;T恤&#39;, 39.90, 1000, &#39;2020-11-10 00:00:00&#39;),
       (1, &#39;女装&#x2F;女士精品&#39;, &#39;连衣裙&#39;, 79.90, 2500, &#39;2020-11-10 00:00:00&#39;),
       (1, &#39;女装&#x2F;女士精品&#39;, &#39;卫衣&#39;, 89.90, 1500, &#39;2020-11-10 00:00:00&#39;),
       (1, &#39;女装&#x2F;女士精品&#39;, &#39;牛仔裤&#39;, 89.90, 3500, &#39;2020-11-10 00:00:00&#39;),
       (1, &#39;女装&#x2F;女士精品&#39;, &#39;百褶裙&#39;, 29.90, 500, &#39;2020-11-10 00:00:00&#39;),
       (1, &#39;女装&#x2F;女士精品&#39;, &#39;呢绒外套&#39;, 399.90, 1200, &#39;2020-11-10 00:00:00&#39;),
       (2, &#39;户外运动&#39;, &#39;自行车&#39;, 399.90, 1000, &#39;2020-11-10 00:00:00&#39;),
       (2, &#39;户外运动&#39;, &#39;山地自行车&#39;, 1399.90, 2500, &#39;2020-11-10 00:00:00&#39;),
       (2, &#39;户外运动&#39;, &#39;登山杖&#39;, 59.90, 1500, &#39;2020-11-10 00:00:00&#39;),
       (2, &#39;户外运动&#39;, &#39;骑行设备&#39;, 399.90, 3500, &#39;2020-11-10 00:00:00&#39;),
       (2, &#39;户外运动&#39;, &#39;运动外套&#39;, 799.90, 500, &#39;2020-11-10 00:00:00&#39;),
       (2, &#39;户外运动&#39;, &#39;滑板&#39;, 499.90, 1200, &#39;2020-11-10 00:00:00&#39;);</code></pre>

<p><span class="red bold">ROW_NUMBER()：</span></p>
<ul>
<li>需求：将goods表按照商品分类进行不合并分组，并且每个商品分类下的商品按照价格降序排列</li>
</ul>
<p><img src="https://s1.ax1x.com/2022/06/16/X7QrKP.md.png" alt="X7QrKP.md.png"></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT ROW_NUMBER() OVER (PARTITION BY category_id ORDER BY price DESC) AS row_num,
       id,
       category_id,
       category,
       &#96;name&#96;,
       price,
       stock
FROM goods;</code></pre>

<ul>
<li><p>需求：查询每个商品分类下价格最高的3种商品</p>
<p>  <span class="red">在上一个查询结果的基础上取row_num为1~3即可</span></p>
</li>
</ul>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT *
FROM (SELECT ROW_NUMBER() OVER (PARTITION BY category_id ORDER BY price DESC) AS row_num,
             id,
             category_id,
             category,
             &#96;name&#96;,
             price
      FROM goods) AS temp
where row_num &lt;&#x3D; 3;</code></pre>

<p><span class="red bold">RANK()：</span></p>
<p>将上面 <code>ROW_NUMBER</code> 的第一个需求所使用的函数换成 <code>RANK()</code> 结果会变成：</p>
<p><img src="https://s1.ax1x.com/2022/06/16/X71ATU.png" alt="ROW_NUMBER.png"></p>
<p>即若排序依据的字段中有相同的值，它们的序号相同，<span class="red">并且相同的序号会占用下面的序号</span></p>
<p><span class="red bold">DENSE_RANK()：</span></p>
<p>这个就显而易见了，<span class="red">相同的序号不会占用下面的序号</span>：</p>
<p><img src="https://s1.ax1x.com/2022/06/16/X71jnx.png" alt="DENSE_RANK.png"></p>
<hr>
<p><strong>各窗口函数详解——分布函数</strong></p>
<p><span class="red bold">PERCENT_RANK()：</span></p>
<p>这个就有点……它是上面排序函数的一个再处理版本，它表示当前排序状态下，每一行是（该分组的）总行数的百分比（如：你的高考成绩是在所有成绩降序的前百分之n，就是这个意思）</p>
<p>它的计算公式为：<br><code>(RANK - 1) / (TOTAL_ROWS - 1)</code></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT RANK() OVER w         AS simple_rank,
       PERCENT_RANK() OVER w AS p_rank,
       category_id,
       category,
       &#96;name&#96;,
       price
FROM goods WINDOW w AS (PARTITION BY category_id ORDER BY price DESC);</code></pre>

<p><span class="red">注意：</span> <code>PERCENT_RANK()</code> 的排序方式固定为 <code>RANK()</code> ，也就是并列排序且相同序号会占用下面的序号，跟我上一个字段使用RANK查询没有任何关系</p>
<p><img src="https://s1.ax1x.com/2022/06/16/X7YIfS.png" alt="PERCENT_RANK.png"></p>
<p><span class="red bold">CUME_DIST()：</span></p>
<p>用于查询小于或等于某个值（比较依据是排序依据，也就是窗口中 <code>ORDER BY</code> 的字段）的记录占（该分类）总记录的比例</p>
<p>其计算公式为：</p>
<p><code>COUNT( SELECT * WHERE 排序依据字段值 &lt;= 当前记录中排序依据字段的值 ) / TOTAL_ROWS</code></p>
<ul>
<li>需求：查询goods表中各商品分类下，小于或等于当前商品价格的商品数的比例（我在说什么？）</li>
</ul>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT CUME_DIST() OVER (PARTITION BY category_id ORDER BY price ASC) AS cd,
       category_id,
       category,
       &#96;name&#96;,
       price
FROM goods;</code></pre>

<p><img src="https://s1.ax1x.com/2022/06/16/X7w3Jx.png" alt="CUME_DIST.png"></p>
<ul>
<li>一些解释：<ul>
<li>百褶裙只有它自己的价格满足 &lt;&#x3D; 29.9，因此是 (1 &#x2F; 6)</li>
<li>T恤有百褶裙和T恤的价格满足 &lt;&#x3D; 39.9，因此是 (2 &#x2F; 6)</li>
<li>卫衣有百褶裙、T恤、连衣裙和牛仔裤的价格满足 &lt;&#x3D; 89.9，因此是 (5 &#x2F; 6)</li>
</ul>
</li>
</ul>
<hr>
<p><strong>各窗口函数详解——前后函数</strong></p>
<p><span class="red bold">LAG(字段名, [n], [default])：</span></p>
<p>在当前分组中，返回当前行的前n行（不写则为1）的字段名对应的值，</p>
<ul>
<li>需求：使goods表按价格升序排列，并且查询每一件商品与它价格第一档次的商品的价格差值</li>
</ul>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 获得上一个档次的价格
SELECT category_id,
       category,
       &#96;name&#96;,
       price,
       LAG(price) OVER (PARTITION BY category_id ORDER BY price ASC)
FROM goods;</code></pre>

<p><img src="https://s1.ax1x.com/2022/06/16/X7DwTJ.png" alt="LAG(1).png"></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 计算差值
SELECT *, price - lag_price AS difference
FROM (SELECT category_id,
             category,
             &#96;name&#96;,
             price,
             LAG(price, 1) OVER (PARTITION BY category_id ORDER BY price ASC) AS lag_price
      FROM goods) AS tab_lag_price;</code></pre>

<p><img src="https://s1.ax1x.com/2022/06/16/X7DO0g.png" alt="LAG(2).png"></p>
<p><span class="red bold">LEAD(字段名, [n], [default])：</span></p>
<p>这个就是返回当前字段的后n行（不写则为1）的指定字段的值</p>
<p>将 <code>LAG</code> 换成 <code>LEAD</code> 的效果：</p>
<p><img src="https://s1.ax1x.com/2022/06/16/X7rRg0.png" alt="LEAD.png"></p>
<hr>
<p><strong>各窗口函数详解——首尾函数</strong></p>
<p><span class="red bold">FIRST_VALUE(字段名)：</span></p>
<p>取当前组的第一行的指定字段的值，并且应用到当前组的全部行</p>
<ul>
<li>需求：查询每一件商品与其同类别商品中最便宜的商品的价格差</li>
</ul>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 查询每组最低的价格
SELECT category_id,
       category,
       &#96;name&#96;,
       price,
       FIRST_VALUE(price) OVER (PARTITION BY category_id ORDER BY price) AS cheapest
FROM goods;</code></pre>

<p><img src="https://s1.ax1x.com/2022/06/16/X7ywTg.png" alt="FIRST_VALUE(1).png"></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 比较差值
SELECT *, price - cheapest
FROM (SELECT category_id,
             category,
             &#96;name&#96;,
             price,
             FIRST_VALUE(price) OVER (PARTITION BY category_id ORDER BY price) AS cheapest
      FROM goods) AS tab_cheapest;</code></pre>

<p><img src="https://s1.ax1x.com/2022/06/16/X7691I.png" alt="FIRST_VALUE(2).png"></p>
<p><span class="red bold">LAST_VALUE(字段名)：</span></p>
<p>取当前组最后一行指定字段的值，并将其应用到该组全部行</p>
<p><span class="red">注意：</span>若不指定框架范围（FRAME）则默认框架范围为当前分组下第一行至当前行，这样LAST_VALUE永远是当前行，<span class="red">因此 <code>LAST_VALUE</code> 必须指定框架</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 查询每组最高的价格
SELECT category_id,
       category,
       &#96;name&#96;,
       price,
       LAST_VALUE(price) OVER (PARTITION BY category_id ORDER BY price ASC RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS &quot;most expensive&quot;
FROM goods;</code></pre>

<p><img src="https://s1.ax1x.com/2022/06/16/X72n9H.png" alt="LAST_VALUE.png"></p>
<hr>
<p><strong>各窗口函数详解——其他函数</strong></p>
<p><span class="red bold">NTH_VALUE(字段名, n)</span></p>
<p>首尾函数的自定义版本，取当前组第n行指定字段的值，并将其应用到该组RANK() &gt;&#x3D; n 的行（也就是说当RANK()出现并列时，NULL会少几个）</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 取价格排名第二商品名
SELECT category_id,
       category,
       &#96;name&#96;,
       price,
       NTH_VALUE(&#96;name&#96;, 2) OVER (PARTITION BY category_id ORDER BY price ASC) AS &quot;No.2&quot;
FROM goods;</code></pre>

<p><img src="https://s1.ax1x.com/2022/06/16/X7RlRJ.png" alt="NTH_VALUE.png"></p>
<p>当n为3时，本应该是骑行设备的N0.3才能取到值，但由于自行车与骑行设备价格相同，视为并列，因此自行车也能取到值。<br /><br>相比之下T恤就因为与连衣裙价格不同而取不到值</p>
<p><img src="https://s1.ax1x.com/2022/06/16/X7W4AK.png" alt="NTH_VALUE(特殊).png"></p>
<p><span class="red bold">NTILE(n)：</span></p>
<p>用于再分组，在目前分组的基础上，再分别在每一组内，分成n组，并且标上序号，序号相同代表同一组</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 在根据商品类别分类的基础上
-- 再将每一个商品类别的商品分为三组
SELECT NTILE(3) OVER (PARTITION BY category_id ORDER BY price) AS No,
       category_id,
       category,
       &#96;name&#96;,
       price
FROM goods;</code></pre>

<p><img src="https://s1.ax1x.com/2022/06/16/X7hkxH.png" alt="NTILE.png"></p>
<h2 id="MySQL8-0新特性——公用表表达式"><a href="#MySQL8-0新特性——公用表表达式" class="headerlink" title="MySQL8.0新特性——公用表表达式"></a>MySQL8.0新特性——公用表表达式</h2><hr>
<p><strong>公用表表达式</strong></p>
<p>公用表表达式（CTE）可以理解为一个可以复用的子查询结果，复用范围是当前语句，当一次查询很复杂并且要使用很多次同一个子查询时，使用CTE</p>
<p><span class="red">把它当成一张临时表看待，而不是一个单字段查询结果，它应该被使用在 FROM 后面，而不是 WHERE 后面</span></p>
<p><span class="red bold">公用表表达式的分类：</span></p>
<ul>
<li>普通公用表表达式</li>
<li>递归公用表表达式</li>
</ul>
<hr>
<p><strong>普通公用表表达式</strong></p>
<p><span class="red bold">结构：</span></p>
<p><span class="red">注意：</span>它的可复用范围就只是下面那一句，那一句结束了，那就没了</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">WITH CTE名
AS
(子查询)

-- 不一定是SLECT, DELETE, UPDATE都行，反正就是调用 
SELECT * FROM CTE名 WHERE ...;


-- 举例：你可能会有这样的使用场景

WITH CTE名
AS
(子查询)

SELECT * FROM CTE名 WHERE xxx &#x3D; (
    SELECT * FROM xxx
    JOIN CTE名 ON ...
    WHERE ...
);</code></pre>

<hr>
<p><strong>递归公用表表达式</strong></p>
<p>相比于普通公用表表达式，递归公用表表达式多一个功能，就是可以自己调用自己</p>
<blockquote>
<p>参考资料：<a target="_blank" rel="noopener" href="https://www.jb51.net/article/236061.htm">https://www.jb51.net/article/236061.htm</a></p>
</blockquote>
<p><span class="red bold">结构：</span></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 定义
WITH RECURSIVE CTE名
AS (
    根查询
    UNION [ALL]
    递归查询
    )

-- 调用
SELECT | DELETE | UPDATE 语句;</code></pre>

<ul>
<li>例子1：查询族谱中指定的某个人及其所有后代</li>
</ul>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 表与数据
CREATE TABLE member
(
    id     INT PRIMARY KEY AUTO_INCREMENT,
    &#96;name&#96; CHAR(2),
    father CHAR(7),
    mother CHAR(7)
);

INSERT INTO member(&#96;name&#96;, father, mother)
VALUES (&#39;张一&#39;, &#39;UNKNOWN&#39;, &#39;UNKNOWN&#39;),
       (&#39;李一&#39;, &#39;UNKNOWN&#39;, &#39;UNKNOWN&#39;),
       (&#39;孙一&#39;, &#39;UNKNOWN&#39;, &#39;UNKNOWN&#39;),
       (&#39;张二&#39;, &#39;张一&#39;, &#39;李一&#39;),
       (&#39;张三&#39;, &#39;张一&#39;, &#39;李一&#39;),
       (&#39;李二&#39;, &#39;UNKNOWN&#39;, &#39;UNKNOWN&#39;),
       (&#39;孙二&#39;, &#39;孙一&#39;, &#39;张二&#39;),
       (&#39;曹一&#39;, &#39;UNKNOWN&#39;, &#39;UNKNOWN&#39;),
       (&#39;张四&#39;, &#39;张三&#39;, &#39;李二&#39;),
       (&#39;张七&#39;, &#39;曹一&#39;, &#39;张四&#39;),
       (&#39;张五&#39;, &#39;张三&#39;, &#39;李二&#39;);</code></pre>

<table>
<thead>
<tr>
<th align="center">族谱图</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="https://s1.ax1x.com/2022/06/16/XH73jO.png" alt="公用表表达式例子1-1.png"></td>
</tr>
</tbody></table>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 查询族谱中指定的某个人及其所有后代
DELIMITER $

CREATE PROCEDURE query_posterity(IN member_id INT)
BEGIN
    WITH RECURSIVE posterity
                       AS (
            -- 根查询
            SELECT &#96;name&#96; FROM member
            WHERE id &#x3D; member_id
            UNION
            SELECT child.&#96;name&#96; FROM member child
                     JOIN posterity parents ON child.father &#x3D; parents.name OR child.mother &#x3D; parents.name)

    SELECT * FROM posterity;
END $

DELIMITER ;</code></pre>

<p><img src="https://s1.ax1x.com/2022/06/16/XHOWct.png" alt="公用表表达式例子1-2.png"></p>
<ul>
<li>例子2：查询族谱中身份为某个人的孙子的成员</li>
</ul>
<p><span class="red">思路：</span>这个例子其实是上一个例子的小扩展，从最年长的人开始，后面两代（包括）之后的人都是某个人的孙子。<br /><span class="red">也就是说需要记录代数</span></p>
<p><img src="https://s1.ax1x.com/2022/06/16/XHjVRs.png" alt="公用表表达式例子2-1.png"></p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 查询族谱中指定的某个人及其所有后代
DELIMITER $

CREATE PROCEDURE query_posterity()
BEGIN
    WITH RECURSIVE posterity
                       AS (
            -- 根查询，定义一个字段记录代数
            SELECT &#96;name&#96;, 0 AS generation FROM member
            WHERE id &#x3D; 1
            UNION
            -- 注意连接两个表的字段数量要对的上
            -- 代数增加也是必要的
            SELECT child.&#96;name&#96;, generation + 1 FROM member child
                     JOIN posterity parents ON child.father &#x3D; parents.name OR child.mother &#x3D; parents.name)

    -- 只选出下两代（包括）之后的人
    SELECT * FROM posterity WHERE generation &gt;&#x3D; 2;
END $

DELIMITER ;</code></pre>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/MySQL/" rel="tag"># MySQL</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/04/24/Java-JUC/" rel="prev" title="Java JUC">
                  <i class="fa fa-chevron-left"></i> Java JUC
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/06/09/Idea-DataGrip%E6%BF%80%E6%B4%BB/" rel="next" title="Idea/DataGrip激活">
                  Idea/DataGrip激活 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Loliconkelvin</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/components/prism-core.min.js" integrity="sha256-4mJNT2bMXxcc1GCJaxBmMPdmah5ji0Ldnd79DKd1hoM=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/plugins/autoloader/prism-autoloader.min.js" integrity="sha256-dL6vkUiCn30lPTN9cVrmQHo5UQmEwDMrx2ppAk4IhVk=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/plugins/line-numbers/prism-line-numbers.min.js" integrity="sha256-9cmf7tcLdXpKsPi/2AWE93PbZpTp4M4tqzFk+lWomjU=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
